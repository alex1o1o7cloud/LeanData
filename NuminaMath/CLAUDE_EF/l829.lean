import Mathlib

namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_unique_solution_n_equals_one_l829_82902

theorem unique_solution_n_equals_one (n : ℕ+) :
  (∃ x : ℤ, (x : ℚ)^(n : ℕ) + ((2 : ℚ) + x)^(n : ℕ) + ((2 : ℚ) - x)^(n : ℕ) = 0) ↔ n = 1 := by
  sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_unique_solution_n_equals_one_l829_82902


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_heron_formula_specific_triangle_l829_82952

noncomputable def triangle_area (a b c : ℝ) : ℝ :=
  let s := (a + b + c) / 2
  Real.sqrt (s * (s - a) * (s - b) * (s - c))

theorem heron_formula_specific_triangle :
  triangle_area 65 60 25 = 750 := by
  -- Proof steps would go here
  sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_heron_formula_specific_triangle_l829_82952


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_train_passing_time_l829_82987

-- Define the train's length in meters
noncomputable def trainLength : ℝ := 65

-- Define the train's speed in km/h
noncomputable def trainSpeed : ℝ := 36

-- Define the conversion factor from km/h to m/s
noncomputable def kmhToMs : ℝ := 5 / 18

-- Define the function to calculate the time to pass the post
noncomputable def timeToPassPost (length : ℝ) (speed : ℝ) : ℝ :=
  length / (speed * kmhToMs)

-- Theorem statement
theorem train_passing_time :
  timeToPassPost trainLength trainSpeed = 6.5 := by
  -- Unfold the definitions
  unfold timeToPassPost trainLength trainSpeed kmhToMs
  
  -- Perform the calculation
  norm_num
  
  -- Close the proof
  done

end NUMINAMATH_CALUDE_ERRORFEEDBACK_train_passing_time_l829_82987


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_thermometer_price_is_two_l829_82909

/-- Represents the sales data for Wal-Mart in December --/
structure WalmartSales where
  hwb_price : ℚ  -- Price of a hot-water bottle
  total_sales : ℚ  -- Total sales in December
  therm_to_hwb_ratio : ℕ  -- Ratio of thermometers to hot-water bottles sold
  hwb_sold : ℕ  -- Number of hot-water bottles sold

/-- Calculates the price of a thermometer based on the given sales data --/
def thermometer_price (sales : WalmartSales) : ℚ :=
  let hwb_revenue := sales.hwb_price * sales.hwb_sold
  let therm_revenue := sales.total_sales - hwb_revenue
  let therm_sold := sales.therm_to_hwb_ratio * sales.hwb_sold
  therm_revenue / therm_sold

/-- Theorem stating that the price of a thermometer is $2 given the specific sales data --/
theorem thermometer_price_is_two (sales : WalmartSales)
  (h1 : sales.hwb_price = 6)
  (h2 : sales.total_sales = 1200)
  (h3 : sales.therm_to_hwb_ratio = 7)
  (h4 : sales.hwb_sold = 60) :
  thermometer_price sales = 2 := by
  sorry

#eval thermometer_price { hwb_price := 6, total_sales := 1200, therm_to_hwb_ratio := 7, hwb_sold := 60 }

end NUMINAMATH_CALUDE_ERRORFEEDBACK_thermometer_price_is_two_l829_82909


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_ellipse_revolution_volume_is_16pi_l829_82924

/-- The volume of the solid of revolution generated by rotating the upper half of an ellipse around the x-axis -/
noncomputable def ellipse_revolution_volume (a b : ℝ) : ℝ :=
  2 * Real.pi * a * b^2

/-- The semi-major axis of the ellipse -/
def semi_major_axis : ℝ := 3

/-- The semi-minor axis of the ellipse -/
def semi_minor_axis : ℝ := 2

theorem ellipse_revolution_volume_is_16pi : 
  ellipse_revolution_volume semi_major_axis semi_minor_axis = 16 * Real.pi := by
  unfold ellipse_revolution_volume semi_major_axis semi_minor_axis
  simp [Real.pi]
  ring
  sorry


end NUMINAMATH_CALUDE_ERRORFEEDBACK_ellipse_revolution_volume_is_16pi_l829_82924


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_stock_change_l829_82969

theorem stock_change (x : ℝ) (hx : x > 0) : 
  let day1 := x * 0.85
  let day2 := day1 * 1.25
  (day2 - x) / x * 100 = 6.25 := by sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_stock_change_l829_82969


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_F_range_l829_82930

-- Define the function f
noncomputable def f : ℝ → ℝ := sorry

-- Define the range of f
def range_f : Set ℝ := Set.Icc 1 3

-- Assume f's range is [1,3]
axiom f_range : ∀ y ∈ range_f, ∃ x, f x = y

-- Define F in terms of f
noncomputable def F (x : ℝ) : ℝ := 1 - 2 * f (x + 3)

-- Define the expected range of F
def range_F : Set ℝ := Set.Icc (-5) (-1)

-- The theorem to prove
theorem F_range : 
  (∀ y ∈ range_F, ∃ x, F x = y) ∧ 
  (∀ x, F x ∈ range_F) := by
  sorry


end NUMINAMATH_CALUDE_ERRORFEEDBACK_F_range_l829_82930


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_intervals_of_increase_range_of_m_l829_82941

-- Define the function f
noncomputable def f (x : ℝ) : ℝ := (1/3) * x^3 - 4 * x + 4

-- Theorem for the intervals of increase
theorem intervals_of_increase :
  (∀ x y : ℝ, x < y ∧ x < -2 → f x < f y) ∧
  (∀ x y : ℝ, 2 < x ∧ x < y → f x < f y) ∧
  (∀ x y : ℝ, x ∈ Set.Ioo (-2) 2 → y ∈ Set.Ioo (-2) 2 → x < y → f y < f x) :=
sorry

-- Theorem for the range of m
theorem range_of_m :
  ∀ m : ℝ, (∀ x : ℝ, x ∈ Set.Icc (-4) 3 → f x ≤ m^2 + m + 10/3) →
  (m ≤ -2 ∨ m ≥ 1) :=
sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_intervals_of_increase_range_of_m_l829_82941


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_min_distance_midpoint_theorem_l829_82934

/-- The minimum distance from the midpoint of a chord to the x-axis on a parabola -/
noncomputable def min_distance_midpoint_to_x_axis (a m : ℝ) : ℝ :=
  if m ≥ 1 / a then (2 * m * a - 1) / (4 * a) else a * m^2 / 4

/-- Theorem: Minimum distance from the midpoint of a chord to the x-axis on a parabola -/
theorem min_distance_midpoint_theorem (a m : ℝ) (ha : a > 0) :
  let y (x : ℝ) := a * x^2
  ∃ (A B : ℝ × ℝ), 
    A.2 = y A.1 ∧ 
    B.2 = y B.1 ∧ 
    (A.1 - B.1)^2 + (A.2 - B.2)^2 = m^2 ∧
    ∀ (M : ℝ × ℝ), 
      M.1 = (A.1 + B.1) / 2 ∧ 
      M.2 = (A.2 + B.2) / 2 →
      M.2 ≥ min_distance_midpoint_to_x_axis a m :=
by
  sorry


end NUMINAMATH_CALUDE_ERRORFEEDBACK_min_distance_midpoint_theorem_l829_82934


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_smallest_circle_radius_l829_82995

theorem smallest_circle_radius
  (r₁ r₂ r₃ : ℝ)
  (h_touch : r₁ > 0 ∧ r₂ > 0 ∧ r₃ > 0)
  (h_right_triangle : (r₁ + r₂)^2 = (r₁ + r₃)^2 + (r₂ + r₃)^2)
  (h_r₁ : r₁ = 6)
  (h_r₂ : r₂ = 4) :
  r₃ = 2 := by
  sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_smallest_circle_radius_l829_82995


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_b_work_time_l829_82986

-- Define the work rates relative to B
noncomputable def work_rate_A (rate_B : ℝ) : ℝ := rate_B / 2
noncomputable def work_rate_C (rate_B : ℝ) : ℝ := rate_B / 3

-- Define the combined work rate
noncomputable def combined_work_rate (rate_B : ℝ) : ℝ :=
  work_rate_A rate_B + rate_B + work_rate_C rate_B

-- Theorem statement
theorem b_work_time (rate_B : ℝ) (h : combined_work_rate rate_B = 1 / 15) :
  1 / rate_B = 27.5 := by
  sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_b_work_time_l829_82986


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_same_foci_l829_82932

-- Define the ellipse
def ellipse (x y : ℝ) : Prop := x^2 / 25 + y^2 / 9 = 1

-- Define the rectangular hyperbola
def rect_hyperbola (x y : ℝ) : Prop := x^2 / 8 - y^2 / 8 = 1

-- Function to calculate the foci of an ellipse
noncomputable def ellipse_foci (a b : ℝ) : ℝ := Real.sqrt (a^2 - b^2)

-- Function to calculate the foci of a rectangular hyperbola
noncomputable def rect_hyperbola_foci (a : ℝ) : ℝ := Real.sqrt (2 * a^2)

-- Theorem stating that the rectangular hyperbola has the same foci as the ellipse
theorem same_foci :
  ellipse_foci 5 3 = rect_hyperbola_foci (Real.sqrt 8) :=
by sorry


end NUMINAMATH_CALUDE_ERRORFEEDBACK_same_foci_l829_82932


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_triangle_reconstruction_from_altitude_feet_l829_82992

/-- A point is the foot of an altitude if it lies on the perpendicular line from a vertex to the opposite side. -/
def is_altitude (vertex foot₁ foot₂ opposite : ℝ × ℝ) : Prop :=
  (foot₁.1 - foot₂.1) * (vertex.1 - opposite.1) +
  (foot₁.2 - foot₂.2) * (vertex.2 - opposite.2) = 0 ∧
  foot₁ ≠ foot₂ ∧
  ∃ t : ℝ, vertex = (1 - t) • foot₁ + t • foot₂

/-- Given the feet of the altitudes of a triangle, the original triangle can be uniquely reconstructed. -/
theorem triangle_reconstruction_from_altitude_feet
  (A₁ B₁ C₁ : ℝ × ℝ) :
  ∃! (A B C : ℝ × ℝ),
    (is_altitude A B₁ C B) ∧
    (is_altitude B C₁ A C) ∧
    (is_altitude C A₁ B A) :=
sorry


end NUMINAMATH_CALUDE_ERRORFEEDBACK_triangle_reconstruction_from_altitude_feet_l829_82992


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_triangle_square_theorem_l829_82998

/-- Triangle with external squares -/
structure TriangleWithSquares where
  /-- Side lengths of the original triangle -/
  a : ℝ
  b : ℝ
  c : ℝ
  /-- Area of the original triangle -/
  S : ℝ
  /-- Side lengths of the triangle formed by square centers -/
  a₁ : ℝ
  b₁ : ℝ
  c₁ : ℝ
  /-- Area of the triangle formed by square centers -/
  S₁ : ℝ

/-- Properties of a triangle with external squares -/
def triangle_square_properties (T : TriangleWithSquares) : Prop :=
  (T.a₁^2 + T.b₁^2 + T.c₁^2 = T.a^2 + T.b^2 + T.c^2 + 6*T.S) ∧
  (T.S₁ - T.S = (T.a^2 + T.b^2 + T.c^2) / 8)

/-- Theorem stating the properties of a triangle with external squares -/
theorem triangle_square_theorem (T : TriangleWithSquares) :
  triangle_square_properties T := by
  sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_triangle_square_theorem_l829_82998


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_tshirt_fandoms_tom_fandoms_l829_82972

theorem tshirt_fandoms (original_price : ℝ) (discount_percent : ℝ) (tax_percent : ℝ) 
  (shirts_per_fandom : ℕ) (total_paid : ℝ) : ℝ :=
  let discounted_price := original_price * (1 - discount_percent / 100)
  let cost_per_fandom := discounted_price * (shirts_per_fandom : ℝ)
  let pre_tax_total := total_paid / (1 + tax_percent / 100)
  pre_tax_total / cost_per_fandom

theorem tom_fandoms : 
  tshirt_fandoms 15 20 10 5 264 = 4 := by
  sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_tshirt_fandoms_tom_fandoms_l829_82972


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_f_f_two_thirds_f_f_unique_solution_l829_82917

-- Define the piecewise function f
noncomputable def f (x : ℝ) : ℝ :=
  if x < 1 then 3 * x - 1 else Real.exp (Real.log 2 * x)

-- Theorem 1: f(f(2/3)) = 2
theorem f_f_two_thirds : f (f (2/3)) = 2 := by sorry

-- Theorem 2: f(f(5/9)) = 1 and it's the unique solution
theorem f_f_unique_solution :
  f (f (5/9)) = 1 ∧ ∀ a : ℝ, f (f a) = 1 → a = 5/9 := by sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_f_f_two_thirds_f_f_unique_solution_l829_82917


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_distance_PF_is_two_l829_82973

/-- The parabola y^2 = 4x with point P(1,2) and focus F -/
structure Parabola where
  -- Define the parabola y^2 = 4x
  equation : ∀ x y, y^2 = 4*x → (x, y) ∈ Set.range (λ t : ℝ ↦ (t, 2*Real.sqrt t))
  -- P is a point on the parabola
  P : ℝ × ℝ
  P_on_parabola : P.2^2 = 4*P.1 ∧ P = (1, 2)
  -- F is the focus of the parabola
  F : ℝ × ℝ
  F_is_focus : F = (1, 0)

/-- The distance between two points in ℝ² -/
noncomputable def distance (p q : ℝ × ℝ) : ℝ :=
  Real.sqrt ((p.1 - q.1)^2 + (p.2 - q.2)^2)

/-- Theorem: The distance |PF| is 2 -/
theorem distance_PF_is_two (para : Parabola) : distance para.P para.F = 2 := by
  sorry


end NUMINAMATH_CALUDE_ERRORFEEDBACK_distance_PF_is_two_l829_82973


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_sum_of_exponents_simplified_l829_82901

-- Define the variables
variable (a b c : ℝ)
variable (h : a ≠ 0 ∧ b ≠ 0 ∧ c ≠ 0)

-- Define the expression under the fourth root
def radicand (a b c : ℝ) : ℝ := 120 * a^6 * b^8 * c^17

-- Define a function to calculate the sum of exponents outside the radical
def sum_of_exponents_outside (x : ℝ) : ℕ := 5

-- State the theorem
theorem sum_of_exponents_simplified (a b c : ℝ) (h : a ≠ 0 ∧ b ≠ 0 ∧ c ≠ 0) :
  sum_of_exponents_outside ((radicand a b c)^(1/4 : ℝ)) = 5 := by sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_sum_of_exponents_simplified_l829_82901


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_sequence_exceeds_1994_l829_82936

noncomputable def a : ℕ → ℝ → ℝ
  | 0, q => 1
  | 1, q => 1 + q
  | (n + 2), q => 
    if n % 2 = 0 then
      ((n / 2 + 1) * q + 1) ^ 2
    else
      ((n / 2 + 1) * q + 1) * ((n / 2 + 2) * q + 1)

theorem sequence_exceeds_1994 (q : ℝ) (hq : q > 0) : 
  ∃ N : ℕ, ∀ n : ℕ, n > N → a n q > 1994 := by
  sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_sequence_exceeds_1994_l829_82936


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_probability_increases_with_favorable_cases_probability_increases_with_favorable_and_total_probability_change_equal_increase_probability_unchanged_proportional_increase_l829_82962

/-- Probability is defined as the fraction of favorable cases over total cases -/
noncomputable def probability (a m : ℝ) : ℝ := a / m

/-- The probability is always between 0 and 1 (inclusive) -/
axiom probability_bounds {a m : ℝ} (h : 0 ≤ a ∧ a ≤ m) : 0 ≤ probability a m ∧ probability a m ≤ 1

/-- Theorem: Probability increases when favorable cases increase and unfavorable cases decrease -/
theorem probability_increases_with_favorable_cases {a m k : ℝ} 
  (h1 : 0 < k) (h2 : k ≤ m - a) : 
  probability a m < probability (a + k) m := by sorry

/-- Theorem: Probability increases when favorable cases increase and total cases increase -/
theorem probability_increases_with_favorable_and_total {a m k : ℝ} 
  (h1 : 0 < k) (h2 : a ≤ m) : 
  probability a m < probability (a + k) (m + k) := by sorry

/-- Theorem: Probability change when both favorable and unfavorable cases increase by the same amount -/
theorem probability_change_equal_increase {a m k : ℝ} (h1 : 0 < k) (h2 : 0 < m) :
  probability (a + k) (m + 2*k) < probability a m ↔ a > m/2 := by sorry

/-- Theorem: Probability remains unchanged when favorable and unfavorable cases increase proportionally -/
theorem probability_unchanged_proportional_increase {a m c : ℝ} 
  (h1 : 0 < c) (h2 : 0 < m) (h3 : a ≤ m) :
  probability (c * a) (c * m) = probability a m := by sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_probability_increases_with_favorable_cases_probability_increases_with_favorable_and_total_probability_change_equal_increase_probability_unchanged_proportional_increase_l829_82962


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_derivative_sign_theorem_l829_82982

open Real

noncomputable def f (x : ℝ) : ℝ := exp x + 1 / x

theorem derivative_sign_theorem (x₀ m n : ℝ) :
  (∀ x > 0, DifferentiableAt ℝ f x) →
  x₀ > 0 →
  (deriv f) x₀ = 0 →
  0 < m → m < x₀ →
  x₀ < n →
  (deriv f) m < 0 ∧ (deriv f) n > 0 := by
  sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_derivative_sign_theorem_l829_82982


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_sum_of_three_equals_fourth_l829_82918

theorem sum_of_three_equals_fourth
  (S : Finset ℕ)
  (h1 : S.card = 69)
  (h2 : ∀ x, x ∈ S → x > 0 ∧ x ≤ 100) :
  ∃ a b c d, a ∈ S ∧ b ∈ S ∧ c ∈ S ∧ d ∈ S ∧
    a ≠ b ∧ a ≠ c ∧ a ≠ d ∧ b ≠ c ∧ b ≠ d ∧ c ≠ d ∧
    a + b + c = d :=
by sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_sum_of_three_equals_fourth_l829_82918


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_arithmetic_sequence_problem_l829_82993

noncomputable def arithmetic_sequence (a₁ : ℝ) (d : ℝ) (n : ℕ) : ℝ := a₁ + (n - 1 : ℝ) * d

noncomputable def arithmetic_sequence_sum (a₁ : ℝ) (d : ℝ) (n : ℕ) : ℝ := n / 2 * (2 * a₁ + (n - 1 : ℝ) * d)

theorem arithmetic_sequence_problem (a₁ d : ℝ) (h₁ : a₁ = 2) (h₂ : d = 5) :
  (arithmetic_sequence a₁ d 21 = 102) ∧ 
  (arithmetic_sequence_sum a₁ d 21 = 1092) := by
  sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_arithmetic_sequence_problem_l829_82993


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_solution_set_of_inequality_l829_82974

noncomputable def f (x : ℝ) : ℝ := (x^3 - x) * (1/2 - 1/(Real.exp x + 1))

theorem solution_set_of_inequality :
  {x : ℝ | f x * Real.log (x + 2) ≤ 0} = Set.Ioc (-2) 1 := by sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_solution_set_of_inequality_l829_82974


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_fourth_sixth_root_ratio_cube_l829_82984

theorem fourth_sixth_root_ratio_cube (a : ℝ) (h : a > 0) :
  ((a^(1/4 : ℝ) / a^(1/6 : ℝ)) ^ (-3 : ℝ) : ℝ) = a^(-1/4 : ℝ) :=
by sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_fourth_sixth_root_ratio_cube_l829_82984


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_couch_price_l829_82907

open Real

theorem couch_price (chair_price : ℝ) 
  (table_price : ℝ) (couch_price : ℝ) (bookshelf_price : ℝ) 
  (chair_discount : ℝ) (couch_discount : ℝ) (sales_tax : ℝ) 
  (total_budget : ℝ) :
  table_price = 3 * chair_price →
  couch_price = 5 * table_price →
  bookshelf_price = 0.5 * couch_price →
  chair_discount = 0.2 →
  couch_discount = 0.1 →
  sales_tax = 0.08 →
  total_budget = 900 →
  total_budget = (chair_price * (1 - chair_discount) + 
                  table_price + 
                  couch_price * (1 - couch_discount) + 
                  bookshelf_price) * (1 + sales_tax) →
  abs (couch_price - 503.85) < 0.01 := by
sorry


end NUMINAMATH_CALUDE_ERRORFEEDBACK_couch_price_l829_82907


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_custom_op_2004_l829_82978

/-- Custom operation ※ for natural numbers -/
def custom_op : ℕ → ℕ → ℕ
  | 0, 1 => 3
  | n + 1, 1 => 3 + custom_op n 1
  | _, _ => 0  -- Default case for other inputs

theorem custom_op_2004 : custom_op 2004 1 = 6012 := by
  sorry

#eval custom_op 2004 1  -- This will evaluate the result

end NUMINAMATH_CALUDE_ERRORFEEDBACK_custom_op_2004_l829_82978


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_no_three_similar_parts_l829_82959

theorem no_three_similar_parts (x : ℝ) (hx : x > 0) :
  ¬ ∃ (a b c : ℝ), a > 0 ∧ b > 0 ∧ c > 0 ∧
    a + b + c = x ∧
    (a ≤ Real.sqrt 2 * b ∧ b ≤ Real.sqrt 2 * a) ∧
    (a ≤ Real.sqrt 2 * c ∧ c ≤ Real.sqrt 2 * a) ∧
    (b ≤ Real.sqrt 2 * c ∧ c ≤ Real.sqrt 2 * b) :=
by
  sorry


end NUMINAMATH_CALUDE_ERRORFEEDBACK_no_three_similar_parts_l829_82959


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_specific_triangle_properties_l829_82994

/-- Triangle with sides a, b, c and circumradius r -/
structure RightTriangle where
  a : ℝ
  b : ℝ
  c : ℝ
  r : ℝ

/-- The specific triangle from the problem -/
noncomputable def specificTriangle : RightTriangle :=
  { a := 12,
    b := 35,
    c := 37,
    r := 37 / 2 }

/-- The area of a right triangle -/
noncomputable def triangleArea (t : RightTriangle) : ℝ := (t.a * t.b) / 2

theorem specific_triangle_properties :
  triangleArea specificTriangle = 210 ∧
  specificTriangle.r = 37 / 2 ∧
  specificTriangle.a ^ 2 + specificTriangle.b ^ 2 = specificTriangle.c ^ 2 := by
  sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_specific_triangle_properties_l829_82994


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_suv_max_distance_l829_82931

/-- Represents the fuel efficiency of an SUV in different driving conditions -/
structure SUVFuelEfficiency where
  highway_mpg : ℚ
  city_mpg : ℚ

/-- Calculates the maximum distance an SUV can travel given its fuel efficiency and available fuel -/
def max_distance (efficiency : SUVFuelEfficiency) (fuel_gallons : ℚ) : ℚ :=
  max efficiency.highway_mpg efficiency.city_mpg * fuel_gallons

/-- Theorem: The maximum distance the SUV can travel on 21 gallons of gasoline is 256.2 miles -/
theorem suv_max_distance :
  let efficiency : SUVFuelEfficiency := ⟨12.2, 7.6⟩
  let fuel_gallons : ℚ := 21
  max_distance efficiency fuel_gallons = 256.2 := by
  sorry

#eval max_distance ⟨12.2, 7.6⟩ 21

end NUMINAMATH_CALUDE_ERRORFEEDBACK_suv_max_distance_l829_82931


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_ellipse_and_line_properties_l829_82919

-- Define the ellipse and its properties
def Ellipse (a b : ℝ) := {p : ℝ × ℝ | (p.1^2 / a^2) + (p.2^2 / b^2) = 1}

-- Define the foci of the ellipse
noncomputable def Foci (a b : ℝ) : ℝ × ℝ × ℝ × ℝ := 
  let c := Real.sqrt (a^2 - b^2)
  (c, 0, -c, 0)

-- Define the circle with diameter F₁F₂
def Circle (a b : ℝ) := {p : ℝ × ℝ | p.1^2 + p.2^2 = a^2 - b^2}

-- Define the line l
def Line (k m : ℝ) := {p : ℝ × ℝ | p.2 = k * p.1 + m}

-- State the theorem
theorem ellipse_and_line_properties
  (a b : ℝ) 
  (h_ab : a > b ∧ b > 0) 
  (P : ℝ × ℝ)
  (h_P : P = (-1, Real.sqrt 2 / 2))
  (h_P_on_ellipse : P ∈ Ellipse a b)
  (h_perpendicular : let (x1, y1, x2, y2) := Foci a b
                     (P.1 - x1) * (x2 - x1) + (P.2 - y1) * (y2 - y1) = 0)
  (k m : ℝ)
  (h_tangent : ∀ p ∈ Circle a b, p.2 ≠ k * p.1 + m)
  (h_intersect : ∃ A B, A ≠ B ∧ A ∈ Ellipse a b ∩ Line k m ∧ B ∈ Ellipse a b ∩ Line k m)
  : (∀ p, p ∈ Ellipse a b ↔ p.1^2 / 2 + p.2^2 = 1) ∧
    (∀ A B, A ∈ Ellipse a b → B ∈ Ellipse a b → A.1 * B.1 + A.2 * B.2 = 2/3 → k = 1 ∨ k = -1) := by
  sorry


end NUMINAMATH_CALUDE_ERRORFEEDBACK_ellipse_and_line_properties_l829_82919


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_rectangle_opposite_corners_distance_sum_equal_l829_82968

/-- Predicate to assert that four points form a rectangle -/
def IsRectangle (A B C D : ℝ × ℝ) : Prop :=
  ∃ a b : ℝ, 
    A = (-a, -b) ∧ 
    B = (a, -b) ∧ 
    C = (a, b) ∧ 
    D = (-a, b)

/-- Given a rectangle ABCD and a point P in the plane, prove that the sum of squared distances
    from P to opposite corners is equal. -/
theorem rectangle_opposite_corners_distance_sum_equal 
  (A B C D P : ℝ × ℝ) 
  (h_rectangle : IsRectangle A B C D) : 
  ‖A - P‖^2 + ‖C - P‖^2 = ‖B - P‖^2 + ‖D - P‖^2 := by
  sorry


end NUMINAMATH_CALUDE_ERRORFEEDBACK_rectangle_opposite_corners_distance_sum_equal_l829_82968


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_problem_statement_l829_82914

-- Define the function f
def f (m : ℝ) (x : ℝ) : ℝ := m - |x - 1|

-- Define the solution set condition
def solution_set (m : ℝ) : Set ℝ := {x | f m (x + 2) + f m (x - 2) ≥ 0}

-- State the theorem
theorem problem_statement :
  ∃ m : ℝ, (solution_set m = Set.Icc (-2) 4) ∧
  (∀ a b c : ℝ, a > 0 → b > 0 → c > 0 →
    1/a + 1/(2*b) + 1/(3*c) = m →
    a + 2*b + 3*c ≥ 3) :=
by
  -- Proof goes here
  sorry


end NUMINAMATH_CALUDE_ERRORFEEDBACK_problem_statement_l829_82914


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_domain_of_log_function_l829_82981

-- Define the function as noncomputable due to Real.log
noncomputable def f (x : ℝ) : ℝ := Real.log (2 * x + 4)

-- State the theorem about the domain of the function
theorem domain_of_log_function :
  {x : ℝ | (2 * x + 4) > 0} = {x : ℝ | x > -2} :=
by sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_domain_of_log_function_l829_82981


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_range_of_a_l829_82915

theorem range_of_a (a b : ℝ) (h : a - 4 * Real.sqrt b = 2 * Real.sqrt (a - b)) : 
  a ∈ Set.Icc 4 20 ∪ {0} := by
  sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_range_of_a_l829_82915


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_jack_speed_is_12mph_l829_82913

/-- The speed Jack needs to jog to reach the beach before his ice cream melts -/
noncomputable def jack_jogging_speed (melt_time : ℚ) (blocks : ℕ) (block_length : ℚ) : ℚ :=
  (blocks * block_length) / (melt_time / 60)

/-- Theorem: Jack needs to jog at 12 miles per hour -/
theorem jack_speed_is_12mph :
  jack_jogging_speed 10 16 (1/8) = 12 := by
  -- Unfold the definition of jack_jogging_speed
  unfold jack_jogging_speed
  -- Simplify the expression
  simp
  -- The proof is complete
  rfl

end NUMINAMATH_CALUDE_ERRORFEEDBACK_jack_speed_is_12mph_l829_82913


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_circle_center_and_radius_l829_82950

/-- A circle in the xy-plane -/
structure Circle where
  center : ℝ × ℝ
  radius : ℝ

/-- A line in the xy-plane -/
structure Line where
  a : ℝ
  b : ℝ
  c : ℝ

/-- The origin point (0, 0) -/
def origin : ℝ × ℝ := (0, 0)

/-- Check if two vectors are perpendicular -/
def perpendicular (v1 v2 : ℝ × ℝ) : Prop :=
  v1.1 * v2.1 + v1.2 * v2.2 = 0

/-- Given circle equation coefficients and a line, find the circle -/
noncomputable def find_circle (m : ℝ) (l : Line) : Circle :=
  { center := (-1/2, 3), radius := 5/2 }

theorem circle_center_and_radius 
  (m : ℝ)
  (l : Line)
  (h1 : l.a = 1 ∧ l.b = 2 ∧ l.c = 3)
  (h2 : ∃ (p q : ℝ × ℝ), p ≠ q ∧
        p.1^2 + p.2^2 + p.1 - 6*p.2 + m = 0 ∧
        q.1^2 + q.2^2 + q.1 - 6*q.2 + m = 0 ∧
        p.1 + 2*p.2 = 3 ∧ q.1 + 2*q.2 = 3)
  (h3 : ∃ (p q : ℝ × ℝ), p ≠ q ∧
        perpendicular (p.1 - origin.1, p.2 - origin.2) (q.1 - origin.1, q.2 - origin.2) ∧
        p.1^2 + p.2^2 + p.1 - 6*p.2 + m = 0 ∧
        q.1^2 + q.2^2 + q.1 - 6*q.2 + m = 0 ∧
        p.1 + 2*p.2 = 3 ∧ q.1 + 2*q.2 = 3)
  : (find_circle m l).center = (-1/2, 3) ∧ (find_circle m l).radius = 5/2 := by
  sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_circle_center_and_radius_l829_82950


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_cube_surface_area_l829_82977

/-- The surface area of a cube with edge length 4 cm is 96 square centimeters. -/
theorem cube_surface_area : ∀ (edge_length : ℝ), 
  edge_length = 4 → 6 * edge_length^2 = 96 := by
  intro edge_length h
  rw [h]
  norm_num

#check cube_surface_area

end NUMINAMATH_CALUDE_ERRORFEEDBACK_cube_surface_area_l829_82977


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_train_passing_tree_l829_82963

/-- Calculates the time (in seconds) for a train to pass a stationary point -/
noncomputable def train_passing_time (length : ℝ) (speed_kmh : ℝ) : ℝ :=
  let speed_ms := speed_kmh * (5 / 18)  -- Convert km/h to m/s
  length / speed_ms

/-- Theorem: A train 420 meters long, traveling at 63 km/hr, takes 24 seconds to pass a stationary point -/
theorem train_passing_tree : train_passing_time 420 63 = 24 := by
  sorry

-- Remove the #eval statement as it's not computable
-- #eval train_passing_time 420 63

end NUMINAMATH_CALUDE_ERRORFEEDBACK_train_passing_tree_l829_82963


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_second_tree_red_percentage_l829_82939

def total_apples_per_tree : ℕ := 20
def first_tree_red_percentage : ℚ := 40 / 100
def total_red_apples : ℕ := 18

theorem second_tree_red_percentage :
  (total_red_apples - (first_tree_red_percentage * total_apples_per_tree).floor) / total_apples_per_tree = 1 / 2 := by
  sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_second_tree_red_percentage_l829_82939


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_investment_growth_rate_proof_l829_82910

/-- Calculates the growth rate of an investment portfolio in the second year, given:
  * initial_investment: The initial amount invested
  * first_year_growth_rate: The growth rate in the first year
  * additional_investment: The amount added after the first year
  * final_value: The final value of the portfolio after two years
-/
noncomputable def second_year_growth_rate (initial_investment : ℝ) (first_year_growth_rate : ℝ) 
  (additional_investment : ℝ) (final_value : ℝ) : ℝ :=
  let first_year_value := initial_investment * (1 + first_year_growth_rate)
  let second_year_initial := first_year_value + additional_investment
  (final_value / second_year_initial) - 1

/-- Theorem stating that for the given investment scenario, the second year growth rate is 0.1 -/
theorem investment_growth_rate_proof :
  second_year_growth_rate 80 0.15 28 132 = 0.1 := by
  -- Proof goes here
  sorry


end NUMINAMATH_CALUDE_ERRORFEEDBACK_investment_growth_rate_proof_l829_82910


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_f_increasing_interval_l829_82921

-- Define the function f(x) = (1/2)^(x^2 - 2)
noncomputable def f (x : ℝ) : ℝ := (1/2) ^ (x^2 - 2)

-- Define the increasing interval
def increasing_interval : Set ℝ := Set.Ici 0

-- Theorem statement
theorem f_increasing_interval :
  {x : ℝ | ∀ y, x < y → f x < f y} = increasing_interval :=
sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_f_increasing_interval_l829_82921


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_triangle_area_side_length_a_l829_82958

-- Define the triangle ABC
structure Triangle where
  A : Real  -- Angle A
  B : Real  -- Angle B
  C : Real  -- Angle C
  a : Real  -- Side length opposite to angle A
  b : Real  -- Side length opposite to angle B
  c : Real  -- Side length opposite to angle C

-- Define the given conditions
def triangle_conditions (t : Triangle) : Prop :=
  Real.cos (t.A / 2) = 2 * Real.sqrt 5 / 5 ∧
  t.b * t.c * Real.cos t.A = 15

-- Theorem for the area of the triangle
theorem triangle_area (t : Triangle) (h : triangle_conditions t) :
  (1 / 2) * t.b * t.c * Real.sin t.A = 10 :=
sorry

-- Theorem for the side length a
theorem side_length_a (t : Triangle) (h : triangle_conditions t) (h_tanB : Real.tan t.B = 2) :
  t.a = 2 * Real.sqrt 5 :=
sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_triangle_area_side_length_a_l829_82958


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_abs_sum_equals_sum_abs_condition_l829_82900

theorem abs_sum_equals_sum_abs_condition :
  (∀ a b : ℝ, a * b > 0 → |a + b| = |a| + |b|) ∧
  (∃ a b : ℝ, |a + b| = |a| + |b| ∧ a * b ≤ 0) :=
by
  constructor
  · intro a b hab
    sorry
  · use (0 : ℝ), (0 : ℝ)
    constructor
    · simp
    · simp


end NUMINAMATH_CALUDE_ERRORFEEDBACK_abs_sum_equals_sum_abs_condition_l829_82900


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_hiking_time_is_23_point_5_l829_82983

/-- Represents the hiking conditions and calculates the total time -/
noncomputable def hiking_time (base_pace : ℝ) (total_distance : ℝ) (elevation_up : ℝ) (elevation_down : ℝ) : ℝ :=
  let segment1_distance := 12
  let segment1_elevation := 3000
  let segment2_distance := 9
  let segment2_elevation := -2000
  let segment3_distance := 15
  let segment3_elevation_up := 3000
  let segment3_elevation_down := -2000
  
  let pace_change_rate := 1 / 1000
  
  let segment1_time := segment1_distance / (base_pace - segment1_elevation * pace_change_rate)
  let segment2_time := segment2_distance / (base_pace - segment2_elevation * pace_change_rate)
  let segment3_time_up := (segment3_distance * (segment3_elevation_up / (segment3_elevation_up - segment3_elevation_down))) / 
                          (base_pace - segment3_elevation_up * pace_change_rate)
  let segment3_time_down := (segment3_distance * (-segment3_elevation_down / (segment3_elevation_up - segment3_elevation_down))) / 
                            (base_pace - segment3_elevation_down * pace_change_rate)
  
  segment1_time + segment2_time + segment3_time_up + segment3_time_down

/-- Theorem stating that the total hiking time is 23.5 hours -/
theorem hiking_time_is_23_point_5 :
  hiking_time 4 36 6000 4000 = 23.5 := by
  sorry


end NUMINAMATH_CALUDE_ERRORFEEDBACK_hiking_time_is_23_point_5_l829_82983


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_unique_solution_l829_82951

def is_valid_sequence (seq : List ℕ) : Prop :=
  seq.length = 9 ∧
  seq.toFinset = Finset.range 9 ∧
  ∀ i, i < 7 → ¬(seq[i]! < seq[i+1]! ∧ seq[i+1]! < seq[i+2]!) ∧
  ∀ i, i < 7 → ¬(seq[i]! > seq[i+1]! ∧ seq[i+1]! > seq[i+2]!)

def matches_visible (seq : List ℕ) : Prop :=
  seq[0]! = 7 ∧ seq[1]! = 6 ∧ seq[2]! = 3 ∧ seq[3]! = 4 ∧ seq[6]! = 8

theorem unique_solution :
  ∀ seq : List ℕ, is_valid_sequence seq → matches_visible seq →
    seq[4]! = 5 ∧ seq[5]! = 2 ∧ seq[7]! = 9 := by
  sorry

#check unique_solution

end NUMINAMATH_CALUDE_ERRORFEEDBACK_unique_solution_l829_82951


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_cone_slant_height_is_5_l829_82975

/-- A right cone with height h and base diameter d -/
structure RightCone where
  h : ℝ
  d : ℝ

/-- The slant height of a right cone -/
noncomputable def slant_height (c : RightCone) : ℝ := 
  Real.sqrt (c.h^2 + (c.d/2)^2)

/-- Theorem: For a right cone with height 3 and base diameter 8, 
    the slant height (distance from apex to base circumference) is 5 -/
theorem cone_slant_height_is_5 :
  let c : RightCone := ⟨3, 8⟩
  slant_height c = 5 := by
  sorry


end NUMINAMATH_CALUDE_ERRORFEEDBACK_cone_slant_height_is_5_l829_82975


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_mirror_side_length_is_21_l829_82923

/-- The length of each side of a square mirror, given the dimensions of the rectangular wall it's hung on. -/
noncomputable def mirror_side_length (wall_width wall_length : ℝ) : ℝ :=
  let wall_area := wall_width * wall_length
  let mirror_area := wall_area / 2
  Real.sqrt mirror_area

/-- Theorem stating that the length of each side of the square mirror is 21 inches. -/
theorem mirror_side_length_is_21 :
  mirror_side_length 28 31.5 = 21 := by
  sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_mirror_side_length_is_21_l829_82923


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_worst_player_is_son_or_sister_l829_82926

-- Define the family members
inductive FamilyMember
  | Woman
  | Brother
  | Son
  | Daughter
  | Sister

-- Define the chess skill level
def ChessSkill := FamilyMember → ℕ

-- Define the age of family members
def Age := FamilyMember → ℕ

-- Define the sex of family members
def Sex := FamilyMember → Bool

-- Define the twin relationship
def Twin := FamilyMember → Option FamilyMember

-- Define the conditions of the problem
structure ChessProblem where
  skill : ChessSkill
  age : Age
  sex : Sex
  twin : Twin
  worst_player : FamilyMember
  best_player : FamilyMember
  h1 : ∀ m, skill m ≥ skill worst_player
  h2 : ∀ m, skill m ≤ skill best_player
  h3 : ∀ (h : Option.isSome (twin worst_player)), 
       sex (Option.get (twin worst_player) h) ≠ sex best_player
  h4 : age worst_player = age best_player
  h5 : (twin worst_player = some FamilyMember.Brother ∧ worst_player = FamilyMember.Sister) ∨
       (twin worst_player = some FamilyMember.Sister ∧ worst_player = FamilyMember.Woman) ∨
       (twin worst_player = some FamilyMember.Son ∧ worst_player = FamilyMember.Daughter) ∨
       (twin worst_player = some FamilyMember.Daughter ∧ worst_player = FamilyMember.Son)

-- Theorem to prove
theorem worst_player_is_son_or_sister (p : ChessProblem) :
  p.worst_player = FamilyMember.Son ∨ p.worst_player = FamilyMember.Sister :=
by
  sorry


end NUMINAMATH_CALUDE_ERRORFEEDBACK_worst_player_is_son_or_sister_l829_82926


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_line_equation_proof_l829_82955

noncomputable section

-- Define the ellipse E
def ellipse (x y : ℝ) : Prop := x^2 / 4 + y^2 / 2 = 1

-- Define the line l
def line_l (x y : ℝ) : Prop := x - 4*y - 9/2 = 0

-- Define the midpoint of AB
def midpoint_AB : ℝ × ℝ := (1/2, -1)

-- Theorem statement
theorem line_equation_proof :
  ∀ (A B : ℝ × ℝ),
  ellipse A.1 A.2 →
  ellipse B.1 B.2 →
  ((A.1 + B.1) / 2, (A.2 + B.2) / 2) = midpoint_AB →
  line_l A.1 A.2 ∧ line_l B.1 B.2 :=
by
  sorry

end

end NUMINAMATH_CALUDE_ERRORFEEDBACK_line_equation_proof_l829_82955


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_triangle_inequality_range_l829_82942

theorem triangle_inequality_range (a b c A B C : ℝ) : 
  0 < A ∧ 0 < B ∧ 0 < C ∧ A + B + C = π →  -- Triangle is acute
  a > 0 ∧ b > 0 ∧ c > 0 →  -- Sides are positive
  a * Real.sin B = b * Real.sin A ∧ b * Real.sin C = c * Real.sin B ∧ c * Real.sin A = a * Real.sin C →  -- Sine rule
  (1/2) * a * b * Real.sin C = 2 →  -- Area condition
  a * Real.cos B = b * (1 + Real.cos A) →  -- Given condition
  8 * Real.sqrt 2 - 8 < (c + a - b) * (c + b - a) ∧ 
  (c + a - b) * (c + b - a) < 8 := by
sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_triangle_inequality_range_l829_82942


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_midpoint_coordinate_product_l829_82956

/-- Given a line segment AB where M(2,5) is the midpoint and A(3,1) is one endpoint,
    the product of coordinates of point B is 9. -/
theorem midpoint_coordinate_product : 
  ∀ (B : ℝ × ℝ),
  let M : ℝ × ℝ := (2, 5)
  let A : ℝ × ℝ := (3, 1)
  (M.1 = (A.1 + B.1) / 2 ∧ M.2 = (A.2 + B.2) / 2) →
  B.1 * B.2 = 9 := by
  intro B
  intro h
  sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_midpoint_coordinate_product_l829_82956


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_f_range_l829_82912

open Real

/-- The function f defined on (0, +∞)³ to ℝ -/
noncomputable def f (x y z : ℝ) : ℝ := 
  (x * sqrt y + y * sqrt z + z * sqrt x) / sqrt ((x + y) * (y + z) * (z + x))

theorem f_range : 
  (∀ ε > 0, ∃ (x y z : ℝ), x > 0 ∧ y > 0 ∧ z > 0 ∧ f x y z < ε) ∧
  (∀ (a b c : ℝ), a > 0 → b > 0 → c > 0 → f a b c ≤ 3 / (2 * sqrt 2)) :=
by sorry


end NUMINAMATH_CALUDE_ERRORFEEDBACK_f_range_l829_82912


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_lightning_distance_is_three_and_quarter_l829_82925

/-- The speed of sound in feet per second -/
def speed_of_sound : ℝ := 1088

/-- The number of feet in a mile -/
def feet_per_mile : ℝ := 5280

/-- The time in seconds between seeing lightning and hearing thunder -/
def time_delay : ℝ := 15

/-- Rounds a real number to the nearest quarter -/
noncomputable def round_to_nearest_quarter (x : ℝ) : ℝ :=
  ⌊(x * 4 + 0.5)⌋ / 4

/-- The distance from Linus to the lightning strike in miles -/
noncomputable def lightning_distance : ℝ :=
  round_to_nearest_quarter ((speed_of_sound * time_delay) / feet_per_mile)

theorem lightning_distance_is_three_and_quarter :
  lightning_distance = 3.25 := by sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_lightning_distance_is_three_and_quarter_l829_82925


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_f_symmetry_l829_82903

noncomputable def f (x : ℝ) := 3 * Real.sin (2 * x - Real.pi / 3)

theorem f_symmetry (x : ℝ) :
  (f (11 * Real.pi / 12 + x) = f (11 * Real.pi / 12 - x)) ∧
  (f (2 * Real.pi / 3 + x) = f (2 * Real.pi / 3 - x)) :=
by sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_f_symmetry_l829_82903


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_more_good_than_bad_l829_82922

/-- Represents a moment in time on a 24-hour clock --/
structure ClockTime where
  hours : ℕ
  minutes : ℕ
  seconds : ℕ
  h_valid : hours < 24
  m_valid : minutes < 60
  s_valid : seconds < 60

/-- All clock hands are on the same side of the given diameter --/
def handsOnSameSide (t : ClockTime) (diameter : ℝ) : Prop := sorry

/-- Determines if a given moment is "good" --/
def isGoodTime (t : ClockTime) : Prop :=
  ∃ (diameter : ℝ), handsOnSameSide t diameter

/-- Calculates the total duration of good moments in a day --/
noncomputable def totalGoodTime : ℝ := sorry

/-- Calculates the total duration of bad moments in a day --/
noncomputable def totalBadTime : ℝ := sorry

/-- The main theorem stating that there is more good time than bad time --/
theorem more_good_than_bad : totalGoodTime > totalBadTime := by sorry


end NUMINAMATH_CALUDE_ERRORFEEDBACK_more_good_than_bad_l829_82922


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_isosceles_triangle_l829_82999

noncomputable section

open Real

theorem isosceles_triangle (A B C : ℝ) (a b c : ℝ) : 
  0 < a ∧ 0 < b ∧ 0 < c →  -- Ensure positive side lengths
  0 < A ∧ A < π ∧ 0 < B ∧ B < π ∧ 0 < C ∧ C < π →  -- Angle range constraints
  A + B + C = π →  -- Angle sum in a triangle
  Real.sin (A - B) = (a / (a + b)) * Real.sin A * Real.cos B - (b / (a + b)) * Real.sin B * Real.cos A →
  A = B :=
by sorry

end

end NUMINAMATH_CALUDE_ERRORFEEDBACK_isosceles_triangle_l829_82999


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_h_equality_l829_82944

-- Define the function h as noncomputable
noncomputable def h (x : ℝ) : ℝ := ((x + 5) / 5) ^ (1/4)

-- State the theorem
theorem h_equality (x : ℝ) : h (3 * x) = 3 * h x ↔ x = -200/39 := by
  sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_h_equality_l829_82944


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_train_crossing_time_approx_48_seconds_l829_82965

/-- The time taken for two trains moving in opposite directions to cross each other -/
noncomputable def train_crossing_time (speed1 speed2 length1 length2 : ℝ) : ℝ :=
  let relative_speed := speed1 + speed2
  let total_length := length1 + length2
  let relative_speed_mps := relative_speed * (5 / 18)
  (total_length * 1000) / relative_speed_mps

theorem train_crossing_time_approx_48_seconds :
  ∃ ε > 0, ε < 0.01 →
  |train_crossing_time 60 90 1.10 0.9 - 48| < ε := by
  sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_train_crossing_time_approx_48_seconds_l829_82965


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_volume_of_solid_revolution_l829_82908

/-- The volume of a solid of revolution --/
noncomputable def volume_of_revolution (f : ℝ → ℝ) (a b : ℝ) : ℝ :=
  Real.pi * ∫ x in a..b, (f x)^2

/-- The bounding function for the region --/
noncomputable def f (x : ℝ) : ℝ := 4 / x

theorem volume_of_solid_revolution :
  volume_of_revolution f 1 4 = 12 * Real.pi := by
  sorry

#check volume_of_solid_revolution

end NUMINAMATH_CALUDE_ERRORFEEDBACK_volume_of_solid_revolution_l829_82908


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_intersection_M_N_l829_82904

def M : Set ℤ := {-4, -2, 0, 2, 4, 6}

def N : Set ℤ := {x : ℤ | (x : ℝ)^2 - x - 12 ≤ 0}

theorem intersection_M_N : M ∩ N = {-2, 0, 2, 4} := by
  sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_intersection_M_N_l829_82904


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_board_can_be_emptied_l829_82949

/-- A move on the board can be one of three types -/
inductive Move
  | PlaceTromino : Fin 2 → Fin 2 → Move  -- Place an L-shaped tromino at (i, j)
  | RemoveColumn : Fin 2 → Move        -- Remove all stones from column i
  | RemoveRow : Fin 2 → Move           -- Remove all stones from row j

/-- The state of the board -/
def Board (n : Nat) := Fin n → Fin n → Bool

/-- Apply a move to the board -/
def applyMove (n : Nat) (b : Board n) (m : Move) : Board n :=
  sorry

/-- A sequence of moves -/
def MoveSequence := List Move

/-- Apply a sequence of moves to the board -/
def applyMoveSequence (n : Nat) (b : Board n) (ms : MoveSequence) : Board n :=
  sorry

/-- Check if the board is empty -/
def isEmpty (n : Nat) (b : Board n) : Prop :=
  ∀ i j, b i j = false

/-- The main theorem -/
theorem board_can_be_emptied (n : Nat) (h : n ≥ 2) :
  (∃ ms : MoveSequence, ms ≠ [] ∧
    isEmpty n (applyMoveSequence n (λ _ _ => false) ms)) ↔ 3 ∣ n :=
  sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_board_can_be_emptied_l829_82949


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_range_of_f_l829_82920

open Set
open Function
open Real

/-- The function f(x) = 1/x^2 for x ≠ 0 -/
noncomputable def f : {x : ℝ | x ≠ 0} → ℝ := fun x ↦ 1 / x^2

/-- The range of f is the set of all positive real numbers -/
theorem range_of_f : range f = {y : ℝ | y > 0} := by sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_range_of_f_l829_82920


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_vector_angle_condition_f_is_even_l829_82980

def vector_a : ℝ × ℝ := (1, 2)
def vector_b (k : ℝ) : ℝ × ℝ := (2, k)

def angle_acute (a b : ℝ × ℝ) : Prop :=
  a.1 * b.1 + a.2 * b.2 > 0 ∧ ¬(∃ t : ℝ, a = t • b ∨ b = t • a)

noncomputable def f (x : ℝ) : ℝ :=
  if x ≤ 0 then Real.sin (x + Real.pi/3) else Real.cos (x + Real.pi/6)

theorem vector_angle_condition (k : ℝ) :
  angle_acute vector_a (vector_b k) ↔ k > -1 ∧ k ≠ 4 :=
sorry

theorem f_is_even : ∀ x, f x = f (-x) :=
sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_vector_angle_condition_f_is_even_l829_82980


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_f_even_and_increasing_l829_82929

-- Define the function f(x) = log₂|x|
noncomputable def f (x : ℝ) : ℝ := Real.log (abs x) / Real.log 2

-- State the theorem
theorem f_even_and_increasing :
  (∀ x ∈ {x | x ≠ 0}, f x = f (-x)) ∧
  (∀ x y, 0 < x ∧ x < y → f x < f y) :=
by sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_f_even_and_increasing_l829_82929


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_f_is_odd_f_12_in_terms_of_a_f_is_increasing_l829_82961

-- Define the function f
variable (f : ℝ → ℝ)

-- Define the functional equation
axiom functional_equation : ∀ x y : ℝ, f (x + y) = f x + f y

-- Define the positivity condition
axiom f_positive : ∀ x : ℝ, x > 0 → f x > 0

-- Theorem 1: f is an odd function
theorem f_is_odd : ∀ x : ℝ, f (-x) = -f x := by sorry

-- Theorem 2: f(12) in terms of a
theorem f_12_in_terms_of_a (a : ℝ) (h : f (-3) = a) : f 12 = -4 * a := by sorry

-- Theorem 3: f is strictly increasing
theorem f_is_increasing : ∀ x y : ℝ, x < y → f x < f y := by sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_f_is_odd_f_12_in_terms_of_a_f_is_increasing_l829_82961


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_distance_from_c_to_a_l829_82953

/-- Represents a point in one-dimensional space -/
structure Point where
  position : ℝ

/-- Represents a person's movement -/
structure Movement where
  start : Point
  distance : ℝ
  direction : Bool  -- true for east, false for west

/-- Calculates the end point after a movement -/
def move (start : Point) (distance : ℝ) (direction : Bool) : Point :=
  if direction then
    { position := start.position + distance }
  else
    { position := start.position - distance }

/-- The main theorem -/
theorem distance_from_c_to_a 
  (a b c : Point)
  (move_to_b : Movement)
  (move_to_c : Movement)
  (h1 : move_to_b.start = a)
  (h2 : move_to_b.distance = 15)
  (h3 : move_to_b.direction = false)
  (h4 : b = move move_to_b.start move_to_b.distance move_to_b.direction)
  (h5 : move_to_c.start = b)
  (h6 : move_to_c.distance = 23)
  (h7 : move_to_c.direction = true)
  (h8 : c = move move_to_c.start move_to_c.distance move_to_c.direction) :
  |c.position - a.position| = 8 := by
  sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_distance_from_c_to_a_l829_82953


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_repeating_decimal_sum_of_fraction_parts_l829_82940

/-- The repeating decimal 0.345345... as a rational number -/
def repeating_decimal : ℚ := 345 / 999

/-- The fraction representation of the repeating decimal in lowest terms -/
def lowest_terms_fraction : ℚ := 115 / 333

theorem repeating_decimal_sum_of_fraction_parts : 
  (Int.gcd (lowest_terms_fraction.num) (lowest_terms_fraction.den) = 1) ∧
  (repeating_decimal = lowest_terms_fraction) ∧
  (lowest_terms_fraction.num + lowest_terms_fraction.den = 448) := by
  sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_repeating_decimal_sum_of_fraction_parts_l829_82940


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_scheduled_speed_l829_82957

/-- The distance between points A and B in kilometers. -/
noncomputable def a : ℝ := sorry

/-- The scheduled speed of the train in km/h. -/
noncomputable def v : ℝ := sorry

/-- The train arrives 20 minutes (1/3 hour) early when its speed is v + 5 km/h. -/
axiom early_arrival : a / v - a / (v + 5) = 1 / 3

/-- The train arrives 25 minutes (5/12 hour) late when its speed is v - 5 km/h. -/
axiom late_arrival : a / (v - 5) - a / v = 5 / 12

/-- The scheduled speed of the train is 45 km/h. -/
theorem scheduled_speed : v = 45 := by sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_scheduled_speed_l829_82957


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_probability_theorem_l829_82916

def num_teams : ℕ := 4
def team_sizes : List ℕ := [4, 6, 7, 9]
def co_captains_per_team : ℕ := 3

noncomputable def probability_all_co_captains : ℚ :=
  (List.sum (team_sizes.map (λ n => 1 / (Nat.choose n co_captains_per_team)))) / num_teams

theorem probability_theorem :
  probability_all_co_captains = 59 / 1680 :=
sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_probability_theorem_l829_82916


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_perimeter_of_triangle_wxy_l829_82935

-- Define the right prism
structure RightPrism :=
  (height : ℝ)
  (base_side_length : ℝ)

-- Define the triangle WXY
structure TriangleWXY (prism : RightPrism) :=
  (W : ℝ × ℝ × ℝ)
  (X : ℝ × ℝ × ℝ)
  (Y : ℝ × ℝ × ℝ)

-- Define the perimeter of the triangle
noncomputable def perimeter (triangle : TriangleWXY (RightPrism.mk 20 10)) : ℝ :=
  let (x₁, y₁, z₁) := triangle.W
  let (x₂, y₂, z₂) := triangle.X
  let (x₃, y₃, z₃) := triangle.Y
  (((x₂ - x₁)^2 + (y₂ - y₁)^2 + (z₂ - z₁)^2) ^ (1/2 : ℝ)) +
  (((x₃ - x₂)^2 + (y₃ - y₂)^2 + (z₃ - z₂)^2) ^ (1/2 : ℝ)) +
  (((x₁ - x₃)^2 + (y₁ - y₃)^2 + (z₁ - z₃)^2) ^ (1/2 : ℝ))

-- Theorem statement
theorem perimeter_of_triangle_wxy (triangle : TriangleWXY (RightPrism.mk 20 10)) :
  perimeter triangle = 5 * (2 * (5 ^ (1/2 : ℝ)) + 1) := by
  sorry


end NUMINAMATH_CALUDE_ERRORFEEDBACK_perimeter_of_triangle_wxy_l829_82935


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_monotonic_increasing_f_iff_a_in_range_l829_82946

-- Define the function f(x) as noncomputable due to its dependence on Real.sin
noncomputable def f (a : ℝ) (x : ℝ) : ℝ := x - (1/3) * Real.sin (2*x) + a * Real.sin x

-- State the theorem
theorem monotonic_increasing_f_iff_a_in_range :
  ∀ a : ℝ, (∀ x y : ℝ, x < y → f a x < f a y) ↔ -1/3 ≤ a ∧ a ≤ 1/3 := by
  sorry


end NUMINAMATH_CALUDE_ERRORFEEDBACK_monotonic_increasing_f_iff_a_in_range_l829_82946


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_repeatingDecimalSum_l829_82906

/-- Represents a repeating decimal with a single repeating digit -/
def repeatingDecimal (whole : ℚ) (rep : ℕ) : ℚ :=
  whole + (rep : ℚ) / 9

theorem repeatingDecimalSum :
  let a := repeatingDecimal 0 6
  let b := repeatingDecimal 0 2
  let c := repeatingDecimal 0 4
  a + b - c = 4 / 9 := by
    sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_repeatingDecimalSum_l829_82906


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_increase_1500_by_45_percent_l829_82933

/-- Calculates the result of increasing a number by a given percentage. -/
noncomputable def increase_by_percentage (initial : ℝ) (percentage : ℝ) : ℝ :=
  initial * (1 + percentage / 100)

/-- Theorem stating that increasing 1500 by 45% results in 2175. -/
theorem increase_1500_by_45_percent :
  increase_by_percentage 1500 45 = 2175 := by
  -- Unfold the definition of increase_by_percentage
  unfold increase_by_percentage
  -- Simplify the expression
  simp [mul_add, mul_div_cancel']
  -- Check that the result is equal to 2175
  norm_num


end NUMINAMATH_CALUDE_ERRORFEEDBACK_increase_1500_by_45_percent_l829_82933


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_arithmetic_sum_minimum_l829_82948

/-- An arithmetic sequence with first term a₁ and common difference d -/
def arithmetic_sequence (a₁ d : ℚ) (n : ℕ) : ℚ :=
  a₁ + (n - 1) * d

/-- Sum of the first n terms of an arithmetic sequence -/
def arithmetic_sum (a₁ d : ℚ) (n : ℕ) : ℚ :=
  n * a₁ + n * (n - 1) / 2 * d

/-- Theorem: For an arithmetic sequence with a₁ = -3 and S₅ = S₁₀,
    the sum S_n reaches its minimum value when n = 7 or n = 8 -/
theorem arithmetic_sum_minimum :
  ∃ (d : ℚ),
    arithmetic_sum (-3) d 5 = arithmetic_sum (-3) d 10 ∧
    (∀ (n : ℕ), n ≥ 1 →
      arithmetic_sum (-3) d n ≥ arithmetic_sum (-3) d 7 ∧
      arithmetic_sum (-3) d n ≥ arithmetic_sum (-3) d 8) ∧
    (∀ (n : ℕ), n = 7 ∨ n = 8 →
      ∃ (m : ℕ), m ≥ 1 ∧ m ≠ n ∧
        arithmetic_sum (-3) d n < arithmetic_sum (-3) d m) :=
by sorry


end NUMINAMATH_CALUDE_ERRORFEEDBACK_arithmetic_sum_minimum_l829_82948


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_meaningful_expression_l829_82966

-- Define the expression as noncomputable
noncomputable def f (m : ℝ) : ℝ := Real.sqrt (2 - m) / (m + 2)

-- State the theorem
theorem meaningful_expression (m : ℝ) :
  (∃ x, f m = x) ↔ (m ≤ 2 ∧ m ≠ -2) := by
  sorry


end NUMINAMATH_CALUDE_ERRORFEEDBACK_meaningful_expression_l829_82966


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_cost_price_approximation_l829_82967

-- Define the marked price
def marked_price : ℝ := 64.54

-- Define the relationship between selling price and marked price
def selling_price (m : ℝ) : ℝ := 0.92 * m

-- Define the relationship between selling price and cost price
def selling_price_from_cost (c : ℝ) : ℝ := 1.25 * c

-- Theorem stating the cost price is approximately 47.50
theorem cost_price_approximation :
  ∃ c : ℝ, (selling_price marked_price = selling_price_from_cost c) ∧ 
  (abs (c - 47.50) < 0.01) := by
  sorry


end NUMINAMATH_CALUDE_ERRORFEEDBACK_cost_price_approximation_l829_82967


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_direct_proportion_condition_direct_proportion_m_equals_two_l829_82911

/-- A function f(x) = ax^n is a direct proportion function if and only if n = 1 and a ≠ 0 -/
theorem direct_proportion_condition {a n : ℝ} (f : ℝ → ℝ) (h : ∀ x, f x = a * x ^ n) :
  (∃ k, ∀ x, f x = k * x) ↔ n = 1 ∧ a ≠ 0 := by sorry

/-- For the function y = (m+2)x^(m^2-3) to be a direct proportion function, m must equal 2 -/
theorem direct_proportion_m_equals_two (m : ℝ) :
  (∃ k, ∀ x, (m + 2) * x^(m^2 - 3) = k * x) ↔ m = 2 := by sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_direct_proportion_condition_direct_proportion_m_equals_two_l829_82911


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_tangent_sum_l829_82937

-- Define the function f
variable (f : ℝ → ℝ)

-- Define the condition for the tangent line
def tangent_condition (f : ℝ → ℝ) : Prop :=
  ∃ (m b : ℝ), m = (1/2) ∧ b = 3 ∧
  ∀ (x : ℝ), f 1 + (deriv f 1) * (x - 1) = m * x + b

-- Theorem statement
theorem tangent_sum (f : ℝ → ℝ) (h : tangent_condition f) :
  f 1 + deriv f 1 = 4 := by
  sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_tangent_sum_l829_82937


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_max_k_implies_n_11_l829_82927

theorem max_k_implies_n_11 
  (A : Finset ℕ) 
  (n : ℕ) 
  (k : ℕ)
  (A_subsets : Fin n → Finset ℕ)
  (h_subset : ∀ i : Fin n, A_subsets i ⊆ A)
  (h_card_eq : ∀ i : Fin n, (A_subsets i).card = k)
  (h_k_gt_half : k > A.card / 2)
  (h_triple_intersection : ∀ a b, a ∈ A → b ∈ A → 
    ∃ r s t : Fin n, r.val < s.val ∧ s.val < t.val ∧
    a ∈ (A_subsets r) ∩ (A_subsets s) ∩ (A_subsets t) ∧
    b ∈ (A_subsets r) ∩ (A_subsets s) ∩ (A_subsets t))
  (h_pairwise_intersection : ∀ i j : Fin n, i.val < j.val → 
    (A_subsets i ∩ A_subsets j).card ≤ 3)
  (h_k_max : ∀ k' A' n' (A_subsets' : Fin n' → Finset ℕ), 
    (∀ i : Fin n', A_subsets' i ⊆ A') → 
    (∀ i : Fin n', (A_subsets' i).card = k') → 
    k' > A'.card / 2 → 
    (∀ a b, a ∈ A' → b ∈ A' → 
      ∃ r s t : Fin n', r.val < s.val ∧ s.val < t.val ∧
      a ∈ (A_subsets' r) ∩ (A_subsets' s) ∩ (A_subsets' t) ∧
      b ∈ (A_subsets' r) ∩ (A_subsets' s) ∩ (A_subsets' t)) → 
    (∀ i j : Fin n', i.val < j.val → 
      (A_subsets' i ∩ A_subsets' j).card ≤ 3) → 
    k' ≤ k) :
  n = 11 := by
  sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_max_k_implies_n_11_l829_82927


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_gameWinner_correct_l829_82979

/-- Represents the possible winners of the game -/
inductive Winner where
  | FirstPlayer
  | SecondPlayer
deriving Repr

/-- Determines if two natural numbers are coprime -/
def coprime (a b : ℕ) : Prop := Nat.gcd a b = 1

/-- Determines the winner of the game for a given N -/
def gameWinner (N : ℕ) : Winner :=
  if N = 10 ∨ N = 12 ∨ N = 30 then Winner.FirstPlayer
  else if N = 15 then Winner.SecondPlayer
  else Winner.FirstPlayer  -- Default case, not specified in the original problem

/-- Theorem stating the correctness of the gameWinner function -/
theorem gameWinner_correct (N : ℕ) :
  (N = 10 ∨ N = 12 ∨ N = 15 ∨ N = 30) →
  (gameWinner N = Winner.FirstPlayer ↔ 
    (∃ (first_move : ℕ), first_move ≤ N ∧
      ∀ (second_move : ℕ), second_move ≤ N ∧ second_move ≠ first_move ∧ coprime first_move second_move →
        ∃ (third_move : ℕ), third_move ≤ N ∧ third_move ≠ first_move ∧ third_move ≠ second_move ∧
          coprime third_move first_move ∧ coprime third_move second_move ∧
          gameWinner (N - 3) = Winner.SecondPlayer)) ∧
  (gameWinner N = Winner.SecondPlayer ↔
    ∀ (first_move : ℕ), first_move ≤ N →
      ∃ (second_move : ℕ), second_move ≤ N ∧ second_move ≠ first_move ∧ coprime first_move second_move ∧
        gameWinner (N - 2) = Winner.FirstPlayer) :=
by sorry

#eval gameWinner 10
#eval gameWinner 12
#eval gameWinner 15
#eval gameWinner 30

end NUMINAMATH_CALUDE_ERRORFEEDBACK_gameWinner_correct_l829_82979


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_tangent_slope_at_point_l829_82964

-- Define the function f
noncomputable def f (x : ℝ) : ℝ := (1/2) * x^2 - 3

-- State the theorem
theorem tangent_slope_at_point :
  let P : ℝ × ℝ := (1, -5/2)
  (f P.1 = P.2) →  -- Point P is on the curve
  (∀ x, HasDerivAt f x x) →  -- f'(x) = x for all x
  HasDerivAt f 1 1 :=
by sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_tangent_slope_at_point_l829_82964


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_shopkeeper_profit_percent_l829_82976

/-- Calculates the profit percent for a shopkeeper using a faulty meter -/
noncomputable def profit_percent (actual_weight : ℝ) (faulty_weight : ℝ) : ℝ :=
  ((actual_weight - faulty_weight) / faulty_weight) * 100

/-- Theorem stating that the profit percent for a shopkeeper using a faulty meter
    weighing 960 grams instead of 1000 grams is approximately 4.17% -/
theorem shopkeeper_profit_percent :
  let actual_weight : ℝ := 1000
  let faulty_weight : ℝ := 960
  abs (profit_percent actual_weight faulty_weight - 100 / 24) < 0.01 := by
  sorry


end NUMINAMATH_CALUDE_ERRORFEEDBACK_shopkeeper_profit_percent_l829_82976


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_triangle_angle_problem_l829_82947

/-- Represents that point Y is on a straight line with point X, forming an angle of θ degrees -/
def angle_on_line (Y X : Point) (θ : ℝ) : Prop := sorry

/-- Represents that point X is on a straight line, with angles θ₁ and θ₂ on either side -/
def angle_on_two_lines (X : Point) (θ₁ θ₂ : ℝ) : Prop := sorry

/-- Represents the angle formed by three points -/
def angle (A B C : Point) : ℝ := sorry

/-- Given a triangle XYZ where:
  - XY is on a straight line with a 110° angle at Y
  - X is on another straight line with angles 70° and 40° on either side
  Prove that the angle at Z is 40° -/
theorem triangle_angle_problem (X Y Z : Point) (h1 : angle_on_line Y X 110)
  (h2 : angle_on_two_lines X 70 40) : angle Z X Y = 40 := by sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_triangle_angle_problem_l829_82947


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_f_properties_l829_82960

/-- The function f(x) with parameter ω -/
noncomputable def f (ω : ℝ) (x : ℝ) : ℝ := 2 * (Real.cos (ω * x))^2 + Real.sqrt 3 * Real.sin (2 * ω * x) - 1

/-- Theorem stating the properties of the function f -/
theorem f_properties :
  ∃ (ω : ℝ), ω > 0 ∧
  (∀ (x : ℝ), f ω (x + π) = f ω x) ∧
  (∀ (T : ℝ), T > 0 → (∀ (x : ℝ), f ω (x + T) = f ω x) → T ≥ π) ∧
  ω = 1 ∧
  (∀ (x y : ℝ), 0 ≤ x ∧ x < y ∧ y ≤ π / 6 → f ω x < f ω y) ∧
  (∀ (x : ℝ), f ω (5 * π / 12 + x) = f ω (5 * π / 12 - x)) := by
  sorry


end NUMINAMATH_CALUDE_ERRORFEEDBACK_f_properties_l829_82960


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_a_share_is_75_l829_82928

/-- Calculates the share of profit for an investor given the investment details --/
noncomputable def calculate_share_of_profit (a_investment : ℝ) (a_months : ℝ) (b_investment : ℝ) (b_months : ℝ) (total_profit : ℝ) : ℝ :=
  let a_investment_months := a_investment * a_months
  let b_investment_months := b_investment * b_months
  let total_investment_months := a_investment_months + b_investment_months
  (a_investment_months / total_investment_months) * total_profit

/-- Theorem stating that A's share of the profit is $75 given the investment details --/
theorem a_share_is_75 (a_investment b_investment total_profit : ℝ) 
    (h1 : a_investment = 300)
    (h2 : b_investment = 200)
    (h3 : total_profit = 100) :
  calculate_share_of_profit a_investment 12 b_investment 6 total_profit = 75 := by
  sorry


end NUMINAMATH_CALUDE_ERRORFEEDBACK_a_share_is_75_l829_82928


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_triangle_properties_l829_82991

-- Define a triangle ABC
structure Triangle where
  A : Real
  B : Real
  C : Real
  a : Real
  b : Real
  c : Real

-- Define the properties of the triangle
def TriangleProperties (t : Triangle) : Prop :=
  t.a = 2 * t.b ∧  -- a = 2b
  ∃ k, Real.sin t.A + Real.sin t.B = 2 * Real.sin t.C + k ∧  -- sin A, sin C, sin B form an arithmetic sequence
       Real.sin t.A + Real.sin t.C = 2 * Real.sin t.B + k ∧
  1/2 * t.b * t.c * Real.sin t.A = 8 * Real.sqrt 15 / 3  -- Area of triangle is 8√15/3

-- Theorem statement
theorem triangle_properties (t : Triangle) (h : TriangleProperties t) :
  Real.cos (t.B + t.C) = 1/4 ∧ t.c = 4 * Real.sqrt 2 := by
  sorry


end NUMINAMATH_CALUDE_ERRORFEEDBACK_triangle_properties_l829_82991


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_max_bc_length_l829_82997

/-- Represents the number of squares that can be placed in a row of the triangle -/
def squares_in_row (base_length : ℕ) (row : ℕ) : ℕ :=
  base_length - 8 * row

/-- Represents the total number of squares that can be placed in the triangle -/
def total_squares (base_length : ℕ) (height : ℕ) : ℕ :=
  (List.range height).map (squares_in_row base_length) |>.sum

/-- The main theorem stating the maximum length of BC -/
theorem max_bc_length (base_length : ℕ) (height : ℕ) :
  (base_length : ℚ) / height ≤ 8 →
  total_squares base_length height = 330 →
  base_length ≤ 67 :=
by sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_max_bc_length_l829_82997


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_completion_time_difference_is_60_l829_82989

/-- Represents the work rates and completion times for workers A and B -/
structure WorkData where
  rate_a : ℚ
  rate_b : ℚ
  time_together : ℚ

/-- Calculates the difference in completion time between workers B and A -/
def completion_time_difference (data : WorkData) : ℚ :=
  (1 / data.rate_b) - (1 / data.rate_a)

/-- Theorem stating the difference in completion time between B and A is 60 days -/
theorem completion_time_difference_is_60 (data : WorkData) 
  (h1 : data.rate_a = 3 * data.rate_b)
  (h2 : data.time_together = 45/2)
  (h3 : data.rate_a + data.rate_b = 1 / data.time_together) :
  completion_time_difference data = 60 := by
  sorry

#eval completion_time_difference { rate_a := 1/30, rate_b := 1/90, time_together := 45/2 }

end NUMINAMATH_CALUDE_ERRORFEEDBACK_completion_time_difference_is_60_l829_82989


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_odd_terms_sum_2020_l829_82945

noncomputable def sequence_sum (n : ℕ) (first : ℝ) (diff : ℝ) : ℝ :=
  n * (2 * first + (n - 1) * diff) / 2

noncomputable def odd_terms_sum (n : ℕ) (first : ℝ) (diff : ℝ) : ℝ :=
  sequence_sum ((n + 1) / 2) first (2 * diff)

theorem odd_terms_sum_2020 (first : ℝ) :
  sequence_sum 2020 first 2 = 6060 →
  odd_terms_sum 2020 first 2 = 2020 := by
  sorry


end NUMINAMATH_CALUDE_ERRORFEEDBACK_odd_terms_sum_2020_l829_82945


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_quadrilateral_area_and_perimeter_l829_82943

-- Define the quadrilateral EFGH
structure Quadrilateral :=
  (E F G H : ℝ × ℝ)

-- Define the properties of the quadrilateral
def is_valid_quadrilateral (q : Quadrilateral) : Prop :=
  let (ex, ey) := q.E
  let (fx, fy) := q.F
  let (gx, gy) := q.G
  let (hx, hy) := q.H
  -- Angle F and G are 135°
  (fx - ex) * (gx - fx) + (fy - ey) * (gy - fy) = -Real.sqrt 2 * ((fx - ex)^2 + (fy - ey)^2)^(1/2) * ((gx - fx)^2 + (gy - fy)^2)^(1/2) / 2
  ∧ (gx - fx) * (hx - gx) + (gy - fy) * (hy - gy) = -Real.sqrt 2 * ((gx - fx)^2 + (gy - fy)^2)^(1/2) * ((hx - gx)^2 + (hy - gy)^2)^(1/2) / 2
  -- Side lengths
  ∧ ((fx - ex)^2 + (fy - ey)^2)^(1/2) = 5
  ∧ ((gx - fx)^2 + (gy - fy)^2)^(1/2) = 6
  ∧ ((hx - gx)^2 + (hy - gy)^2)^(1/2) = 7
  ∧ ((ex - hx)^2 + (ey - hy)^2)^(1/2) = 4

-- Theorem statement
theorem quadrilateral_area_and_perimeter (q : Quadrilateral) 
  (h : is_valid_quadrilateral q) : 
  ∃ (area perimeter : ℝ), area = 18 * Real.sqrt 2 ∧ perimeter = 22 := by
  sorry


end NUMINAMATH_CALUDE_ERRORFEEDBACK_quadrilateral_area_and_perimeter_l829_82943


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_greatest_x_given_lcm_l829_82954

theorem greatest_x_given_lcm (x : ℕ) : 
  Nat.lcm x (Nat.lcm 12 18) = 180 → x ≤ 180 ∧ ∃ y : ℕ, y = 180 ∧ Nat.lcm y (Nat.lcm 12 18) = 180 :=
by
  sorry

#check greatest_x_given_lcm

end NUMINAMATH_CALUDE_ERRORFEEDBACK_greatest_x_given_lcm_l829_82954


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_largest_prime_factor_of_cyclic_sequence_sum_l829_82905

/-- Represents a cyclic sequence of four-digit numbers with the described rotation property -/
structure CyclicSequence where
  digits : List (Fin 10)
  length : Nat
  rotation_property : length = 4 ∧ digits.length = 4 * length

/-- The sum of all terms in the cyclic sequence -/
def sequenceSum (seq : CyclicSequence) : ℕ := sorry

/-- The largest prime factor that always divides the sum of all terms in any cyclic sequence -/
def largestPrimeFactor : ℕ := 37

/-- Theorem stating that 37 is the largest prime factor that always divides the sum of all terms in any cyclic sequence -/
theorem largest_prime_factor_of_cyclic_sequence_sum :
  ∀ (seq : CyclicSequence), (Nat.factors (sequenceSum seq)).maximum? = some largestPrimeFactor := by
  sorry

#check largest_prime_factor_of_cyclic_sequence_sum

end NUMINAMATH_CALUDE_ERRORFEEDBACK_largest_prime_factor_of_cyclic_sequence_sum_l829_82905


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_min_k_value_l829_82985

/-- Define k(S) as the number of distinct values in the form aᵢ + 2ʲ for i, j = 1, 2, ..., n -/
noncomputable def k (S : Finset ℝ) : ℕ :=
  (Finset.biUnion S (λ a => Finset.image (λ j => a + 2^j) (Finset.range S.card))).card

/-- Theorem stating the minimum value of k(S) for sets S of size n ≥ 2 -/
theorem min_k_value (n : ℕ) (hn : n ≥ 2) :
  ∃ (S : Finset ℝ), S.card = n ∧ k S = n * (n + 1) / 2 ∧
  ∀ (T : Finset ℝ), T.card = n → k T ≥ n * (n + 1) / 2 :=
by
  sorry


end NUMINAMATH_CALUDE_ERRORFEEDBACK_min_k_value_l829_82985


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_triangle_properties_l829_82938

/-- Triangle ABC with sides a, b, c opposite to angles A, B, C respectively -/
structure Triangle where
  a : ℝ
  b : ℝ
  c : ℝ
  A : ℝ
  B : ℝ
  C : ℝ
  positive_sides : 0 < a ∧ 0 < b ∧ 0 < c
  angle_sum : A + B + C = π
  law_of_cosines_a : a^2 = b^2 + c^2 - 2*b*c*(Real.cos A)
  law_of_cosines_b : b^2 = a^2 + c^2 - 2*a*c*(Real.cos B)
  law_of_cosines_c : c^2 = a^2 + b^2 - 2*a*b*(Real.cos C)

theorem triangle_properties (t : Triangle) 
  (h1 : (Real.cos t.A - 2*Real.cos t.C) * t.b = (2*t.c - t.a) * Real.cos t.B) 
  (h2 : t.b * Real.cos t.C + t.c * Real.cos t.B = 1) 
  (h3 : t.a + t.b + t.c = 5) : 
  Real.sin t.C / Real.sin t.A = 2 ∧ t.b = 2 := by
  sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_triangle_properties_l829_82938


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_cube_surface_area_increase_l829_82970

theorem cube_surface_area_increase (s : ℝ) (h : s > 0) : 
  (6 * (1.2 * s)^2 - 6 * s^2) / (6 * s^2) = 0.44 := by
  sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_cube_surface_area_increase_l829_82970


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_circle_line_distance_range_l829_82996

/-- Circle equation -/
def circle_eq (x y : ℝ) : Prop := x^2 + y^2 - 4*x - 4*y - 8 = 0

/-- Line equation -/
def line_eq (x y c : ℝ) : Prop := x - y + c = 0

/-- Distance from a point to a line -/
noncomputable def distance_to_line (x y c : ℝ) : ℝ := |c| / Real.sqrt 2

/-- Theorem statement -/
theorem circle_line_distance_range (c : ℝ) :
  (∃ (x₁ y₁ x₂ y₂ x₃ y₃ : ℝ),
    circle_eq x₁ y₁ ∧ circle_eq x₂ y₂ ∧ circle_eq x₃ y₃ ∧
    line_eq x₁ y₁ c ∧ line_eq x₂ y₂ c ∧ line_eq x₃ y₃ c ∧
    (x₁ ≠ x₂ ∨ y₁ ≠ y₂) ∧ (x₁ ≠ x₃ ∨ y₁ ≠ y₃) ∧ (x₂ ≠ x₃ ∨ y₂ ≠ y₃) ∧
    distance_to_line x₁ y₁ c = 2 ∧
    distance_to_line x₂ y₂ c = 2 ∧
    distance_to_line x₃ y₃ c = 2) →
  c ∈ Set.Icc (-2 * Real.sqrt 2) (2 * Real.sqrt 2) :=
by
  sorry


end NUMINAMATH_CALUDE_ERRORFEEDBACK_circle_line_distance_range_l829_82996


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_intersection_distance_sum_l829_82990

/-- Represents an ellipse with equation x²/36 + y²/16 = 1 -/
structure Ellipse where
  equation : ℝ × ℝ → Prop
  is_standard : equation = fun (x, y) ↦ x^2/36 + y^2/16 = 1

/-- Represents a parabola sharing a focus with the ellipse and having its directrix along the minor axis of the ellipse -/
structure Parabola where
  focus : ℝ × ℝ
  directrix : ℝ → ℝ × ℝ
  shares_focus : ∃ (f : ℝ × ℝ), focus = f ∧ f.1^2/36 + f.2^2/16 = 1
  directrix_on_minor_axis : ∀ y, directrix y = (0, y)

/-- Represents the intersection points of the ellipse and parabola -/
def intersection_points (e : Ellipse) (p : Parabola) : Set (ℝ × ℝ) :=
  {point | e.equation point ∧ ∃ y, p.directrix y = point}

/-- The positive solutions for y in the intersection equations -/
noncomputable def positive_y_solutions (e : Ellipse) (p : Parabola) : ℝ × ℝ :=
  sorry

/-- The sum of distances between pairs of intersection points on opposite sides of the ellipse -/
noncomputable def sum_of_distances (e : Ellipse) (p : Parabola) : ℝ :=
  let (b, c) := positive_y_solutions e p
  2 * (Real.sqrt b + Real.sqrt c)

theorem intersection_distance_sum (e : Ellipse) (p : Parabola) :
  sum_of_distances e p = 2 * (Real.sqrt (positive_y_solutions e p).1 + Real.sqrt (positive_y_solutions e p).2) := by
  sorry

end NUMINAMATH_CALUDE_ERRORFEEDBACK_intersection_distance_sum_l829_82990


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_wheel_diameter_proof_l829_82971

-- Define the number of revolutions and distance covered
def revolutions : ℝ := 6.005459508644222
def distance : ℝ := 1056  -- in cm

-- Define π as a constant (noncomputable due to Real.pi)
noncomputable def π : ℝ := Real.pi

-- Define the theorem
theorem wheel_diameter_proof :
  let circumference : ℝ := distance / revolutions
  let diameter : ℝ := circumference / π
  ∃ (ε : ℝ), ε > 0 ∧ ε < 1 ∧ (56 - ε < diameter ∧ diameter < 56 + ε) :=
by
  sorry

#eval revolutions
#eval distance

end NUMINAMATH_CALUDE_ERRORFEEDBACK_wheel_diameter_proof_l829_82971


namespace NUMINAMATH_CALUDE_ERRORFEEDBACK_circle_center_and_radius_l829_82988

/-- The equation of the circle -/
def circle_equation (x y : ℝ) : Prop := x^2 + y^2 - 4*y - 1 = 0

/-- The center of the circle -/
def center : ℝ × ℝ := (0, 2)

/-- The radius of the circle -/
noncomputable def radius : ℝ := Real.sqrt 5

/-- Theorem stating the equivalence between the original equation and the standard form -/
theorem circle_center_and_radius :
  ∀ x y : ℝ, circle_equation x y ↔ (x - center.1)^2 + (y - center.2)^2 = radius^2 := by
  sorry


end NUMINAMATH_CALUDE_ERRORFEEDBACK_circle_center_and_radius_l829_82988
