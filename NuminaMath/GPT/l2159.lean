import Mathlib

namespace arithmetic_sequence_l2159_215993

theorem arithmetic_sequence (a : ℕ → ℕ) (d : ℕ) (h : a 1 + 2 * a 8 + a 15 = 96) :
  2 * a 9 - a 10 = 24 :=
sorry

end arithmetic_sequence_l2159_215993


namespace annual_rent_per_square_foot_is_172_l2159_215913

def monthly_rent : ℕ := 3600
def local_taxes : ℕ := 500
def maintenance_fees : ℕ := 200
def length_of_shop : ℕ := 20
def width_of_shop : ℕ := 15

def total_monthly_cost : ℕ := monthly_rent + local_taxes + maintenance_fees
def annual_cost : ℕ := total_monthly_cost * 12
def area_of_shop : ℕ := length_of_shop * width_of_shop
def annual_rent_per_square_foot : ℕ := annual_cost / area_of_shop

theorem annual_rent_per_square_foot_is_172 :
  annual_rent_per_square_foot = 172 := by
    sorry

end annual_rent_per_square_foot_is_172_l2159_215913


namespace even_and_monotonically_increasing_f3_l2159_215963

noncomputable def f1 (x : ℝ) : ℝ := x^3
noncomputable def f2 (x : ℝ) : ℝ := -x^2 + 1
noncomputable def f3 (x : ℝ) : ℝ := abs x + 1
noncomputable def f4 (x : ℝ) : ℝ := 2^(-abs x)

theorem even_and_monotonically_increasing_f3 :
  (∀ x, f3 x = f3 (-x)) ∧ (∀ x > 0, ∀ y > x, f3 y > f3 x) := 
sorry

end even_and_monotonically_increasing_f3_l2159_215963


namespace pages_in_first_chapter_l2159_215952

/--
Rita is reading a five-chapter book with 95 pages. Each chapter has three pages more than the previous one. 
Prove the number of pages in the first chapter.
-/
theorem pages_in_first_chapter (h : ∃ p1 p2 p3 p4 p5 : ℕ, p1 + p2 + p3 + p4 + p5 = 95 ∧ p2 = p1 + 3 ∧ p3 = p1 + 6 ∧ p4 = p1 + 9 ∧ p5 = p1 + 12) : 
  ∃ x : ℕ, x = 13 := 
by
  sorry

end pages_in_first_chapter_l2159_215952


namespace ellipse_parameters_sum_l2159_215995

theorem ellipse_parameters_sum 
  (h k a b : ℤ) 
  (h_def : h = 3) 
  (k_def : k = -5) 
  (a_def : a = 7) 
  (b_def : b = 2) : 
  h + k + a + b = 7 := 
by 
  -- definitions and sums will be handled by autogenerated proof
  sorry

end ellipse_parameters_sum_l2159_215995


namespace not_an_algorithm_option_B_l2159_215955

def is_algorithm (description : String) : Prop :=
  description = "clear and finite steps to solve a problem producing correct results when executed by a computer"

def operation_to_string (option : Char) : String :=
  match option with
  | 'A' => "Calculating the area of a circle given its radius"
  | 'B' => "Calculating the possibility of reaching 24 by randomly drawing 4 playing cards"
  | 'C' => "Finding the equation of a line given two points in the coordinate plane"
  | 'D' => "The rules of addition, subtraction, multiplication, and division"
  | _ => ""

noncomputable def categorize_operation (option : Char) : Prop :=
  option = 'B' ↔ ¬ is_algorithm (operation_to_string option)

theorem not_an_algorithm_option_B :
  categorize_operation 'B' :=
by
  sorry

end not_an_algorithm_option_B_l2159_215955


namespace donna_pays_total_l2159_215985

def original_price_vase : ℝ := 250
def discount_vase : ℝ := original_price_vase * 0.25

def original_price_teacups : ℝ := 350
def discount_teacups : ℝ := original_price_teacups * 0.30

def original_price_plate : ℝ := 450
def discount_plate : ℝ := 0

def original_price_ornament : ℝ := 150
def discount_ornament : ℝ := original_price_ornament * 0.20

def membership_discount_vase : ℝ := (original_price_vase - discount_vase) * 0.05
def membership_discount_plate : ℝ := original_price_plate * 0.05

def tax_vase : ℝ := ((original_price_vase - discount_vase - membership_discount_vase) * 0.12)
def tax_teacups : ℝ := ((original_price_teacups - discount_teacups) * 0.08)
def tax_plate : ℝ := ((original_price_plate - membership_discount_plate) * 0.10)
def tax_ornament : ℝ := ((original_price_ornament - discount_ornament) * 0.06)

def final_price_vase : ℝ := (original_price_vase - discount_vase - membership_discount_vase) + tax_vase
def final_price_teacups : ℝ := (original_price_teacups - discount_teacups) + tax_teacups
def final_price_plate : ℝ := (original_price_plate - membership_discount_plate) + tax_plate
def final_price_ornament : ℝ := (original_price_ornament - discount_ornament) + tax_ornament

def total_price : ℝ := final_price_vase + final_price_teacups + final_price_plate + final_price_ornament

theorem donna_pays_total :
  total_price = 1061.55 :=
by
  sorry

end donna_pays_total_l2159_215985


namespace largest_intersection_value_l2159_215912

theorem largest_intersection_value (b c d : ℝ) :
  ∀ x : ℝ, (x^7 - 12*x^6 + 44*x^5 - 24*x^4 + b*x^3 = c*x - d) → x ≤ 6 := sorry

end largest_intersection_value_l2159_215912


namespace range_of_b_l2159_215976

theorem range_of_b (b : ℝ) :
  (∃ x : ℝ, x^2 - 2 * b * x + b^2 + b - 5 = 0) ∧
  (∀ x < 3.5, ∃ δ > 0, ∀ ε, x < ε → ε^2 - 2 * b * ε + b^2 + b - 5 < x^2 - 2 * b * x + b^2 + b - 5) →
  (3.5 ≤ b ∧ b ≤ 5) :=
by
  sorry

end range_of_b_l2159_215976


namespace farmer_initial_apples_l2159_215937

variable (initial_apples given_away_apples remaining_apples : ℕ)

def initial_apple_count (given_away_apples remaining_apples : ℕ) : ℕ :=
  given_away_apples + remaining_apples

theorem farmer_initial_apples : initial_apple_count 88 39 = 127 := by
  -- Given conditions
  let given_away_apples := 88
  let remaining_apples := 39

  -- Calculate the initial apples
  let initial_apples := initial_apple_count given_away_apples remaining_apples

  -- We are supposed to prove initial apples count is 127
  show initial_apples = 127
  sorry

end farmer_initial_apples_l2159_215937


namespace function_order_l2159_215953

theorem function_order (f : ℝ → ℝ)
  (h1 : ∀ x : ℝ, f (2 - x) = f x)
  (h2 : ∀ x : ℝ, f (x + 2) = f (x - 2))
  (h3 : ∀ x1 x2 : ℝ, 1 ≤ x1 ∧ x1 ≤ 3 ∧ 1 ≤ x2 ∧ x2 ≤ 3 → (f x1 - f x2) / (x1 - x2) < 0) :
  f 2016 = f 2014 ∧ f 2014 > f 2015 :=
by
  sorry

end function_order_l2159_215953


namespace slope_of_line_through_midpoints_l2159_215979

theorem slope_of_line_through_midpoints (A B C D : ℝ × ℝ) (hA : A = (1, 1)) (hB : B = (3, 4)) (hC : C = (4, 1)) (hD : D = (7, 4)) :
  let M := ((A.1 + B.1) / 2, (A.2 + B.2) / 2)
  let N := ((C.1 + D.1) / 2, (C.2 + D.2) / 2)
  (N.2 - M.2) / (N.1 - M.1) = 0 := by
  sorry

end slope_of_line_through_midpoints_l2159_215979


namespace simple_interest_rate_l2159_215901

theorem simple_interest_rate (P : ℝ) (T : ℝ) (R : ℝ) (H : T = 4 ∧ (7 / 6) * P = P + (P * R * T / 100)) :
  R = 4.17 :=
by
  sorry

end simple_interest_rate_l2159_215901


namespace smallest_n_for_sum_exceed_10_pow_5_l2159_215924

def a₁ : ℕ := 9
def r : ℕ := 10
def S (n : ℕ) : ℕ := 5 * n^2 + 4 * n
def target_sum : ℕ := 10^5

theorem smallest_n_for_sum_exceed_10_pow_5 : 
  ∃ n : ℕ, S n > target_sum ∧ ∀ m < n, ¬(S m > target_sum) := 
sorry

end smallest_n_for_sum_exceed_10_pow_5_l2159_215924


namespace minimum_one_by_one_squares_l2159_215918

theorem minimum_one_by_one_squares :
  ∀ (x y z : ℕ), 9 * x + 4 * y + z = 49 → (z = 3) :=
  sorry

end minimum_one_by_one_squares_l2159_215918


namespace original_number_is_8_l2159_215908

open Real

theorem original_number_is_8 
  (x : ℝ)
  (h1 : |(x + 5) - (x - 5)| = 10)
  (h2 : (10 / (x + 5)) * 100 = 76.92) : 
  x = 8 := 
by
  sorry

end original_number_is_8_l2159_215908


namespace JaneReadingSpeed_l2159_215968

theorem JaneReadingSpeed (total_pages read_second_half_speed total_days pages_first_half days_first_half_speed : ℕ)
  (h1 : total_pages = 500)
  (h2 : read_second_half_speed = 5)
  (h3 : total_days = 75)
  (h4 : pages_first_half = 250)
  (h5 : days_first_half_speed = pages_first_half / (total_days - (pages_first_half / read_second_half_speed))) :
  days_first_half_speed = 10 := by
  sorry

end JaneReadingSpeed_l2159_215968


namespace solid_is_cone_l2159_215923

-- Definitions of the conditions.
def front_and_side_views_are_equilateral_triangles (S : Type) : Prop :=
∀ (F : S → Prop) (E : S → Prop), (∃ T : S, F T ∧ E T ∧ T = T) 

def top_view_is_circle_with_center (S : Type) : Prop :=
∀ (C : S → Prop), (∃ O : S, C O ∧ O = O)

-- The proof statement that given the above conditions, the solid is a cone
theorem solid_is_cone (S : Type)
  (H1 : front_and_side_views_are_equilateral_triangles S)
  (H2 : top_view_is_circle_with_center S) : 
  ∃ C : S, C = C :=
by 
  sorry

end solid_is_cone_l2159_215923


namespace distance_from_p_to_center_is_2_sqrt_10_l2159_215939

-- Define the conditions
def r : ℝ := 4
def PA : ℝ := 4
def PB : ℝ := 6

-- The conjecture to prove
theorem distance_from_p_to_center_is_2_sqrt_10
  (r : ℝ) (PA : ℝ) (PB : ℝ) 
  (PA_mul_PB : PA * PB = 24) 
  (r_squared : r = 4)  : 
  ∃ d : ℝ, d = 2 * Real.sqrt 10 := 
by sorry

end distance_from_p_to_center_is_2_sqrt_10_l2159_215939


namespace cesar_watched_fraction_l2159_215981

theorem cesar_watched_fraction
  (total_seasons : ℕ) (episodes_per_season : ℕ) (remaining_episodes : ℕ)
  (h1 : total_seasons = 12)
  (h2 : episodes_per_season = 20)
  (h3 : remaining_episodes = 160) :
  (total_seasons * episodes_per_season - remaining_episodes) / (total_seasons * episodes_per_season) = 1 / 3 := 
sorry

end cesar_watched_fraction_l2159_215981


namespace negation_proof_l2159_215910

theorem negation_proof :
  (¬ ∃ x : ℝ, x^2 - x + 1 ≤ 0) → (∀ x : ℝ, x^2 - x + 1 > 0) :=
by
  sorry

end negation_proof_l2159_215910


namespace exists_solution_interval_inequality_l2159_215911

theorem exists_solution_interval_inequality :
  ∀ x : ℝ, (0 < x ∧ x < 1) ∨ (1 < x ∧ x < 2) ↔ 
  (1 / (x * (x - 1)) - 1 / ((x - 1) * (x - 2)) > 1 / 5) := 
by
  sorry

end exists_solution_interval_inequality_l2159_215911


namespace ratio_c_d_l2159_215906

theorem ratio_c_d (x y c d : ℝ) 
  (h1 : 8 * x - 5 * y = c)
  (h2 : 10 * y - 12 * x = d)
  (hx : x ≠ 0)
  (hy : y ≠ 0)
  (hd : d ≠ 0) :
  c / d = -2 / 3 :=
sorry

end ratio_c_d_l2159_215906


namespace B_completes_work_in_12_hours_l2159_215905

theorem B_completes_work_in_12_hours:
  let A := 1 / 4
  let C := (1 / 2) - A
  let B := (1 / 3) - C
  (1 / B) = 12 :=
by
  -- placeholder for the proof
  sorry

end B_completes_work_in_12_hours_l2159_215905


namespace bakery_used_0_2_bags_of_wheat_flour_l2159_215969

-- Define the conditions
def total_flour := 0.3
def white_flour := 0.1

-- Define the number of bags of wheat flour used
def wheat_flour := total_flour - white_flour

-- The proof statement
theorem bakery_used_0_2_bags_of_wheat_flour : wheat_flour = 0.2 := 
by
  sorry

end bakery_used_0_2_bags_of_wheat_flour_l2159_215969


namespace range_of_a_l2159_215920

theorem range_of_a (a : ℝ) : 
  (¬ ∃ x : ℝ, x^2 - a * x + 1 < 0) ↔ -2 ≤ a ∧ a ≤ 2 :=
by sorry

end range_of_a_l2159_215920


namespace intersection_of_A_and_B_l2159_215926

-- Define sets A and B
def setA : Set ℝ := {x : ℝ | -3 < x ∧ x < 3}
def setB : Set ℝ := {x : ℝ | x < 2}

-- Prove that A ∩ B = (-3, 2)
theorem intersection_of_A_and_B : {x : ℝ | x ∈ setA ∧ x ∈ setB} = {x : ℝ | -3 < x ∧ x < 2} := 
by 
  sorry

end intersection_of_A_and_B_l2159_215926


namespace poly_perfect_fourth_l2159_215927

theorem poly_perfect_fourth (a b c : ℤ) (h : ∀ x : ℤ, ∃ k : ℤ, (a * x^2 + b * x + c) = k^4) : 
  a = 0 ∧ b = 0 :=
sorry

end poly_perfect_fourth_l2159_215927


namespace burrs_count_l2159_215967

variable (B T : ℕ)

theorem burrs_count 
  (h1 : T = 6 * B) 
  (h2 : B + T = 84) : 
  B = 12 := 
by
  sorry

end burrs_count_l2159_215967


namespace number_of_5card_hands_with_4_of_a_kind_l2159_215977

-- Definitions based on the given conditions
def deck_size : Nat := 52
def num_values : Nat := 13
def suits_per_value : Nat := 4

-- The function to count the number of 5-card hands with exactly four cards of the same value
def count_hands_with_four_of_a_kind : Nat :=
  num_values * (deck_size - suits_per_value)

-- Proof statement
theorem number_of_5card_hands_with_4_of_a_kind : count_hands_with_four_of_a_kind = 624 :=
by
  -- Steps to show the computation results may be added here
  -- We use the formula: 13 * (52 - 4)
  sorry

end number_of_5card_hands_with_4_of_a_kind_l2159_215977


namespace boat_speed_5_kmh_l2159_215902

noncomputable def boat_speed_in_still_water (V_s : ℝ) (t : ℝ) (d : ℝ) : ℝ :=
  (d / t) - V_s

theorem boat_speed_5_kmh :
  boat_speed_in_still_water 5 10 100 = 5 :=
by
  sorry

end boat_speed_5_kmh_l2159_215902


namespace remainder_zero_l2159_215996

theorem remainder_zero (x : ℕ) (h1 : x = 1680) :
  (x % 5 = 0) ∧ (x % 6 = 0) ∧ (x % 7 = 0) ∧ (x % 8 = 0) :=
by
  sorry

end remainder_zero_l2159_215996


namespace polar_distance_l2159_215986

noncomputable def distance_point (r1 θ1 r2 θ2 : ℝ) : ℝ :=
  Real.sqrt ((r1 ^ 2) + (r2 ^ 2) - 2 * r1 * r2 * Real.cos (θ1 - θ2))

theorem polar_distance :
  ∀ (θ1 θ2 : ℝ), (θ1 - θ2 = Real.pi / 2) → distance_point 5 θ1 12 θ2 = 13 :=
by
  intros θ1 θ2 hθ
  rw [distance_point, hθ, Real.cos_pi_div_two]
  norm_num
  sorry

end polar_distance_l2159_215986


namespace blocks_differ_in_two_ways_exactly_l2159_215971

theorem blocks_differ_in_two_ways_exactly 
  (materials : Finset String := {"plastic", "wood", "metal"})
  (sizes : Finset String := {"small", "medium", "large"})
  (colors : Finset String := {"blue", "green", "red", "yellow"})
  (shapes : Finset String := {"circle", "hexagon", "square", "triangle"})
  (target : String := "plastic medium red circle") :
  ∃ (n : ℕ), n = 37 := by
  sorry

end blocks_differ_in_two_ways_exactly_l2159_215971


namespace sum_of_interior_angles_l2159_215940

theorem sum_of_interior_angles (n : ℕ) : 
  (∀ θ, θ = 40 ∧ (n = 360 / θ)) → (n - 2) * 180 = 1260 :=
by
  sorry

end sum_of_interior_angles_l2159_215940


namespace order_of_numbers_l2159_215972

variable (a b c : ℝ)
variable (h₁ : a = (1 / 2) ^ (1 / 3))
variable (h₂ : b = (1 / 2) ^ (2 / 3))
variable (h₃ : c = (1 / 5) ^ (2 / 3))

theorem order_of_numbers (a b c : ℝ) (h₁ : a = (1 / 2) ^ (1 / 3)) (h₂ : b = (1 / 2) ^ (2 / 3)) (h₃ : c = (1 / 5) ^ (2 / 3)) :
  c < b ∧ b < a := 
by
  sorry

end order_of_numbers_l2159_215972


namespace balloon_height_l2159_215935

theorem balloon_height :
  let initial_money : ℝ := 200
  let cost_sheet : ℝ := 42
  let cost_rope : ℝ := 18
  let cost_tank_and_burner : ℝ := 14
  let helium_price_per_ounce : ℝ := 1.5
  let lift_per_ounce : ℝ := 113
  let remaining_money := initial_money - cost_sheet - cost_rope - cost_tank_and_burner
  let ounces_of_helium := remaining_money / helium_price_per_ounce
  let height := ounces_of_helium * lift_per_ounce
  height = 9492 :=
by
  sorry

end balloon_height_l2159_215935


namespace shaded_area_of_hexagon_with_quarter_circles_l2159_215943

noncomputable def area_inside_hexagon_outside_circles
  (s : ℝ) (h : s = 4) : ℝ :=
  let hex_area := (3 * Real.sqrt 3) / 2 * s^2
  let quarter_circle_area := (1 / 4) * Real.pi * s^2
  let total_quarter_circles_area := 6 * quarter_circle_area
  hex_area - total_quarter_circles_area

theorem shaded_area_of_hexagon_with_quarter_circles :
  area_inside_hexagon_outside_circles 4 rfl = 48 * Real.sqrt 3 - 24 * Real.pi := by
  sorry

end shaded_area_of_hexagon_with_quarter_circles_l2159_215943


namespace p_distinct_roots_iff_l2159_215987

variables {p : ℝ}

def quadratic_has_distinct_roots (a b c : ℝ) : Prop :=
  (b^2 - 4 * a * c) > 0

theorem p_distinct_roots_iff (hp: p > 0 ∨ p = -1) :
  (∀ x : ℝ, x^2 - 2 * |x| - p = 0 → 
    (quadratic_has_distinct_roots 1 (-2) (-p) ∨
      quadratic_has_distinct_roots 1 2 (-p))) :=
by sorry

end p_distinct_roots_iff_l2159_215987


namespace program_result_l2159_215954

def program_loop (i : ℕ) (s : ℕ) : ℕ :=
if i < 9 then s else program_loop (i - 1) (s * i)

theorem program_result : 
  program_loop 11 1 = 990 :=
by 
  sorry

end program_result_l2159_215954


namespace aquarium_counts_l2159_215941

theorem aquarium_counts :
  ∃ (O S L : ℕ), O + S = 7 ∧ L + S = 6 ∧ O + L = 5 ∧ (O ≤ S ∧ O ≤ L) ∧ O = 5 ∧ S = 7 ∧ L = 6 :=
by
  sorry

end aquarium_counts_l2159_215941


namespace trigonometric_inequality_solution_l2159_215946

theorem trigonometric_inequality_solution (k : ℤ) :
  ∃ x : ℝ, x = - (3 * Real.pi) / 2 + 4 * Real.pi * k ∧
           (Real.cos (x / 2) + Real.sin (x / 2) ≤ (Real.sin x - 3) / Real.sqrt 2) :=
by
  sorry

end trigonometric_inequality_solution_l2159_215946


namespace plankton_consumption_difference_l2159_215903

theorem plankton_consumption_difference 
  (x : ℕ) 
  (d : ℕ) 
  (total_hours : ℕ := 9) 
  (total_consumption : ℕ := 360)
  (sixth_hour_consumption : ℕ := 43)
  (total_series_sum : x + (x + d) + (x + 2 * d) + (x + 3 * d) + (x + 4 * d) + (x + 5 * d) + (x + 6 * d) + (x + 7 * d) + (x + 8 * d) = total_consumption)
  (sixth_hour_eq : x + 5 * d = sixth_hour_consumption)
  : d = 3 :=
by
  sorry

end plankton_consumption_difference_l2159_215903


namespace minimum_dot_product_l2159_215945

-- Define the points A and B
def A : ℝ × ℝ × ℝ := (1, 2, 0)
def B : ℝ × ℝ × ℝ := (0, 1, -1)

-- Define the vector AP
def vector_AP (x : ℝ) := (x - 1, -2, 0)

-- Define the vector BP
def vector_BP (x : ℝ) := (x, -1, 1)

-- Define the dot product of vector AP and vector BP
def dot_product (x : ℝ) : ℝ := (x - 1) * x + (-2) * (-1) + 0 * 1

-- State the theorem
theorem minimum_dot_product : ∃ x : ℝ, dot_product x = (x - 1) * x + 2 ∧ 
  (∀ y : ℝ, dot_product y ≥ dot_product (1/2)) := 
sorry

end minimum_dot_product_l2159_215945


namespace heather_aprons_l2159_215990

variable {totalAprons : Nat} (apronsSewnBeforeToday apronsSewnToday apronsSewnTomorrow apronsSewnSoFar apronsRemaining : Nat)

theorem heather_aprons (h_total : totalAprons = 150)
                       (h_today : apronsSewnToday = 3 * apronsSewnBeforeToday)
                       (h_sewnSoFar : apronsSewnSoFar = apronsSewnBeforeToday + apronsSewnToday)
                       (h_tomorrow : apronsSewnTomorrow = 49)
                       (h_remaining : apronsRemaining = totalAprons - apronsSewnSoFar)
                       (h_halfRemaining : 2 * apronsSewnTomorrow = apronsRemaining) :
  apronsSewnBeforeToday = 13 :=
by
  sorry

end heather_aprons_l2159_215990


namespace expression_one_expression_two_l2159_215925

-- Define the expressions to be proved.
theorem expression_one : (3.6 - 0.8) * (1.8 + 2.05) = 10.78 :=
by sorry

theorem expression_two : (34.28 / 2) - (16.2 / 4) = 13.09 :=
by sorry

end expression_one_expression_two_l2159_215925


namespace find_room_width_l2159_215989

def room_height : ℕ := 12
def room_length : ℕ := 25
def door_height : ℕ := 6
def door_width : ℕ := 3
def window_height : ℕ := 4
def window_width : ℕ := 3
def number_of_windows : ℕ := 3
def cost_per_sqft : ℕ := 8
def total_cost : ℕ := 7248

theorem find_room_width (x : ℕ) (h : 8 * (room_height * (2 * room_length + 2 * x) - (door_height * door_width + window_height * window_width * number_of_windows)) = total_cost) : 
  x = 15 :=
sorry

end find_room_width_l2159_215989


namespace janet_total_lives_l2159_215936

/-
  Janet's initial lives: 38
  Lives lost: 16
  Lives gained: 32
  Prove that total lives == 54 after the changes
-/

theorem janet_total_lives (initial_lives lost_lives gained_lives : ℕ) 
(h1 : initial_lives = 38)
(h2 : lost_lives = 16)
(h3 : gained_lives = 32):
  initial_lives - lost_lives + gained_lives = 54 := by
  sorry

end janet_total_lives_l2159_215936


namespace net_effect_on_sale_value_l2159_215966

theorem net_effect_on_sale_value
(P Q : ℝ)
(h_new_price : ∃ P', P' = P - 0.22 * P)
(h_new_qty : ∃ Q', Q' = Q + 0.86 * Q) :
  let original_sale_value := P * Q
  let new_sale_value := (0.78 * P) * (1.86 * Q)
  let net_effect := ((new_sale_value / original_sale_value - 1) * 100 : ℝ)
  net_effect = 45.08 :=
by {
  sorry
}

end net_effect_on_sale_value_l2159_215966


namespace trig_identity_cos_sin_l2159_215922

theorem trig_identity_cos_sin : 
  (Real.cos (π / 12))^2 - (Real.sin (π / 12))^2 = Real.cos (π / 6) :=
sorry

end trig_identity_cos_sin_l2159_215922


namespace ratio_of_probabilities_l2159_215929

-- Define the total number of balls and bins
def balls : ℕ := 20
def bins : ℕ := 6

-- Define the sets A and B based on the given conditions
def A : ℕ := Nat.choose bins 1 * Nat.choose (bins - 1) 1 * (Nat.factorial balls / (Nat.factorial 2 * Nat.factorial 5 * Nat.factorial 3 * Nat.factorial 3 * Nat.factorial 3 * Nat.factorial 3))
def B : ℕ := Nat.choose bins 2 * (Nat.factorial balls / (Nat.factorial 5 * Nat.factorial 5 * Nat.factorial 2 * Nat.factorial 2 * Nat.factorial 2 * Nat.factorial 2))

-- Define the probabilities p and q
def p : ℚ := A / (Nat.factorial balls * Nat.factorial bins)
def q : ℚ := B / (Nat.factorial balls * Nat.factorial bins)

-- Prove the ratio of probabilities p and q equals 2
theorem ratio_of_probabilities : p / q = 2 := by sorry

end ratio_of_probabilities_l2159_215929


namespace nine_odot_three_l2159_215974

-- Defining the operation based on the given conditions
axiom odot_def (a b : ℕ) : ℕ

axiom odot_eq_1 : odot_def 2 4 = 8
axiom odot_eq_2 : odot_def 4 6 = 14
axiom odot_eq_3 : odot_def 5 3 = 13
axiom odot_eq_4 : odot_def 8 7 = 23

-- Proving that 9 ⊙ 3 = 21
theorem nine_odot_three : odot_def 9 3 = 21 := 
by
  sorry

end nine_odot_three_l2159_215974


namespace inequality_1_inequality_2_l2159_215932

theorem inequality_1 (x : ℝ) : (2 * x^2 - 3 * x + 1 < 0) ↔ (1 / 2 < x ∧ x < 1) := 
by sorry

theorem inequality_2 (x : ℝ) (h : x ≠ -1) : (2 * x / (x + 1) ≥ 1) ↔ (x < -1 ∨ x ≥ 1) := 
by sorry

end inequality_1_inequality_2_l2159_215932


namespace eq_relation_q_r_l2159_215917

-- Define the angles in the context of the problem
variables {A B C D E F : Type}
variables {angle_BAC angle_BFD angle_ADE angle_FEC : ℝ}
variables (right_triangle_ABC : A → B → C → angle_BAC = 90)

-- Equilateral triangle DEF inscribed in ABC
variables (inscribed_equilateral_DEF : D → E → F)
variables (angle_BFD_eq_p : ∀ p : ℝ, angle_BFD = p)
variables (angle_ADE_eq_q : ∀ q : ℝ, angle_ADE = q)
variables (angle_FEC_eq_r : ∀ r : ℝ, angle_FEC = r)

-- Main statement to be proved
theorem eq_relation_q_r {p q r : ℝ} 
  (right_triangle_ABC : angle_BAC = 90)
  (angle_BFD : angle_BFD = 30 + q)
  (angle_FEC : angle_FEC = 120 - r) :
  q + r = 60 :=
sorry

end eq_relation_q_r_l2159_215917


namespace min_triangle_perimeter_l2159_215982

/-- Given a point (a, b) with 0 < b < a,
    determine the minimum perimeter of a triangle with one vertex at (a, b),
    one on the x-axis, and one on the line y = x. 
    The minimum perimeter is √(2(a^2 + b^2)).
-/
theorem min_triangle_perimeter (a b : ℝ) (h : 0 < b ∧ b < a) 
  : ∃ c d : ℝ, c^2 + d^2 = 2 * (a^2 + b^2) := sorry

end min_triangle_perimeter_l2159_215982


namespace reading_time_per_week_l2159_215949

variable (meditation_time_per_day : ℕ)
variable (reading_factor : ℕ)

theorem reading_time_per_week (h1 : meditation_time_per_day = 1) (h2 : reading_factor = 2) : 
  (reading_factor * meditation_time_per_day * 7) = 14 :=
by
  sorry

end reading_time_per_week_l2159_215949


namespace simplify_expression_l2159_215964

theorem simplify_expression (a : ℝ) :
  (1/2) * (8 * a^2 + 4 * a) - 3 * (a - (1/3) * a^2) = 5 * a^2 - a :=
by
  sorry

end simplify_expression_l2159_215964


namespace eval_power_expr_of_196_l2159_215978

theorem eval_power_expr_of_196 (a b : ℕ) (ha : 2^a ∣ 196 ∧ ¬ 2^(a + 1) ∣ 196) (hb : 7^b ∣ 196 ∧ ¬ 7^(b + 1) ∣ 196) :
  (1 / 7 : ℝ)^(b - a) = 1 := by
  have ha_val : a = 2 := sorry
  have hb_val : b = 2 := sorry
  rw [ha_val, hb_val]
  simp

end eval_power_expr_of_196_l2159_215978


namespace synodic_month_is_approx_29_5306_l2159_215909

noncomputable def sidereal_month_moon : ℝ := 
27 + 7/24 + 43/1440  -- conversion of 7 hours and 43 minutes to days

noncomputable def sidereal_year_earth : ℝ := 
365 + 6/24 + 9/1440  -- conversion of 6 hours and 9 minutes to days

noncomputable def synodic_month (T_H T_F: ℝ) : ℝ := 
(T_H * T_F) / (T_F - T_H)

theorem synodic_month_is_approx_29_5306 : 
  abs (synodic_month sidereal_month_moon sidereal_year_earth - (29 + 12/24 + 44/1440)) < 0.0001 :=
by 
  sorry

end synodic_month_is_approx_29_5306_l2159_215909


namespace unique_exponential_function_l2159_215965

theorem unique_exponential_function (g : ℝ → ℝ) :
  (∀ x1 x2 : ℝ, g (x1 + x2) = g x1 * g x2) →
  g 1 = 3 →
  (∀ x1 x2 : ℝ, x1 < x2 → g x1 < g x2) →
  ∀ x : ℝ, g x = 3^x :=
by
  sorry

end unique_exponential_function_l2159_215965


namespace arithmetic_seq_ratio_l2159_215973

theorem arithmetic_seq_ratio
  (a b : ℕ → ℝ)
  (S T : ℕ → ℝ)
  (H_seq_a : ∀ n, S n = (n * (a 1 + a n)) / 2)
  (H_seq_b : ∀ n, T n = (n * (b 1 + b n)) / 2)
  (H_ratio : ∀ n, S n / T n = (2 * n - 3) / (4 * n - 3)) :
  (a 3 + a 15) / (2 * (b 3 + b 9)) + a 3 / (b 2 + b 10) = 19 / 41 :=
by
  sorry

end arithmetic_seq_ratio_l2159_215973


namespace line_through_two_points_l2159_215944

theorem line_through_two_points (P Q : ℝ × ℝ) (hP : P = (2, 5)) (hQ : Q = (2, -5)) :
  (∀ (x y : ℝ), (x, y) = P ∨ (x, y) = Q → x = 2) :=
by
  sorry

end line_through_two_points_l2159_215944


namespace solve_for_k_l2159_215958

theorem solve_for_k (x y k : ℤ) (h1 : x = -3) (h2 : y = 2) (h3 : 2 * x + k * y = 0) : k = 3 :=
by
  sorry

end solve_for_k_l2159_215958


namespace value_of_fraction_l2159_215900

theorem value_of_fraction (x y : ℤ) (h1 : x = 3) (h2 : y = 4) : (x^5 + 3 * y^3) / 9 = 48 :=
by
  sorry

end value_of_fraction_l2159_215900


namespace value_of_a_plus_b_l2159_215904

theorem value_of_a_plus_b (a b : ℝ) (f g : ℝ → ℝ)
  (hf : ∀ x, f x = a * x + b) 
  (hg : ∀ x, g x = -3 * x + 2)
  (hgf : ∀ x, g (f x) = -2 * x - 3) :
  a + b = 7 / 3 :=
by
  sorry

end value_of_a_plus_b_l2159_215904


namespace find_f_2015_l2159_215959

def f (x : ℝ) := 2 * x - 1 

theorem find_f_2015 (f : ℝ → ℝ)
  (H1 : ∀ a b : ℝ, f ((2 * a + b) / 3) = (2 * f a + f b) / 3)
  (H2 : f 1 = 1)
  (H3 : f 4 = 7) :
  f 2015 = 4029 := by 
  sorry

end find_f_2015_l2159_215959


namespace tan_ratio_proof_l2159_215950

noncomputable def tan_ratio (a b : ℝ) : ℝ := Real.tan a / Real.tan b

theorem tan_ratio_proof (a b : ℝ) (h1 : Real.sin (a + b) = 5 / 8) (h2 : Real.sin (a - b) = 1 / 3) : 
tan_ratio a b = 23 / 7 := by
  sorry

end tan_ratio_proof_l2159_215950


namespace find_initial_salt_concentration_l2159_215916

noncomputable def initial_salt_concentration 
  (x : ℝ) (final_concentration : ℝ) (extra_water : ℝ) (extra_salt : ℝ) (evaporation_fraction : ℝ) : ℝ :=
  let initial_volume : ℝ := x
  let remaining_volume : ℝ := evaporation_fraction * initial_volume
  let mixed_volume : ℝ := remaining_volume + extra_water + extra_salt
  let target_salt_volume_fraction : ℝ := final_concentration / 100
  let initial_salt_volume_fraction : ℝ := (target_salt_volume_fraction * mixed_volume - extra_salt) / initial_volume * 100
  initial_salt_volume_fraction

theorem find_initial_salt_concentration :
  initial_salt_concentration 120 33.333333333333336 8 16 (3 / 4) = 18.333333333333332 :=
by
  sorry

end find_initial_salt_concentration_l2159_215916


namespace find_b_l2159_215915

-- Definitions for conditions
def eq1 (a : ℤ) : Prop := 2 * a + 1 = 1
def eq2 (a b : ℤ) : Prop := 2 * b - 3 * a = 2

-- The theorem statement
theorem find_b (a b : ℤ) (h1 : eq1 a) (h2 : eq2 a b) : b = 1 :=
  sorry  -- Proof to be filled in.

end find_b_l2159_215915


namespace part_a_part_b_l2159_215998

-- Define the sum of digits function
def sum_of_digits (n : ℕ) : ℕ :=
  n.digits 10 |>.foldl (λ x y => x + y) 0

-- Part A: There exists a sequence of 158 consecutive integers where the sum of digits is not divisible by 17
theorem part_a : ∃ (n : ℕ), ∀ (k : ℕ), k < 158 → sum_of_digits (n + k) % 17 ≠ 0 := by
  sorry

-- Part B: Among any 159 consecutive integers, there exists at least one integer whose sum of digits is divisible by 17
theorem part_b : ∀ (n : ℕ), ∃ (k : ℕ), k < 159 ∧ sum_of_digits (n + k) % 17 = 0 := by
  sorry

end part_a_part_b_l2159_215998


namespace total_estate_value_l2159_215994

theorem total_estate_value :
  ∃ (E : ℝ), ∀ (x : ℝ),
    (5 * x + 4 * x = (2 / 3) * E) ∧
    (E = 13.5 * x) ∧
    (wife_share = 3 * 4 * x) ∧
    (gardener_share = 600) ∧
    (nephew_share = 1000) →
    E = 2880 := 
by 
  -- Declarations
  let E : ℝ := sorry
  let x : ℝ := sorry
  
  -- Set up conditions
  -- Daughter and son share
  have c1 : 5 * x + 4 * x = (2 / 3) * E := sorry
  
  -- E expressed through x
  have c2 : E = 13.5 * x := sorry
  
  -- Wife's share
  have c3 : wife_share = 3 * (4 * x) := sorry
  
  -- Gardener's share and Nephew's share
  have c4 : gardener_share = 600 := sorry
  have c5 : nephew_share = 1000 := sorry
  
  -- Equate expressions and solve
  have eq1 : E = 21 * x + 1600 := sorry
  have eq2 : E = 2880 := sorry
  use E
  intro x
  -- Prove the equalities under the given conditions
  sorry

end total_estate_value_l2159_215994


namespace joyful_not_blue_l2159_215951

variables {Snakes : Type} 
variables (isJoyful : Snakes → Prop) (isBlue : Snakes → Prop)
variables (canMultiply : Snakes → Prop) (canDivide : Snakes → Prop)

-- Conditions
axiom H1 : ∀ s : Snakes, isJoyful s → canMultiply s
axiom H2 : ∀ s : Snakes, isBlue s → ¬ canDivide s
axiom H3 : ∀ s : Snakes, ¬ canDivide s → ¬ canMultiply s

theorem joyful_not_blue (s : Snakes) : isJoyful s → ¬ isBlue s :=
by sorry

end joyful_not_blue_l2159_215951


namespace find_cat_video_length_l2159_215980

variables (C : ℕ)

def cat_video_length (C : ℕ) : Prop :=
  C + 2 * C + 6 * C = 36

theorem find_cat_video_length : cat_video_length 4 :=
by
  sorry

end find_cat_video_length_l2159_215980


namespace shauna_fifth_test_score_l2159_215938

theorem shauna_fifth_test_score :
  ∀ (a1 a2 a3 a4: ℕ), a1 = 76 → a2 = 94 → a3 = 87 → a4 = 92 →
  (∃ a5 : ℕ, (a1 + a2 + a3 + a4 + a5) / 5 = 85 ∧ a5 = 76) :=
by
  sorry

end shauna_fifth_test_score_l2159_215938


namespace unit_digit_of_product_of_nine_consecutive_numbers_is_zero_l2159_215957

theorem unit_digit_of_product_of_nine_consecutive_numbers_is_zero (n : ℕ) :
  (n * (n + 1) * (n + 2) * (n + 3) * (n + 4) * (n + 5) * (n + 6) * (n + 7) * (n + 8)) % 10 = 0 :=
by
  sorry

end unit_digit_of_product_of_nine_consecutive_numbers_is_zero_l2159_215957


namespace mixed_solution_concentration_l2159_215921

def salt_amount_solution1 (weight1 : ℕ) (concentration1 : ℕ) : ℕ := (concentration1 * weight1) / 100
def salt_amount_solution2 (salt2 : ℕ) : ℕ := salt2
def total_salt (salt1 salt2 : ℕ) : ℕ := salt1 + salt2
def total_weight (weight1 weight2 : ℕ) : ℕ := weight1 + weight2
def concentration (total_salt : ℕ) (total_weight : ℕ) : ℚ := (total_salt : ℚ) / (total_weight : ℚ) * 100

theorem mixed_solution_concentration 
  (weight1 weight2 salt2 : ℕ) (concentration1 : ℕ)
  (h_weight1 : weight1 = 200)
  (h_weight2 : weight2 = 300)
  (h_concentration1 : concentration1 = 25)
  (h_salt2 : salt2 = 60) :
  concentration (total_salt (salt_amount_solution1 weight1 concentration1) (salt_amount_solution2 salt2)) (total_weight weight1 weight2) = 22 := 
sorry

end mixed_solution_concentration_l2159_215921


namespace division_remainder_unique_u_l2159_215991

theorem division_remainder_unique_u :
  ∃! u : ℕ, ∃ q : ℕ, 15 = u * q + 4 ∧ u > 4 :=
sorry

end division_remainder_unique_u_l2159_215991


namespace problem1_problem2_l2159_215984

noncomputable def f (x a : ℝ) : ℝ := |x - 1| + |x - a|

theorem problem1 (x : ℝ) : f x 2 ≥ 2 ↔ x ≤ 1/2 ∨ x ≥ 5/2 :=
  sorry -- the proof goes here

theorem problem2 (a : ℝ) (h₁ : 1 < a) : 
  (∀ x : ℝ, f x a + |x - 1| ≥ 1) ∧ (2 ≤ a) :=
  sorry -- the proof goes here

end problem1_problem2_l2159_215984


namespace cos_half_angle_neg_sqrt_l2159_215914

theorem cos_half_angle_neg_sqrt (theta m : ℝ) 
  (h1 : (5 / 2) * Real.pi < theta ∧ theta < 3 * Real.pi)
  (h2 : |Real.cos theta| = m) : 
  Real.cos (theta / 2) = -Real.sqrt ((1 - m) / 2) :=
sorry

end cos_half_angle_neg_sqrt_l2159_215914


namespace art_piece_future_value_multiple_l2159_215983

theorem art_piece_future_value_multiple (original_price increase_in_value future_value multiple : ℕ)
  (h1 : original_price = 4000)
  (h2 : increase_in_value = 8000)
  (h3 : future_value = original_price + increase_in_value)
  (h4 : multiple = future_value / original_price) :
  multiple = 3 := 
sorry

end art_piece_future_value_multiple_l2159_215983


namespace total_time_correct_l2159_215997

variable (b n : ℕ)

def total_travel_time (b n : ℕ) : ℚ := (3*b + 4*n + 2*b) / 150

theorem total_time_correct :
  total_travel_time b n = (5 * b + 4 * n) / 150 :=
by sorry

end total_time_correct_l2159_215997


namespace product_of_integers_eq_expected_result_l2159_215907

theorem product_of_integers_eq_expected_result
  (E F G H I : ℚ) 
  (h1 : E + F + G + H + I = 80) 
  (h2 : E + 2 = F - 2) 
  (h3 : F - 2 = G * 2) 
  (h4 : G * 2 = H * 3) 
  (h5 : H * 3 = I / 2) :
  E * F * G * H * I = (5120000 / 81) := 
by 
  sorry

end product_of_integers_eq_expected_result_l2159_215907


namespace arithmetic_sequence_a10_l2159_215931

theorem arithmetic_sequence_a10 (a : ℕ → ℝ) 
    (h1 : a 2 = 2) 
    (h2 : a 3 = 4) : 
    a 10 = 18 := 
sorry

end arithmetic_sequence_a10_l2159_215931


namespace dividend_expression_l2159_215988

theorem dividend_expression 
  (D d q r P : ℕ)
  (hq_square : ∃ k, q = k^2)
  (hd_expr1 : d = 3 * r + 2)
  (hd_expr2 : d = 5 * q)
  (hr_val : r = 6)
  (hD_expr : D = d * q + r)
  (hP_prime : Prime P)
  (hP_div_D : P ∣ D)
  (hP_factor : P = 2 ∨ P = 43) :
  D = 86 := 
sorry

end dividend_expression_l2159_215988


namespace baker_sold_pastries_l2159_215919

theorem baker_sold_pastries : 
  ∃ P : ℕ, (97 = P + 89) ∧ P = 8 :=
by 
  sorry

end baker_sold_pastries_l2159_215919


namespace person_income_l2159_215930

/-- If the income and expenditure of a person are in the ratio 15:8 and the savings are Rs. 7000, then the income of the person is Rs. 15000. -/
theorem person_income (x : ℝ) (income expenditure : ℝ) (savings : ℝ) 
  (h1 : income = 15 * x) 
  (h2 : expenditure = 8 * x) 
  (h3 : savings = income - expenditure) 
  (h4 : savings = 7000) : 
  income = 15000 := 
by 
  sorry

end person_income_l2159_215930


namespace identify_letter_X_l2159_215992

-- Define the conditions
def date_behind_D (z : ℕ) : ℕ := z
def date_behind_E (z : ℕ) : ℕ := z + 1
def date_behind_F (z : ℕ) : ℕ := z + 14

-- Define the sum condition
def sum_date_E_F (z : ℕ) : ℕ := date_behind_E z + date_behind_F z

-- Define the target date behind another letter
def target_date_behind_another_letter (z : ℕ) : ℕ := z + 15

-- Theorem statement
theorem identify_letter_X (z : ℕ) :
  ∃ (x : Char), sum_date_E_F z = date_behind_D z + target_date_behind_another_letter z → x = 'X' :=
by
  -- The actual proof would go here; we'll defer it for now
  sorry

end identify_letter_X_l2159_215992


namespace valid_triples_l2159_215962

theorem valid_triples (x y z : ℕ) (hx : x > 0) (hy : y > 0) (hz : z > 0) :
  x ∣ (y + 1) ∧ y ∣ (z + 1) ∧ z ∣ (x + 1) ↔ (x, y, z) = (1, 1, 1) ∨ 
                                                      (x, y, z) = (1, 1, 2) ∨ 
                                                      (x, y, z) = (1, 3, 2) ∨ 
                                                      (x, y, z) = (3, 5, 4) :=
by
  sorry

end valid_triples_l2159_215962


namespace solution_set_of_inequality_l2159_215934

theorem solution_set_of_inequality :
  { x : ℝ | - (1 : ℝ) / 2 < x ∧ x <= 1 } =
  { x : ℝ | (x - 1) / (2 * x + 1) <= 0 ∧ x ≠ - (1 : ℝ) / 2 } :=
by
  sorry

end solution_set_of_inequality_l2159_215934


namespace cube_root_less_than_five_count_l2159_215961

theorem cube_root_less_than_five_count :
  (∃ n : ℕ, n = 124 ∧ ∀ x : ℕ, 1 ≤ x → x < 5^3 → x < 125) := 
sorry

end cube_root_less_than_five_count_l2159_215961


namespace find_value_of_expression_l2159_215942

variable (α β : ℝ)

-- Defining the conditions
def is_root (α : ℝ) : Prop := α^2 - 3 * α + 1 = 0
def add_roots_eq (α β : ℝ) : Prop := α + β = 3
def mult_roots_eq (α β : ℝ) : Prop := α * β = 1

-- The main statement we want to prove
theorem find_value_of_expression {α β : ℝ} 
  (hα : is_root α) 
  (hβ : is_root β)
  (h_add : add_roots_eq α β)
  (h_mul : mult_roots_eq α β) :
  3 * α^5 + 7 * β^4 = 817 := 
sorry

end find_value_of_expression_l2159_215942


namespace total_assignments_for_28_points_l2159_215933

-- Definitions based on conditions
def assignments_needed (points : ℕ) : ℕ :=
  (points / 7 + 1) * (points % 7) + (points / 7) * (7 - points % 7)

-- The theorem statement, which asserts the answer to the given problem
theorem total_assignments_for_28_points : assignments_needed 28 = 70 :=
by
  -- proof will go here
  sorry

end total_assignments_for_28_points_l2159_215933


namespace horner_eval_at_neg2_l2159_215975

noncomputable def f (x : ℝ) : ℝ := x^5 - 3 * x^3 - 6 * x^2 + x - 1

theorem horner_eval_at_neg2 : f (-2) = -35 :=
by
  sorry

end horner_eval_at_neg2_l2159_215975


namespace three_digit_avg_permutations_l2159_215956

theorem three_digit_avg_permutations (a b c: ℕ) (A: ℕ) (h₀: 1 ≤ a ∧ a ≤ 9) (h₁: 0 ≤ b ∧ b ≤ 9) (h₂: 0 ≤ c ∧ c ≤ 9) (h₃: A = 100 * a + 10 * b + c):
  ((100 * a + 10 * b + c) + (100 * a + 10 * c + b) + (100 * b + 10 * a + c) + (100 * b + 10 * c + a) + (100 * c + 10 * a + b) + (100 * c + 10 * b + a)) / 6 = A ↔ 7 * a = 3 * b + 4 * c := by
  sorry

end three_digit_avg_permutations_l2159_215956


namespace total_worth_of_stock_l2159_215948

theorem total_worth_of_stock (X : ℝ) (h1 : 0.1 * X * 1.2 - 0.9 * X * 0.95 = -400) : X = 16000 :=
by
  -- actual proof
  sorry

end total_worth_of_stock_l2159_215948


namespace pref_card_game_arrangements_l2159_215947

noncomputable def number_of_arrangements :=
  (Nat.factorial 32) / ((Nat.factorial 10) ^ 3 * Nat.factorial 2 * Nat.factorial 3)

theorem pref_card_game_arrangements :
  number_of_arrangements = (Nat.factorial 32) / ((Nat.factorial 10) ^ 3 * Nat.factorial 2 * Nat.factorial 3) :=
by
  sorry

end pref_card_game_arrangements_l2159_215947


namespace smallest_solution_proof_l2159_215999

noncomputable def smallest_solution (x : ℝ) : Prop :=
  (1 / (x - 1) + 1 / (x - 5) = 4 / (x - 2)) ∧ 
  (∀ y : ℝ, 1 / (y - 1) + 1 / (y - 5) = 4 / (y - 2) → y ≥ x)

theorem smallest_solution_proof : smallest_solution ( (7 - Real.sqrt 33) / 2 ) :=
sorry

end smallest_solution_proof_l2159_215999


namespace people_visited_both_l2159_215970

theorem people_visited_both (total iceland norway neither both : ℕ) (h_total: total = 100) (h_iceland: iceland = 55) (h_norway: norway = 43) (h_neither: neither = 63)
  (h_both_def: both = iceland + norway - (total - neither)) :
  both = 61 :=
by 
  rw [h_total, h_iceland, h_norway, h_neither] at h_both_def
  simp at h_both_def
  exact h_both_def

end people_visited_both_l2159_215970


namespace gcd_153_68_eq_17_l2159_215960

theorem gcd_153_68_eq_17 : Int.gcd 153 68 = 17 :=
by
  sorry

end gcd_153_68_eq_17_l2159_215960


namespace smallest_x_undefined_l2159_215928

theorem smallest_x_undefined :
  (∀ x, 10 * x^2 - 90 * x + 20 = 0 → x = 1 ∨ x = 8) → (∀ x, 10 * x^2 - 90 * x + 20 = 0 → x = 1) :=
by
  sorry

end smallest_x_undefined_l2159_215928
