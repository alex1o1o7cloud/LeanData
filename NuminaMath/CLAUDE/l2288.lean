import Mathlib

namespace ticket_price_difference_l2288_228848

/-- Represents the total amount paid for pre-booked tickets -/
def prebooked_total : ℕ := 10 * 140 + 10 * 170

/-- Represents the total amount paid for tickets bought at the gate -/
def gate_total : ℕ := 8 * 190 + 12 * 210 + 10 * 300

/-- Theorem stating the difference in total amount paid -/
theorem ticket_price_difference : gate_total - prebooked_total = 3940 := by
  sorry

end ticket_price_difference_l2288_228848


namespace min_value_theorem_l2288_228854

theorem min_value_theorem (x : ℝ) (h : x > 0) : 
  x + 1 / (2 * x) ≥ Real.sqrt 2 ∧ 
  ∃ y > 0, y + 1 / (2 * y) = Real.sqrt 2 :=
by sorry

end min_value_theorem_l2288_228854


namespace quadratic_equation_roots_roots_difference_condition_l2288_228834

theorem quadratic_equation_roots (m : ℝ) :
  let f : ℝ → ℝ := λ x => x^2 + (m + 3) * x + m + 1
  ∃ x₁ x₂ : ℝ, x₁ ≠ x₂ ∧ f x₁ = 0 ∧ f x₂ = 0 :=
by sorry

theorem roots_difference_condition (m : ℝ) :
  let f : ℝ → ℝ := λ x => x^2 + (m + 3) * x + m + 1
  (∃ x₁ x₂ : ℝ, x₁ ≠ x₂ ∧ f x₁ = 0 ∧ f x₂ = 0 ∧ |x₁ - x₂| = 2 * Real.sqrt 2) →
  (m = 1 ∨ m = -3) :=
by sorry

end quadratic_equation_roots_roots_difference_condition_l2288_228834


namespace symmetric_solution_l2288_228871

/-- The system of equations -/
def system (x y : ℝ) : Prop :=
  2 * x^2 + 3 * x * y + y^2 = 70 ∧ 6 * x^2 + x * y - y^2 = 50

/-- Given solution -/
def x₁ : ℝ := 3
def y₁ : ℝ := 4

/-- Theorem stating that if (x₁, y₁) is a solution, then (-x₁, -y₁) is also a solution -/
theorem symmetric_solution :
  system x₁ y₁ → system (-x₁) (-y₁) := by sorry

end symmetric_solution_l2288_228871


namespace geometric_sequence_problem_l2288_228835

theorem geometric_sequence_problem (a : ℕ → ℝ) :
  (∀ n, a (n + 1) / a n = a 2 / a 1) →  -- geometric sequence condition
  a 1 = 1/4 →
  a 3 * a 5 = 4 * (a 4 - 1) →
  a 2 = 1/2 := by
sorry

end geometric_sequence_problem_l2288_228835


namespace cube_digits_convergence_l2288_228831

/-- The function that cubes each digit of a natural number and sums the results -/
def cube_digits_sum (n : ℕ) : ℕ :=
  n.digits 10
    |>.map (fun d => d^3)
    |>.sum

/-- The sequence generated by repeatedly applying cube_digits_sum -/
def cube_digits_sequence (start : ℕ) : ℕ → ℕ
  | 0 => start
  | n + 1 => cube_digits_sum (cube_digits_sequence start n)

/-- The theorem stating that the sequence converges to 153 for multiples of 3 -/
theorem cube_digits_convergence (n : ℕ) (h : 3 ∣ n) :
  ∃ k, ∀ m ≥ k, cube_digits_sequence n m = 153 := by
  sorry

end cube_digits_convergence_l2288_228831


namespace perimeter_of_cut_square_perimeter_of_specific_cut_square_l2288_228807

/-- The perimeter of a figure formed by cutting a square into two equal rectangles and placing them next to each other -/
theorem perimeter_of_cut_square (square_side : ℝ) : 
  square_side > 0 → 
  (3 * square_side + 4 * (square_side / 2)) = 5 * square_side := by
  sorry

/-- The perimeter of a figure formed by cutting a square with side length 100 into two equal rectangles and placing them next to each other is 500 -/
theorem perimeter_of_specific_cut_square : 
  (3 * 100 + 4 * (100 / 2)) = 500 := by
  sorry

end perimeter_of_cut_square_perimeter_of_specific_cut_square_l2288_228807


namespace exists_captivating_number_l2288_228838

/-- A function that checks if a list of digits forms a captivating number -/
def is_captivating (digits : List Nat) : Prop :=
  digits.length = 7 ∧
  digits.toFinset = Finset.range 7 ∧
  ∀ k : Nat, k ∈ Finset.range 7 → 
    (digits.take k).foldl (fun acc d => acc * 10 + d) 0 % (k + 1) = 0

/-- Theorem stating the existence of at least one captivating number -/
theorem exists_captivating_number : ∃ digits : List Nat, is_captivating digits :=
  sorry

end exists_captivating_number_l2288_228838


namespace simplify_and_evaluate_l2288_228864

theorem simplify_and_evaluate (a b : ℝ) (h1 : a = 1) (h2 : b = 2) :
  (2*a - b)^2 - (2*a + b)*(b - 2*a) = 0 := by
  sorry

end simplify_and_evaluate_l2288_228864


namespace platform_length_l2288_228801

/-- Given a train of length 300 meters that crosses a platform in 27 seconds
    and a signal pole in 18 seconds, prove that the platform length is 150 meters. -/
theorem platform_length (train_length : ℝ) (platform_time : ℝ) (pole_time : ℝ) :
  train_length = 300 →
  platform_time = 27 →
  pole_time = 18 →
  ∃ (platform_length : ℝ),
    platform_length = 150 ∧
    train_length / pole_time = (train_length + platform_length) / platform_time :=
by sorry

end platform_length_l2288_228801


namespace arithmetic_sequence_inequality_l2288_228890

/-- An arithmetic sequence -/
def ArithmeticSequence (a : ℕ → ℝ) : Prop :=
  ∃ d : ℝ, ∀ n : ℕ, a (n + 1) = a n + d

/-- Theorem: For an arithmetic sequence, a₆ < a₇ if and only if a₆ < a₈ -/
theorem arithmetic_sequence_inequality (a : ℕ → ℝ) (h : ArithmeticSequence a) :
  a 6 < a 7 ↔ a 6 < a 8 := by
  sorry

end arithmetic_sequence_inequality_l2288_228890


namespace perfect_square_condition_l2288_228891

theorem perfect_square_condition (n : ℤ) : 
  (∃ k : ℤ, 9 + 8 * n = k^2) ↔ (∃ m : ℤ, n = (m - 1) * (m + 2) / 2) :=
by sorry

end perfect_square_condition_l2288_228891


namespace grass_field_width_l2288_228849

/-- Represents the width of the grass field -/
def field_width : ℝ := sorry

/-- The length of the grass field in meters -/
def field_length : ℝ := 75

/-- The width of the path around the field in meters -/
def path_width : ℝ := 2.5

/-- The cost of constructing the path per square meter in Rupees -/
def cost_per_sqm : ℝ := 2

/-- The total cost of constructing the path in Rupees -/
def total_cost : ℝ := 1350

/-- Theorem stating that given the conditions, the width of the grass field is 55 meters -/
theorem grass_field_width : 
  field_width = 55 := by sorry

end grass_field_width_l2288_228849


namespace ashok_pyarelal_capital_ratio_l2288_228886

/-- Given a total loss and Pyarelal's loss, prove the ratio of Ashok's capital to Pyarelal's capital -/
theorem ashok_pyarelal_capital_ratio 
  (total_loss : ℕ) 
  (pyarelal_loss : ℕ) 
  (h1 : total_loss = 1200) 
  (h2 : pyarelal_loss = 1080) : 
  ∃ (a p : ℕ), a ≠ 0 ∧ p ≠ 0 ∧ a * 9 = p * 1 := by
  sorry

end ashok_pyarelal_capital_ratio_l2288_228886


namespace principal_calculation_l2288_228872

/-- Represents the simple interest calculation for a loan --/
def simple_interest_loan (principal rate time interest : ℚ) : Prop :=
  interest = (principal * rate * time) / 100

theorem principal_calculation (rate time interest : ℚ) 
  (h1 : rate = 12)
  (h2 : time = 20)
  (h3 : interest = 2100) :
  ∃ (principal : ℚ), simple_interest_loan principal rate time interest ∧ principal = 875 := by
  sorry

end principal_calculation_l2288_228872


namespace unique_modular_congruence_l2288_228895

theorem unique_modular_congruence :
  ∃! n : ℕ, 0 ≤ n ∧ n ≤ 6 ∧ n ≡ -2023 [ZMOD 7] := by
  sorry

end unique_modular_congruence_l2288_228895


namespace max_availability_equal_all_days_l2288_228806

-- Define the days of the week
inductive Day
  | Mon
  | Tues
  | Wed
  | Thurs
  | Fri

-- Define the team members
inductive Member
  | Alice
  | Bob
  | Cindy
  | David

-- Define the availability function
def availability (m : Member) (d : Day) : Bool :=
  match m, d with
  | Member.Alice, Day.Mon => false
  | Member.Alice, Day.Tues => false
  | Member.Alice, Day.Wed => true
  | Member.Alice, Day.Thurs => true
  | Member.Alice, Day.Fri => false
  | Member.Bob, Day.Mon => true
  | Member.Bob, Day.Tues => false
  | Member.Bob, Day.Wed => false
  | Member.Bob, Day.Thurs => true
  | Member.Bob, Day.Fri => true
  | Member.Cindy, Day.Mon => false
  | Member.Cindy, Day.Tues => true
  | Member.Cindy, Day.Wed => false
  | Member.Cindy, Day.Thurs => false
  | Member.Cindy, Day.Fri => true
  | Member.David, Day.Mon => true
  | Member.David, Day.Tues => true
  | Member.David, Day.Wed => true
  | Member.David, Day.Thurs => false
  | Member.David, Day.Fri => false

-- Count available members for a given day
def availableCount (d : Day) : Nat :=
  (List.filter (fun m => availability m d) [Member.Alice, Member.Bob, Member.Cindy, Member.David]).length

-- Theorem: The maximum number of available members is equal for all days
theorem max_availability_equal_all_days :
  (List.map availableCount [Day.Mon, Day.Tues, Day.Wed, Day.Thurs, Day.Fri]).all (· = 2) := by
  sorry


end max_availability_equal_all_days_l2288_228806


namespace sqrt_sum_difference_eighth_power_l2288_228892

theorem sqrt_sum_difference_eighth_power : 
  (Real.sqrt 11 + Real.sqrt 5)^8 + (Real.sqrt 11 - Real.sqrt 5)^8 = 903712 := by
  sorry

end sqrt_sum_difference_eighth_power_l2288_228892


namespace line_intersects_segment_slope_range_l2288_228866

-- Define points A and B
def A : ℝ × ℝ := (1, 3)
def B : ℝ × ℝ := (-2, -1)

-- Define the line l
def l (k : ℝ) (x : ℝ) : ℝ := k * (x - 2) + 1

-- Define the segment AB
def segmentAB (t : ℝ) : ℝ × ℝ := (
  (1 - t) * A.1 + t * B.1,
  (1 - t) * A.2 + t * B.2
)

-- Theorem statement
theorem line_intersects_segment_slope_range :
  ∀ k : ℝ, (∃ t ∈ (Set.Icc 0 1), l k (segmentAB t).1 = (segmentAB t).2) →
  -2 ≤ k ∧ k ≤ 1/2 :=
sorry

end line_intersects_segment_slope_range_l2288_228866


namespace lemonade_sum_l2288_228853

theorem lemonade_sum : 
  let first_intermission : Float := 0.25
  let second_intermission : Float := 0.4166666666666667
  let third_intermission : Float := 0.25
  first_intermission + second_intermission + third_intermission = 0.9166666666666667 := by
  sorry

end lemonade_sum_l2288_228853


namespace only_negative_option_l2288_228880

theorem only_negative_option (x : ℝ) : 
  (|(-1)| < 0 ∨ (-2^2) < 0 ∨ ((-Real.sqrt 3)^2) < 0 ∨ ((-3)^0) < 0) ↔ 
  (-2^2) < 0 :=
by sorry

end only_negative_option_l2288_228880


namespace q_at_zero_l2288_228851

-- Define polynomials p, q, and r
variable (p q r : ℝ[X])

-- Define the relationship between r, p, and q
axiom r_eq_p_mul_q : r = p * q

-- Define the constant term of p(x)
axiom p_const_term : p.coeff 0 = 6

-- Define the constant term of r(x)
axiom r_const_term : r.coeff 0 = -18

-- The theorem to prove
theorem q_at_zero : q.eval 0 = -3 := by sorry

end q_at_zero_l2288_228851


namespace unique_positive_solution_l2288_228889

theorem unique_positive_solution : ∃! y : ℝ, y > 0 ∧ (y - 6) / 16 = 6 / (y - 16) := by
  sorry

end unique_positive_solution_l2288_228889


namespace blue_eyed_brunettes_l2288_228846

theorem blue_eyed_brunettes (total : ℕ) (blue_eyed_blondes : ℕ) (brunettes : ℕ) (brown_eyed : ℕ) :
  total = 60 →
  blue_eyed_blondes = 20 →
  brunettes = 36 →
  brown_eyed = 23 →
  ∃ (blue_eyed_brunettes : ℕ),
    blue_eyed_brunettes = 17 ∧
    blue_eyed_brunettes + blue_eyed_blondes = total - brown_eyed ∧
    blue_eyed_brunettes + (brunettes - blue_eyed_brunettes) = brown_eyed :=
by sorry

end blue_eyed_brunettes_l2288_228846


namespace isoscelesTrapezoidArea_l2288_228804

/-- An isosceles trapezoid inscribed around a circle -/
structure IsoscelesTrapezoid where
  /-- Length of the longer base -/
  longerBase : ℝ
  /-- One of the base angles in radians -/
  baseAngle : ℝ
  /-- Assumption that the longer base is 18 -/
  longerBaseIs18 : longerBase = 18
  /-- Assumption that the base angle is arccos(0.6) -/
  baseAngleIsArccos06 : baseAngle = Real.arccos 0.6

/-- The area of the isosceles trapezoid -/
def areaOfTrapezoid (t : IsoscelesTrapezoid) : ℝ := 101.25

/-- Theorem stating that the area of the isosceles trapezoid is 101.25 -/
theorem isoscelesTrapezoidArea (t : IsoscelesTrapezoid) : 
  areaOfTrapezoid t = 101.25 := by
  sorry

end isoscelesTrapezoidArea_l2288_228804


namespace singer_arrangement_count_l2288_228826

/-- The number of singers -/
def n : ℕ := 6

/-- The number of singers with specific arrangement requirements (A, B, C) -/
def k : ℕ := 3

/-- The number of valid arrangements of A, B, C (A-B-C, A-C-B, B-C-A, C-B-A) -/
def valid_abc_arrangements : ℕ := 4

/-- The total number of arrangements of n singers -/
def total_arrangements : ℕ := n.factorial

/-- The number of arrangements of k singers -/
def k_arrangements : ℕ := k.factorial

theorem singer_arrangement_count :
  (valid_abc_arrangements * total_arrangements / k_arrangements : ℕ) = 480 := by
  sorry

end singer_arrangement_count_l2288_228826


namespace fraction_inequality_l2288_228870

theorem fraction_inequality (a b c : ℝ) (h1 : a > b) (h2 : b > 0) (h3 : c < 0) :
  c / (a^2) > c / (b^2) := by
  sorry

end fraction_inequality_l2288_228870


namespace array_sum_remainder_l2288_228877

/-- Represents the sum of all terms in a 1/1004-array -/
def array_sum : ℚ := (2 * 1004^2) / ((2 * 1004 - 1) * (1004 - 1))

/-- Numerator of the array sum when expressed in lowest terms -/
def m : ℕ := 2 * 1004^2

/-- Denominator of the array sum when expressed in lowest terms -/
def n : ℕ := (2 * 1004 - 1) * (1004 - 1)

/-- The main theorem stating that (m + n) ≡ 0 (mod 1004) -/
theorem array_sum_remainder :
  (m + n) % 1004 = 0 := by sorry

end array_sum_remainder_l2288_228877


namespace parabola_intersection_dot_product_l2288_228882

-- Define the parabola
def parabola (x y : ℝ) : Prop := y^2 = 4*x

-- Define a point on the parabola
structure PointOnParabola where
  x : ℝ
  y : ℝ
  on_parabola : parabola x y

-- Define the focus of the parabola
def focus : ℝ × ℝ := (1, 0)

-- Define a line passing through the focus
def line_through_focus (k : ℝ) (x y : ℝ) : Prop :=
  y = k * (x - 1)

-- Define the intersection of the line and the parabola
def intersection (k : ℝ) (p : PointOnParabola) : Prop :=
  line_through_focus k p.x p.y

theorem parabola_intersection_dot_product :
  ∀ (k : ℝ) (A B : PointOnParabola),
    intersection k A →
    intersection k B →
    A ≠ B →
    A.x * B.x + A.y * B.y = -3 :=
sorry

end parabola_intersection_dot_product_l2288_228882


namespace power_sum_difference_l2288_228862

theorem power_sum_difference : 2^(1+2+3+4) - (2^1 + 2^2 + 2^3 + 2^4) = 994 := by
  sorry

end power_sum_difference_l2288_228862


namespace total_pennies_thrown_l2288_228881

/-- The number of pennies thrown by each person and their total --/
def penny_throwing (R G X M T : ℚ) : Prop :=
  R = 1500 ∧
  G = (2/3) * R ∧
  X = (3/4) * G ∧
  M = (7/2) * X ∧
  T = (4/5) * M ∧
  R + G + X + M + T = 7975

/-- Theorem stating that the total number of pennies thrown is 7975 --/
theorem total_pennies_thrown :
  ∃ (R G X M T : ℚ), penny_throwing R G X M T :=
sorry

end total_pennies_thrown_l2288_228881


namespace triangle_angle_inequality_l2288_228811

theorem triangle_angle_inequality (a b c α β γ : Real) : 
  0 < a ∧ 0 < b ∧ 0 < c ∧ 
  0 < α ∧ 0 < β ∧ 0 < γ ∧
  a + b > c ∧ b + c > a ∧ c + a > b ∧
  α + β + γ = π →
  π / 3 ≤ (a * α + b * β + c * γ) / (a + b + c) ∧ 
  (a * α + b * β + c * γ) / (a + b + c) < π / 2 := by
sorry

end triangle_angle_inequality_l2288_228811


namespace trigonometric_simplification_l2288_228812

theorem trigonometric_simplification (x y : ℝ) :
  Real.sin x ^ 2 + Real.sin (x + 2 * y) ^ 2 - 2 * Real.sin x * Real.sin (2 * y) * Real.cos (x + 2 * y) =
  2 * Real.sin x ^ 2 - Real.sin x ^ 2 * Real.cos y ^ 2 :=
by sorry

end trigonometric_simplification_l2288_228812


namespace A_intersect_B_l2288_228888

def A : Set ℝ := {-1, 0, 1}

def B : Set ℝ := {y | ∃ x ∈ A, y = Real.cos (Real.pi * x)}

theorem A_intersect_B : A ∩ B = {-1, 1} := by sorry

end A_intersect_B_l2288_228888


namespace pascal_triangle_complete_residue_l2288_228868

theorem pascal_triangle_complete_residue (p : ℕ) (hp : Prime p) :
  ∃ n : ℕ, n ≤ p^2 ∧
    ∀ k : ℕ, k < p → ∃ j : ℕ, j ≤ n ∧ (Nat.choose n j) % p = k := by
  sorry

end pascal_triangle_complete_residue_l2288_228868


namespace smallest_x_y_sum_l2288_228809

def is_fourth_power (n : ℕ) : Prop :=
  ∃ m : ℕ, n = m^4

def is_sixth_power (n : ℕ) : Prop :=
  ∃ m : ℕ, n = m^6

theorem smallest_x_y_sum :
  ∃ (x y : ℕ),
    (∀ x' : ℕ, is_fourth_power (180 * x') → x ≤ x') ∧
    (∀ y' : ℕ, is_sixth_power (180 * y') → y ≤ y') ∧
    is_fourth_power (180 * x) ∧
    is_sixth_power (180 * y) ∧
    x + y = 4054500 :=
by sorry

end smallest_x_y_sum_l2288_228809


namespace cone_cylinder_equal_volume_l2288_228817

/-- Given a cylinder M with base radius 2 and height 2√3/3, and a cone N whose base diameter
    equals its slant height, if the volumes of M and N are equal, then the base radius of cone N is 2. -/
theorem cone_cylinder_equal_volume (r : ℝ) : 
  let cylinder_volume := π * 2^2 * (2 * Real.sqrt 3 / 3)
  let cone_volume := (1/3) * π * r^2 * (Real.sqrt 3 * r)
  (2 * r = Real.sqrt 3 * r) → (cylinder_volume = cone_volume) → r = 2 := by
  sorry

end cone_cylinder_equal_volume_l2288_228817


namespace goose_survival_fraction_l2288_228850

theorem goose_survival_fraction (total_eggs : ℕ) 
  (hatch_rate : ℚ) (first_month_survival_rate : ℚ) (first_year_survivors : ℕ) :
  hatch_rate = 1/2 →
  first_month_survival_rate = 3/4 →
  first_year_survivors = 120 →
  (hatch_rate * first_month_survival_rate * total_eggs : ℚ) = first_year_survivors →
  (first_year_survivors : ℚ) / (hatch_rate * first_month_survival_rate * total_eggs) = 1 :=
by sorry

end goose_survival_fraction_l2288_228850


namespace cos_150_degrees_l2288_228822

theorem cos_150_degrees :
  Real.cos (150 * π / 180) = -Real.sqrt 3 / 2 :=
by
  -- Define the cosine subtraction identity
  have cos_subtraction_identity (a b : ℝ) :
    Real.cos (a - b) = Real.cos a * Real.cos b + Real.sin a * Real.sin b :=
    sorry

  -- Express 150° as 180° - 30°
  have h1 : 150 * π / 180 = π - (30 * π / 180) :=
    sorry

  -- Use the cosine subtraction identity
  have h2 : Real.cos (150 * π / 180) =
    Real.cos π * Real.cos (30 * π / 180) + Real.sin π * Real.sin (30 * π / 180) :=
    sorry

  -- Evaluate the expression
  sorry

end cos_150_degrees_l2288_228822


namespace cylinder_surface_area_l2288_228865

/-- The total surface area of a cylinder with height 15 cm and radius 5 cm is 200π square cm. -/
theorem cylinder_surface_area :
  let h : ℝ := 15
  let r : ℝ := 5
  let total_area : ℝ := 2 * Real.pi * r * r + 2 * Real.pi * r * h
  total_area = 200 * Real.pi :=
by sorry

end cylinder_surface_area_l2288_228865


namespace rectangular_equation_focus_directrix_distance_l2288_228883

-- Define the polar coordinate equation of the conic section curve C
def polarEquation (ρ θ : ℝ) : Prop :=
  ρ = 8 * Real.sin θ / (1 + Real.cos (2 * θ))

-- Define the conversion from polar to rectangular coordinates
def polarToRectangular (x y ρ θ : ℝ) : Prop :=
  x = ρ * Real.cos θ ∧ y = ρ * Real.sin θ

-- Theorem: The rectangular coordinate equation of curve C is x² = 4y
theorem rectangular_equation (x y : ℝ) :
  (∃ ρ θ, polarEquation ρ θ ∧ polarToRectangular x y ρ θ) →
  x^2 = 4*y :=
sorry

-- Theorem: The distance from the focus to the directrix is 2
theorem focus_directrix_distance :
  (∃ p : ℝ, ∀ x y : ℝ, (∃ ρ θ, polarEquation ρ θ ∧ polarToRectangular x y ρ θ) →
    y = (1 / (4 * p)) * x^2) →
  2 = 2 :=
sorry

end rectangular_equation_focus_directrix_distance_l2288_228883


namespace christines_stickers_l2288_228885

theorem christines_stickers (total_needed : ℕ) (more_needed : ℕ) (h1 : total_needed = 30) (h2 : more_needed = 19) :
  total_needed - more_needed = 11 := by
  sorry

end christines_stickers_l2288_228885


namespace existence_of_a_i_for_x_ij_l2288_228832

theorem existence_of_a_i_for_x_ij (n : ℕ) (x : Fin n → Fin n → ℝ)
  (h : ∀ (i j k : Fin n), x i j + x j k + x k i = 0) :
  ∃ (a : Fin n → ℝ), ∀ (i j : Fin n), x i j = a i - a j := by
  sorry

end existence_of_a_i_for_x_ij_l2288_228832


namespace min_value_sum_squared_over_one_plus_l2288_228802

theorem min_value_sum_squared_over_one_plus (x y z : ℝ) 
  (pos_x : 0 < x) (pos_y : 0 < y) (pos_z : 0 < z) 
  (sum_eq_one : x + y + z = 1) : 
  x^2 / (1 + x) + y^2 / (1 + y) + z^2 / (1 + z) ≥ 1/4 := by
  sorry

end min_value_sum_squared_over_one_plus_l2288_228802


namespace software_package_savings_l2288_228828

/-- Calculates the savings when choosing a more expensive software package with higher device coverage over a cheaper one with lower device coverage. -/
theorem software_package_savings
  (total_devices : ℕ)
  (package1_price package2_price : ℕ)
  (package1_coverage package2_coverage : ℕ)
  (h1 : total_devices = 50)
  (h2 : package1_price = 40)
  (h3 : package2_price = 60)
  (h4 : package1_coverage = 5)
  (h5 : package2_coverage = 10) :
  (total_devices / package1_coverage * package1_price) -
  (total_devices / package2_coverage * package2_price) = 100 :=
by
  sorry

#check software_package_savings

end software_package_savings_l2288_228828


namespace no_negative_roots_l2288_228842

theorem no_negative_roots : 
  ∀ x : ℝ, x < 0 → x^4 - 4*x^3 - 6*x^2 - 3*x + 9 ≠ 0 := by
sorry

end no_negative_roots_l2288_228842


namespace red_marble_fraction_l2288_228837

theorem red_marble_fraction (total : ℝ) (h : total > 0) :
  let initial_blue := (2/3 : ℝ) * total
  let initial_red := total - initial_blue
  let new_red := 3 * initial_red
  let new_total := initial_blue + new_red
  new_red / new_total = 3/5 := by
  sorry

end red_marble_fraction_l2288_228837


namespace cashback_is_twelve_percent_l2288_228821

/-- Calculates the cashback percentage given the total cost, rebate, and final cost -/
def cashback_percentage (total_cost rebate final_cost : ℚ) : ℚ :=
  let cost_after_rebate := total_cost - rebate
  let cashback_amount := cost_after_rebate - final_cost
  (cashback_amount / cost_after_rebate) * 100

/-- Theorem stating that the cashback percentage is 12% given the problem conditions -/
theorem cashback_is_twelve_percent :
  cashback_percentage 150 25 110 = 12 := by
  sorry

end cashback_is_twelve_percent_l2288_228821


namespace triangle_area_l2288_228824

/-- Given a triangle with perimeter 20 cm and inradius 2.5 cm, its area is 25 cm². -/
theorem triangle_area (perimeter : ℝ) (inradius : ℝ) (area : ℝ) 
    (h1 : perimeter = 20) 
    (h2 : inradius = 2.5) 
    (h3 : area = inradius * (perimeter / 2)) : 
  area = 25 := by
  sorry

end triangle_area_l2288_228824


namespace pirate_loot_sum_l2288_228863

/-- Converts a number from base b to base 10 -/
def to_base_10 (digits : List ℕ) (b : ℕ) : ℕ :=
  digits.enum.foldl (fun acc (i, d) => acc + d * b^i) 0

/-- The value from S.S. AOPS in base 5 -/
def aops_value : List ℕ := [4, 2, 1, 3]

/-- The value from S.S. BOPS in base 7 -/
def bops_value : List ℕ := [2, 1, 0, 1]

/-- The value from S.S. COPS in base 8 -/
def cops_value : List ℕ := [3, 2, 1]

/-- The theorem to be proved -/
theorem pirate_loot_sum :
  to_base_10 aops_value 5 + to_base_10 bops_value 7 + to_base_10 cops_value 8 = 849 := by
  sorry

end pirate_loot_sum_l2288_228863


namespace G_equals_negative_three_F_l2288_228876

noncomputable def F (x : ℝ) : ℝ := Real.log ((1 + x) / (1 - x))

noncomputable def G (x : ℝ) : ℝ := F ((5 * x - x^3) / (1 - 5 * x^2))

theorem G_equals_negative_three_F (x : ℝ) : G x = -3 * F x :=
by sorry

end G_equals_negative_three_F_l2288_228876


namespace minutes_to_date_time_correct_l2288_228869

/-- Represents a date and time -/
structure DateTime where
  year : Nat
  month : Nat
  day : Nat
  hour : Nat
  minute : Nat

/-- Converts minutes to a DateTime structure -/
def minutesToDateTime (startDateTime : DateTime) (minutes : Nat) : DateTime :=
  sorry

/-- The starting date and time -/
def startDateTime : DateTime :=
  { year := 2015, month := 1, day := 1, hour := 0, minute := 0 }

/-- The number of minutes to add -/
def minutesToAdd : Nat := 3050

/-- The expected result date and time -/
def expectedDateTime : DateTime :=
  { year := 2015, month := 1, day := 3, hour := 2, minute := 50 }

theorem minutes_to_date_time_correct :
  minutesToDateTime startDateTime minutesToAdd = expectedDateTime :=
  sorry

end minutes_to_date_time_correct_l2288_228869


namespace students_with_both_pets_l2288_228813

theorem students_with_both_pets (total : ℕ) (dog : ℕ) (cat : ℕ) (no_pet : ℕ) 
  (h_total : total = 50)
  (h_dog : dog = 30)
  (h_cat : cat = 35)
  (h_no_pet : no_pet = 3)
  (h_at_least_one : ∀ s, s ∈ Finset.range total → 
    (s ∈ Finset.range dog ∨ s ∈ Finset.range cat ∨ s ∈ Finset.range no_pet)) :
  Finset.card (Finset.range dog ∩ Finset.range cat) = 18 := by
  sorry

end students_with_both_pets_l2288_228813


namespace main_theorem_l2288_228874

-- Define the propositions p and q
def p (m a : ℝ) : Prop := (m - a) * (m - 3 * a) ≤ 0
def q (m : ℝ) : Prop := (m + 2) * (m + 1) < 0

-- Define the condition for m to represent a hyperbola
def is_hyperbola (m : ℝ) : Prop :=
  ∃ (x y : ℝ), x^2 / (2 + m) + y^2 / (m + 1) = 1

-- Main theorem
theorem main_theorem (m a : ℝ) 
  (h1 : m^2 - 4*a*m + 3*a^2 ≤ 0)
  (h2 : is_hyperbola m) :
  (a = -1 ∧ (p m a ∨ q m) → -3 ≤ m ∧ m ≤ -1) ∧
  (∀ m, p m a → ¬q m) ∧ (∃ m, p m a ∧ q m) →
  (-1/3 ≤ a ∧ a < 0) ∨ a ≤ -2 :=
sorry

end main_theorem_l2288_228874


namespace sqrt_three_plus_one_over_two_lt_sqrt_two_l2288_228808

theorem sqrt_three_plus_one_over_two_lt_sqrt_two :
  (Real.sqrt 3 + 1) / 2 < Real.sqrt 2 := by
  sorry

end sqrt_three_plus_one_over_two_lt_sqrt_two_l2288_228808


namespace sin_double_pi_minus_theta_l2288_228861

theorem sin_double_pi_minus_theta (θ : ℝ) 
  (h1 : 3 * (Real.cos θ)^2 = Real.tan θ + 3) 
  (h2 : ∀ k : ℤ, θ ≠ k * Real.pi) : 
  Real.sin (2 * (Real.pi - θ)) = 2/3 := by
  sorry

end sin_double_pi_minus_theta_l2288_228861


namespace function_equality_implies_sum_l2288_228810

theorem function_equality_implies_sum (f : ℝ → ℝ) (a b c : ℝ) :
  (∀ x, f (x - 2) = 4 * x^2 + 9 * x + 5) →
  (∀ x, f x = a * x^2 + b * x + c) →
  a + b + c = 68 := by
sorry

end function_equality_implies_sum_l2288_228810


namespace chapter_page_difference_l2288_228816

theorem chapter_page_difference (chapter1 chapter2 chapter3 : ℕ) 
  (h1 : chapter1 = 35)
  (h2 : chapter2 = 18)
  (h3 : chapter3 = 3) :
  chapter2 - chapter3 = 15 := by
  sorry

end chapter_page_difference_l2288_228816


namespace area_at_stage_4_is_1360_l2288_228844

/-- The area of the figure at stage n, given an initial square of side length 4 inches -/
def area_at_stage (n : ℕ) : ℕ :=
  let initial_side := 4
  let rec sum_areas (k : ℕ) (acc : ℕ) : ℕ :=
    if k = 0 then acc
    else sum_areas (k - 1) (acc + (initial_side * 2^(k - 1))^2)
  sum_areas n 0

/-- The theorem stating that the area at stage 4 is 1360 square inches -/
theorem area_at_stage_4_is_1360 : area_at_stage 4 = 1360 := by
  sorry

end area_at_stage_4_is_1360_l2288_228844


namespace square_pieces_count_l2288_228847

/-- Represents a square sheet of paper -/
structure SquareSheet :=
  (side : ℝ)
  (area : ℝ := side * side)

/-- Represents the state of the paper after folding and cutting -/
structure FoldedCutSheet :=
  (original : SquareSheet)
  (num_folds : ℕ)
  (num_cuts : ℕ)

/-- Counts the number of square pieces after unfolding -/
def count_square_pieces (sheet : FoldedCutSheet) : ℕ :=
  sorry

/-- Theorem stating that folding a square sheet twice and cutting twice results in 5 square pieces -/
theorem square_pieces_count (s : SquareSheet) :
  let folded_cut := FoldedCutSheet.mk s 2 2
  count_square_pieces folded_cut = 5 :=
sorry

end square_pieces_count_l2288_228847


namespace work_completion_time_l2288_228858

theorem work_completion_time 
  (ratio_a : ℚ) 
  (ratio_b : ℚ) 
  (combined_time : ℚ) 
  (h1 : ratio_a / ratio_b = 3 / 2) 
  (h2 : combined_time = 18) : 
  ratio_a / (ratio_a + ratio_b) * combined_time = 30 := by
sorry

end work_completion_time_l2288_228858


namespace base_conversion_2458_to_base_7_l2288_228845

theorem base_conversion_2458_to_base_7 :
  2458 = 1 * 7^4 + 0 * 7^3 + 1 * 7^2 + 1 * 7^1 + 1 * 7^0 :=
by sorry

end base_conversion_2458_to_base_7_l2288_228845


namespace division_problem_l2288_228823

theorem division_problem (h : (7125 : ℝ) / 1.25 = 5700) : 
  ∃ x : ℝ, 712.5 / x = 57 ∧ x = 12.5 := by sorry

end division_problem_l2288_228823


namespace rudys_running_time_l2288_228830

/-- Calculates the total running time for Rudy given two separate runs -/
def totalRunningTime (distance1 : ℝ) (rate1 : ℝ) (distance2 : ℝ) (rate2 : ℝ) : ℝ :=
  distance1 * rate1 + distance2 * rate2

/-- Proves that Rudy's total running time is 88 minutes -/
theorem rudys_running_time :
  totalRunningTime 5 10 4 9.5 = 88 := by
  sorry

end rudys_running_time_l2288_228830


namespace complex_simplification_l2288_228833

/-- The imaginary unit i -/
def i : ℂ := Complex.I

/-- Theorem stating the equality of the complex expression and its simplified form -/
theorem complex_simplification :
  3 * (2 + i) - i * (3 - i) + 2 * (1 - 2*i) = 7 - 4*i :=
by sorry

end complex_simplification_l2288_228833


namespace coefficient_x3y5_l2288_228860

-- Define the binomial coefficient
def binomial (n k : ℕ) : ℚ := (Nat.factorial n) / (Nat.factorial k * Nat.factorial (n - k))

-- Define the expression
def expression (x y : ℚ) : ℚ := (2/3 * x - 4/5 * y)^8

-- State the theorem
theorem coefficient_x3y5 :
  (binomial 8 3) * (2/3)^3 * (-4/5)^5 = -458752/84375 := by sorry

end coefficient_x3y5_l2288_228860


namespace exercise_book_count_l2288_228878

theorem exercise_book_count (pencil_count : ℕ) (pencil_ratio : ℕ) (book_ratio : ℕ) :
  pencil_count = 120 →
  pencil_ratio = 10 →
  book_ratio = 3 →
  (pencil_count * book_ratio) / pencil_ratio = 36 :=
by
  sorry

end exercise_book_count_l2288_228878


namespace arithmetic_sequence_remainder_l2288_228898

/-- The sum of an arithmetic sequence -/
def arithmetic_sum (a₁ aₙ : ℕ) (d : ℕ) : ℕ :=
  let n := (aₙ - a₁) / d + 1
  n * (a₁ + aₙ) / 2

/-- The problem statement -/
theorem arithmetic_sequence_remainder (a₁ aₙ d : ℕ) 
  (h₁ : a₁ = 3)
  (h₂ : aₙ = 273)
  (h₃ : d = 6)
  (h₄ : ∀ k, 1 ≤ k ∧ k ≤ (aₙ - a₁) / d + 1 → a₁ + (k - 1) * d = 6 * k - 3) :
  arithmetic_sum a₁ aₙ d % 8 = 2 := by
  sorry


end arithmetic_sequence_remainder_l2288_228898


namespace sum_a_d_l2288_228805

theorem sum_a_d (a b c d : ℤ) 
  (eq1 : a + b = 14) 
  (eq2 : b + c = 9) 
  (eq3 : c + d = 3) : 
  a + d = 8 := by
sorry

end sum_a_d_l2288_228805


namespace star_properties_l2288_228884

-- Define the "※" operation
def star (m n : ℚ) : ℚ := 3 * m - n

-- Theorem statement
theorem star_properties :
  (star 2 10 = -4) ∧
  (∃ a b c : ℚ, star a (b + c) ≠ star a b + star a c) :=
by sorry

end star_properties_l2288_228884


namespace roots_expression_l2288_228894

theorem roots_expression (p q : ℝ) (α β γ δ : ℝ) 
  (hαβ : α^2 + p*α - 1 = 0 ∧ β^2 + p*β - 1 = 0)
  (hγδ : γ^2 + q*γ - 1 = 0 ∧ δ^2 + q*δ - 1 = 0) :
  (α - γ)*(β - γ)*(α - δ)*(β - δ) = -(p - q)^2 := by
sorry

end roots_expression_l2288_228894


namespace income_expenditure_ratio_l2288_228887

/-- Given a person's income and savings, prove the ratio of income to expenditure -/
theorem income_expenditure_ratio 
  (income : ℕ) 
  (savings : ℕ) 
  (h1 : income = 14000) 
  (h2 : savings = 2000) :
  (income : ℚ) / (income - savings) = 7 / 6 :=
by sorry

end income_expenditure_ratio_l2288_228887


namespace erin_savings_days_l2288_228867

/-- The daily amount Erin receives in dollars -/
def daily_amount : ℕ := 3

/-- The total amount Erin needs to receive in dollars -/
def total_amount : ℕ := 30

/-- The number of days it takes Erin to receive the total amount -/
def days_to_total : ℕ := total_amount / daily_amount

theorem erin_savings_days : days_to_total = 10 := by
  sorry

end erin_savings_days_l2288_228867


namespace right_triangle_probability_l2288_228814

/-- A regular octagon -/
structure RegularOctagon where
  vertices : Finset (ℕ × ℕ)
  regular : vertices.card = 8
  -- Additional properties of a regular octagon could be added here

/-- A triangle formed by three vertices of a regular octagon -/
structure OctagonTriangle (octagon : RegularOctagon) where
  vertices : Finset (ℕ × ℕ)
  subset : vertices ⊆ octagon.vertices
  three_points : vertices.card = 3

/-- Predicate to determine if a triangle is right-angled -/
def is_right_triangle (triangle : OctagonTriangle octagon) : Prop :=
  sorry -- Definition of a right triangle in terms of the octagon's geometry

/-- The set of all possible triangles from an octagon -/
def all_triangles (octagon : RegularOctagon) : Finset (OctagonTriangle octagon) :=
  sorry

/-- The set of right triangles from an octagon -/
def right_triangles (octagon : RegularOctagon) : Finset (OctagonTriangle octagon) :=
  sorry

/-- The main theorem -/
theorem right_triangle_probability (octagon : RegularOctagon) :
  (right_triangles octagon).card / (all_triangles octagon).card = 2 / 7 :=
sorry

end right_triangle_probability_l2288_228814


namespace tangent_line_equation_l2288_228839

/-- The curve function -/
def f (x : ℝ) : ℝ := 2 * x^3 - 3 * x + 1

/-- The derivative of the curve function -/
def f' (x : ℝ) : ℝ := 6 * x^2 - 3

/-- The point of tangency -/
def point : ℝ × ℝ := (1, 0)

/-- Theorem: The equation of the tangent line to y = 2x^3 - 3x + 1 at (1, 0) is 3x - y - 3 = 0 -/
theorem tangent_line_equation :
  ∀ x y : ℝ, (x, y) ∈ {(x, y) | 3 * x - y - 3 = 0} ↔
  y - point.2 = f' point.1 * (x - point.1) :=
by sorry

end tangent_line_equation_l2288_228839


namespace group_size_l2288_228856

theorem group_size (T : ℕ) (N : ℕ) (h1 : N > 0) : 
  (T : ℝ) / N - 3 = (T - 44 + 14 : ℝ) / N → N = 10 := by
  sorry

end group_size_l2288_228856


namespace lottery_winning_probability_l2288_228825

/-- The number of options for the MagicBall -/
def magicBallOptions : ℕ := 25

/-- The number of options for each TrophyBall -/
def trophyBallOptions : ℕ := 48

/-- The number of TrophyBalls to be selected -/
def trophyBallsToSelect : ℕ := 5

/-- The probability of winning the lottery -/
def winningProbability : ℚ := 1 / 63180547200

theorem lottery_winning_probability :
  1 / (magicBallOptions * (trophyBallOptions.factorial / (trophyBallOptions - trophyBallsToSelect).factorial)) = winningProbability :=
sorry

end lottery_winning_probability_l2288_228825


namespace f_max_min_implies_m_range_l2288_228840

/-- The function f(x) = x^2 - 2x + 2 -/
def f (x : ℝ) : ℝ := x^2 - 2*x + 2

/-- Theorem: If the maximum value of f(x) in [0,m] is 2 and the minimum is 1, then 1 ≤ m ≤ 2 -/
theorem f_max_min_implies_m_range (m : ℝ) 
  (h_max : ∀ x ∈ Set.Icc 0 m, f x ≤ 2) 
  (h_min : ∃ x ∈ Set.Icc 0 m, f x = 1) 
  (h_reaches_max : ∃ x ∈ Set.Icc 0 m, f x = 2) : 
  1 ≤ m ∧ m ≤ 2 := by
  sorry

end f_max_min_implies_m_range_l2288_228840


namespace inequality_proof_l2288_228873

theorem inequality_proof (a b c d : ℝ) 
  (h_pos : 0 < d ∧ 0 < c ∧ 0 < b ∧ 0 < a) 
  (h_order : d < c ∧ c < b ∧ b < a) : 
  (a + b + c + d)^2 > a^2 + 3*b^2 + 5*c^2 + 7*d^2 := by
  sorry

end inequality_proof_l2288_228873


namespace min_cost_grass_seed_l2288_228803

/-- Represents a bag of grass seed -/
structure SeedBag where
  weight : Nat
  price : Rat

/-- Calculates the total weight of a list of seed bags -/
def totalWeight (bags : List SeedBag) : Nat :=
  bags.foldl (fun acc bag => acc + bag.weight) 0

/-- Calculates the total price of a list of seed bags -/
def totalPrice (bags : List SeedBag) : Rat :=
  bags.foldl (fun acc bag => acc + bag.price) 0

/-- Theorem: The minimum cost to buy between 65 and 80 pounds of grass seed is $98.75 -/
theorem min_cost_grass_seed (bag5 bag10 bag25 : SeedBag)
    (h1 : bag5.weight = 5 ∧ bag5.price = 1385 / 100)
    (h2 : bag10.weight = 10 ∧ bag10.price = 2040 / 100)
    (h3 : bag25.weight = 25 ∧ bag25.price = 3225 / 100) :
    ∃ (bags : List SeedBag),
      (totalWeight bags ≥ 65 ∧ totalWeight bags ≤ 80) ∧
      totalPrice bags = 9875 / 100 ∧
      ∀ (other_bags : List SeedBag),
        (totalWeight other_bags ≥ 65 ∧ totalWeight other_bags ≤ 80) →
        totalPrice other_bags ≥ 9875 / 100 := by
  sorry

end min_cost_grass_seed_l2288_228803


namespace purchase_cost_l2288_228829

/-- The cost of purchasing bananas and oranges -/
theorem purchase_cost (banana_quantity : ℕ) (orange_quantity : ℕ) 
  (banana_price : ℚ) (orange_price : ℚ) : 
  banana_quantity = 5 → 
  orange_quantity = 10 → 
  banana_price = 2 → 
  orange_price = (3/2) → 
  banana_quantity * banana_price + orange_quantity * orange_price = 25 := by
  sorry

end purchase_cost_l2288_228829


namespace solution_satisfies_equations_l2288_228818

theorem solution_satisfies_equations :
  ∃ (x y : ℚ), 
    (x = 5/2 ∧ y = 3) ∧
    (x + y + 1 = (6 - x) + (6 - y)) ∧
    (x - y + 2 = (x - 2) + (y - 2)) := by
  sorry

end solution_satisfies_equations_l2288_228818


namespace max_pons_is_nine_nine_pons_achievable_l2288_228819

/-- Represents the number of items Bill can buy -/
structure ItemCounts where
  pan : ℕ
  pin : ℕ
  pon : ℕ

/-- Calculates the total cost of the items -/
def totalCost (items : ItemCounts) : ℕ :=
  3 * items.pan + 5 * items.pin + 10 * items.pon

/-- Checks if the item counts satisfy the conditions -/
def isValid (items : ItemCounts) : Prop :=
  items.pan ≥ 1 ∧ items.pin ≥ 1 ∧ items.pon ≥ 1 ∧ totalCost items = 100

/-- The maximum number of pons that can be purchased -/
def maxPons : ℕ := 9

theorem max_pons_is_nine :
  ∀ items : ItemCounts, isValid items → items.pon ≤ maxPons :=
by sorry

theorem nine_pons_achievable :
  ∃ items : ItemCounts, isValid items ∧ items.pon = maxPons :=
by sorry

end max_pons_is_nine_nine_pons_achievable_l2288_228819


namespace prove_b_value_l2288_228815

theorem prove_b_value (a b : ℕ) (h1 : a = 105) (h2 : a^3 = 21 * 25 * 315 * b) : b = 7 := by
  sorry

end prove_b_value_l2288_228815


namespace square_sum_given_difference_l2288_228857

theorem square_sum_given_difference (a : ℝ) (h : a - 1/a = 3) : (a + 1/a)^2 = 13 := by
  sorry

end square_sum_given_difference_l2288_228857


namespace natural_numbers_product_sum_diff_l2288_228899

theorem natural_numbers_product_sum_diff (m n : ℕ) :
  (m + n) * |Int.ofNat m - Int.ofNat n| = 2021 →
  ((m = 1011 ∧ n = 1010) ∨ (m = 45 ∧ n = 2)) := by
  sorry

end natural_numbers_product_sum_diff_l2288_228899


namespace walker_round_trip_l2288_228855

/-- Ms. Walker's round trip driving problem -/
theorem walker_round_trip (speed_to_work : ℝ) (speed_from_work : ℝ) (total_time : ℝ) 
  (h1 : speed_to_work = 60)
  (h2 : speed_from_work = 40)
  (h3 : total_time = 1) :
  ∃ (distance : ℝ), distance / speed_to_work + distance / speed_from_work = total_time ∧ distance = 24 := by
  sorry

end walker_round_trip_l2288_228855


namespace weight_of_B_l2288_228843

theorem weight_of_B (A B C : ℝ) 
  (h1 : (A + B + C) / 3 = 45)
  (h2 : (A + B) / 2 = 40)
  (h3 : (B + C) / 2 = 47) :
  B = 39 := by
sorry

end weight_of_B_l2288_228843


namespace parallel_vectors_dot_product_l2288_228836

def a (m n : ℝ) : Fin 3 → ℝ := ![1, 3*m - 1, n - 2]
def b (m n : ℝ) : Fin 3 → ℝ := ![2, 3*m + 1, 3*n - 4]

def parallel (u v : Fin 3 → ℝ) : Prop :=
  ∃ (k : ℝ), ∀ (i : Fin 3), u i = k * v i

def dot_product (u v : Fin 3 → ℝ) : ℝ :=
  (u 0) * (v 0) + (u 1) * (v 1) + (u 2) * (v 2)

theorem parallel_vectors_dot_product (m n : ℝ) :
  parallel (a m n) (b m n) → dot_product (a m n) (b m n) = 18 := by
  sorry

end parallel_vectors_dot_product_l2288_228836


namespace sum_F_equals_535501_l2288_228896

/-- F(n) is the smallest positive integer greater than n whose sum of digits is equal to the sum of the digits of n -/
def F (n : ℕ) : ℕ := sorry

/-- The sum of F(n) for n from 1 to 1000 -/
def sum_F : ℕ := (List.range 1000).map F |>.sum

theorem sum_F_equals_535501 : sum_F = 535501 := by sorry

end sum_F_equals_535501_l2288_228896


namespace projection_matrix_values_l2288_228879

def is_projection_matrix (Q : Matrix (Fin 2) (Fin 2) ℝ) : Prop :=
  Q * Q = Q

theorem projection_matrix_values :
  ∀ (a c : ℝ),
  let Q : Matrix (Fin 2) (Fin 2) ℝ := !![a, 18/45; c, 27/45]
  is_projection_matrix Q →
  a = 2/5 ∧ c = 3/5 := by
  sorry

end projection_matrix_values_l2288_228879


namespace sin_180_degrees_l2288_228852

/-- The sine of 180 degrees is 0. -/
theorem sin_180_degrees : Real.sin (π) = 0 := by sorry

end sin_180_degrees_l2288_228852


namespace quadratic_root_product_l2288_228820

theorem quadratic_root_product (p q : ℝ) : 
  (∃ x : ℂ, x^2 + p*x + q = 0 ∧ x = 3 - 4*Complex.I) → p*q = -150 := by
  sorry

end quadratic_root_product_l2288_228820


namespace lunch_combinations_count_l2288_228841

/-- Represents the number of options for each lunch component -/
structure LunchOptions where
  mainCourses : Nat
  beverages : Nat
  snacks : Nat

/-- Calculates the total number of lunch combinations -/
def totalCombinations (options : LunchOptions) : Nat :=
  options.mainCourses * options.beverages * options.snacks

/-- The given lunch options in the cafeteria -/
def cafeteriaOptions : LunchOptions :=
  { mainCourses := 4
  , beverages := 3
  , snacks := 2 }

/-- Theorem stating that the number of lunch combinations is 24 -/
theorem lunch_combinations_count : totalCombinations cafeteriaOptions = 24 := by
  sorry

end lunch_combinations_count_l2288_228841


namespace base7_addition_theorem_l2288_228859

/-- Addition of numbers in base 7 -/
def base7_add (a b c : ℕ) : ℕ :=
  (a + b + c) % 7^4

/-- Conversion from base 7 to decimal -/
def base7_to_decimal (n : ℕ) : ℕ :=
  (n / 7^3) * 7^3 + ((n / 7^2) % 7) * 7^2 + ((n / 7) % 7) * 7 + (n % 7)

theorem base7_addition_theorem :
  base7_add (base7_to_decimal 256) (base7_to_decimal 463) (base7_to_decimal 132) =
  base7_to_decimal 1214 :=
sorry

end base7_addition_theorem_l2288_228859


namespace perpendicular_planes_from_perpendicular_lines_l2288_228897

-- Define the necessary types
variable {Point : Type*} [NormedAddCommGroup Point] [InnerProductSpace ℝ Point] [Finite Point]
variable {Line : Type*} [NormedAddCommGroup Line] [InnerProductSpace ℝ Line] [Finite Line]
variable {Plane : Type*} [NormedAddCommGroup Plane] [InnerProductSpace ℝ Plane] [Finite Plane]

-- Define the necessary relations
variable (perpendicular : Line → Line → Prop)
variable (perpendicular_line_plane : Line → Plane → Prop)
variable (perpendicular_plane : Plane → Plane → Prop)

-- State the theorem
theorem perpendicular_planes_from_perpendicular_lines 
  (m n : Line) (α β : Plane) :
  perpendicular m n → 
  perpendicular_line_plane m α → 
  perpendicular_line_plane n β → 
  perpendicular_plane α β :=
sorry

end perpendicular_planes_from_perpendicular_lines_l2288_228897


namespace machine_depreciation_rate_l2288_228893

/-- The annual depreciation rate of a machine given its initial value,
    selling price after two years, and profit. -/
theorem machine_depreciation_rate
  (initial_value : ℝ)
  (selling_price : ℝ)
  (profit : ℝ)
  (h1 : initial_value = 150000)
  (h2 : selling_price = 113935)
  (h3 : profit = 24000)
  : ∃ (r : ℝ), initial_value * (1 - r / 100)^2 = selling_price - profit :=
sorry

end machine_depreciation_rate_l2288_228893


namespace x₁x₂_equals_1008_l2288_228827

noncomputable def x₁ : ℝ := Real.exp (Real.log 2 * 1008 / (Real.log 2 * Real.exp (Real.log 2 * 1008 / (Real.log 2 * Real.exp (Real.log 2 * 1008 / Real.log 2)))))

noncomputable def x₂ : ℝ := Real.log 2 * 1008 / (Real.log 2 * Real.exp (Real.log 2 * 1008 / Real.log 2))

theorem x₁x₂_equals_1008 :
  x₁ * Real.log x₁ / Real.log 2 = 1008 ∧
  x₂ * 2^x₂ = 1008 →
  x₁ * x₂ = 1008 := by
  sorry

end x₁x₂_equals_1008_l2288_228827


namespace problem_3_l2288_228800

theorem problem_3 (a : ℝ) (h : a = 1 / (Real.sqrt 2 - 1)) : 4 * a^2 - 8 * a + 1 = 5 := by
  sorry

end problem_3_l2288_228800


namespace constant_term_expansion_l2288_228875

theorem constant_term_expansion (x : ℝ) : 
  (x^4 + 3*x^2 + 6) * (2*x^3 + x^2 + 10) = x^7 + 2*x^6 + 3*x^5 + 10*x^4 + 6*x^3 + 30*x^2 + 60 := by
  sorry

#check constant_term_expansion

end constant_term_expansion_l2288_228875
