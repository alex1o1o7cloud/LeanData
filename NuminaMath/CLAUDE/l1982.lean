import Mathlib

namespace ten_dollar_combinations_l1982_198294

def coin_combinations (target : ℕ) (coins : List ℕ) : ℕ :=
  sorry

theorem ten_dollar_combinations :
  coin_combinations 10 [1, 2, 5] = 10 :=
sorry

end ten_dollar_combinations_l1982_198294


namespace inequality_not_always_true_l1982_198233

theorem inequality_not_always_true (a b : ℝ) (h : a > b) :
  ∃ c : ℝ, a * c^2 ≤ b * c^2 :=
sorry

end inequality_not_always_true_l1982_198233


namespace quadratic_factorization_l1982_198251

theorem quadratic_factorization (x y : ℝ) : 5*x^2 + 6*x*y - 8*y^2 = (x + 2*y)*(5*x - 4*y) := by
  sorry

end quadratic_factorization_l1982_198251


namespace smallest_perimeter_l1982_198234

/-- Represents the side lengths of the squares in the rectangle --/
structure SquareSides where
  a : ℕ
  b : ℕ

/-- Calculates the perimeter of the rectangle given the square sides --/
def rectanglePerimeter (s : SquareSides) : ℕ :=
  2 * ((2 * s.a + 3 * s.b) + (3 * s.a + 4 * s.b))

/-- The theorem stating the smallest possible perimeter --/
theorem smallest_perimeter :
  ∃ (s : SquareSides), 
    (5 * s.a + 2 * s.b = 20 * s.a - 3 * s.b) ∧
    (∀ (t : SquareSides), rectanglePerimeter s ≤ rectanglePerimeter t) ∧
    rectanglePerimeter s = 52 := by
  sorry

end smallest_perimeter_l1982_198234


namespace square_side_length_l1982_198208

theorem square_side_length (x : ℝ) : 
  x > 0 ∧ 
  x + (x + 17) + (x + 11) = 52 →
  x = 8 := by
sorry

end square_side_length_l1982_198208


namespace function_composition_theorem_l1982_198270

theorem function_composition_theorem (a b : ℤ) :
  (∃ f g : ℤ → ℤ, ∀ x : ℤ, f (g x) = x + a ∧ g (f x) = x + b) ↔ (a = b ∨ a = -b) :=
by sorry

end function_composition_theorem_l1982_198270


namespace martinez_chiquita_height_difference_l1982_198232

/-- The height difference between Mr. Martinez and Chiquita -/
theorem martinez_chiquita_height_difference :
  ∀ (martinez_height chiquita_height : ℝ),
  chiquita_height = 5 →
  martinez_height + chiquita_height = 12 →
  martinez_height - chiquita_height = 2 :=
by
  sorry

end martinez_chiquita_height_difference_l1982_198232


namespace log_simplification_l1982_198224

theorem log_simplification (a b c d x y : ℝ) 
  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) (hx : 0 < x) (hy : 0 < y) : 
  Real.log (a^2 / b) + Real.log (b / c^2) + Real.log (c / d) - Real.log (a^2 * y / (d^3 * x)) = 
  Real.log (d^2 * x / y) := by
sorry

end log_simplification_l1982_198224


namespace corn_purchase_proof_l1982_198219

/-- The cost of corn in dollars per pound -/
def corn_cost : ℝ := 0.99

/-- The cost of beans in dollars per pound -/
def bean_cost : ℝ := 0.75

/-- The total weight of corn and beans in pounds -/
def total_weight : ℝ := 20

/-- The total cost in dollars -/
def total_cost : ℝ := 16.80

/-- The number of pounds of corn purchased -/
def corn_weight : ℝ := 7.5

theorem corn_purchase_proof :
  ∃ (bean_weight : ℝ),
    bean_weight ≥ 0 ∧
    corn_weight ≥ 0 ∧
    bean_weight + corn_weight = total_weight ∧
    bean_cost * bean_weight + corn_cost * corn_weight = total_cost :=
by sorry

end corn_purchase_proof_l1982_198219


namespace concentric_circles_ratio_l1982_198210

theorem concentric_circles_ratio (r₁ r₂ r₃ : ℝ) (h₁ : 0 < r₁) (h₂ : r₁ < r₂) (h₃ : r₂ < r₃) :
  (r₂^2 - r₁^2 = 2 * (r₃^2 - r₂^2)) →
  (r₃^2 = 3 * (r₂^2 - r₁^2)) →
  ∃ (k : ℝ), r₃ = k ∧ r₂ = k * Real.sqrt (5/6) ∧ r₁ = k / Real.sqrt 3 :=
by sorry

end concentric_circles_ratio_l1982_198210


namespace second_guldin_theorem_l1982_198296

/-- A plate with an arbitrary boundary -/
structure ArbitraryPlate where
  area : ℝ
  centerOfMass : ℝ × ℝ × ℝ

/-- The volume generated by rotating an arbitrary plate around an axis -/
def rotationVolume (plate : ArbitraryPlate) (axisDistance : ℝ) : ℝ := sorry

/-- The second Guldin's theorem for an arbitrary plate -/
theorem second_guldin_theorem (plate : ArbitraryPlate) (axisDistance : ℝ) :
  rotationVolume plate axisDistance = 2 * Real.pi * plate.area * axisDistance := by
  sorry

end second_guldin_theorem_l1982_198296


namespace goldbach_126_max_diff_l1982_198209

def is_prime (n : ℕ) : Prop := n > 1 ∧ ∀ d : ℕ, d > 1 → d < n → ¬(n % d = 0)

theorem goldbach_126_max_diff :
  ∃ (p q : ℕ), 
    is_prime p ∧ 
    is_prime q ∧ 
    p ≠ q ∧ 
    p + q = 126 ∧
    ∀ (r s : ℕ), is_prime r → is_prime s → r ≠ s → r + s = 126 → 
      (max r s - min r s) ≤ (max p q - min p q) ∧
    (max p q - min p q) = 100 :=
sorry

end goldbach_126_max_diff_l1982_198209


namespace remainder_of_sum_divided_by_256_l1982_198255

theorem remainder_of_sum_divided_by_256 :
  (1234567 + 890123) % 256 = 74 := by
  sorry

end remainder_of_sum_divided_by_256_l1982_198255


namespace total_dolls_l1982_198237

theorem total_dolls (hannah_ratio : ℝ) (sister_dolls : ℝ) : 
  hannah_ratio = 5.5 →
  sister_dolls = 8.5 →
  hannah_ratio * sister_dolls + sister_dolls = 55.25 := by
  sorry

end total_dolls_l1982_198237


namespace town_distance_proof_l1982_198282

/-- The distance between two towns on a map in inches -/
def map_distance : ℝ := 18

/-- The scale of the map in inches -/
def scale_inches : ℝ := 0.5

/-- The scale of the map in miles -/
def scale_miles : ℝ := 6

/-- The actual distance between the towns in miles -/
def actual_distance : ℝ := 216

theorem town_distance_proof :
  (map_distance * scale_miles) / scale_inches = actual_distance := by
  sorry

end town_distance_proof_l1982_198282


namespace jerry_fireworks_l1982_198276

theorem jerry_fireworks (firecrackers sparklers : ℕ) 
  (h1 : firecrackers = 48)
  (h2 : sparklers = 30)
  (confiscated_firecrackers : ℕ := firecrackers / 4)
  (confiscated_sparklers : ℕ := sparklers / 10)
  (remaining_firecrackers : ℕ := firecrackers - confiscated_firecrackers)
  (remaining_sparklers : ℕ := sparklers - confiscated_sparklers)
  (defective_firecrackers : ℕ := remaining_firecrackers / 6)
  (defective_sparklers : ℕ := remaining_sparklers / 4)
  (good_firecrackers : ℕ := remaining_firecrackers - defective_firecrackers)
  (good_sparklers : ℕ := remaining_sparklers - defective_sparklers)
  (set_off_firecrackers : ℕ := good_firecrackers / 2)
  (set_off_sparklers : ℕ := good_sparklers * 2 / 3) :
  set_off_firecrackers + set_off_sparklers = 29 :=
by sorry

end jerry_fireworks_l1982_198276


namespace gumball_ratio_l1982_198287

/-- Gumball machine problem -/
theorem gumball_ratio : 
  ∀ (red green blue : ℕ),
  red = 16 →
  green = 4 * blue →
  red + green + blue = 56 →
  blue * 2 = red :=
by
  sorry

end gumball_ratio_l1982_198287


namespace least_perimeter_triangle_l1982_198279

theorem least_perimeter_triangle (a b c : ℕ) : 
  a = 45 → b = 53 → c > 0 → 
  (a + b > c) → (a + c > b) → (b + c > a) →
  ∀ x : ℕ, (x > 0 ∧ (a + x > b) ∧ (b + x > a) ∧ (a + b > x)) → (a + b + c ≤ a + b + x) →
  a + b + c = 107 := by
sorry

end least_perimeter_triangle_l1982_198279


namespace polynomial_factorization_l1982_198271

theorem polynomial_factorization (m : ℤ) : 
  (∃ (A B C D E F : ℤ), 
    (A * x + B * y + C) * (D * x + E * y + F) = x^2 + 4*x*y + 2*x + m*y + m^2 - 16) ↔ 
  (m = 5 ∨ m = -6) := by sorry

end polynomial_factorization_l1982_198271


namespace min_Q_value_l1982_198268

def is_special_number (m : ℕ) : Prop :=
  10 ≤ m ∧ m < 100 ∧ m % 10 ≠ m / 10 ∧ m % 10 ≠ 0 ∧ m / 10 ≠ 0

def swap_digits (m : ℕ) : ℕ :=
  (m % 10) * 10 + m / 10

def F (m : ℕ) : ℚ :=
  (m * 100 + swap_digits m - (swap_digits m * 100 + m)) / 99

def Q (s t : ℕ) : ℚ :=
  (t - s : ℚ) / s

theorem min_Q_value (a b x y : ℕ) (h1 : 1 ≤ b) (h2 : b < a) (h3 : a ≤ 7)
    (h4 : 1 ≤ x) (h5 : x ≤ 8) (h6 : 1 ≤ y) (h7 : y ≤ 8)
    (hs : is_special_number (10 * a + b)) (ht : is_special_number (10 * x + y))
    (hFs : F (10 * a + b) % 5 = 1)
    (hFt : F (10 * x + y) - F (10 * a + b) + 18 * x = 36) :
    ∃ (s t : ℕ), is_special_number s ∧ is_special_number t ∧
      Q s t = -42 / 73 ∧ ∀ (s' t' : ℕ), is_special_number s' → is_special_number t' →
        Q s' t' ≥ -42 / 73 :=
  sorry

end min_Q_value_l1982_198268


namespace power_sum_to_quadratic_expression_l1982_198243

theorem power_sum_to_quadratic_expression (x : ℝ) :
  5 * (3 : ℝ)^x = 243 →
  (x + 2) * (x - 2) = 21 - 10 * (Real.log 5 / Real.log 3) + (Real.log 5 / Real.log 3)^2 := by
  sorry

end power_sum_to_quadratic_expression_l1982_198243


namespace total_nails_l1982_198222

/-- The number of nails each person has -/
structure NailCount where
  violet : ℕ
  tickletoe : ℕ
  sillysocks : ℕ

/-- The conditions of the nail counting problem -/
def nail_conditions (n : NailCount) : Prop :=
  n.violet = 2 * n.tickletoe + 3 ∧
  n.sillysocks = 3 * n.tickletoe - 2 ∧
  3 * n.tickletoe = 2 * n.violet ∧
  4 * n.tickletoe = 3 * n.sillysocks ∧
  n.violet = 27

/-- The theorem stating the total number of nails -/
theorem total_nails (n : NailCount) (h : nail_conditions n) : 
  n.violet + n.tickletoe + n.sillysocks = 73 := by
  sorry

end total_nails_l1982_198222


namespace expectation_linear_transformation_l1982_198230

variable (X : Type) [MeasurableSpace X]
variable (μ : Measure X)
variable (f : X → ℝ)

noncomputable def expectation (f : X → ℝ) : ℝ := ∫ x, f x ∂μ

theorem expectation_linear_transformation 
  (h : expectation μ f = 6) : 
  expectation μ (fun x => 3 * (f x - 2)) = 12 := by
  sorry

end expectation_linear_transformation_l1982_198230


namespace min_value_of_2a_plus_b_l1982_198283

/-- Given a line x/a + y/b = 1 where a > 0 and b > 0, and the line passes through the point (1, 2),
    the minimum value of 2a + b is 8. -/
theorem min_value_of_2a_plus_b (a b : ℝ) (ha : a > 0) (hb : b > 0) 
  (h_line : ∀ x y : ℝ, x / a + y / b = 1 → x = 1 ∧ y = 2) :
  (∀ a' b' : ℝ, a' > 0 → b' > 0 → 
    (∀ x y : ℝ, x / a' + y / b' = 1 → x = 1 ∧ y = 2) → 
    2 * a' + b' ≥ 2 * a + b) ∧
  2 * a + b = 8 :=
sorry

end min_value_of_2a_plus_b_l1982_198283


namespace supplement_of_complement_65_l1982_198254

def complement (α : ℝ) : ℝ := 90 - α

def supplement (α : ℝ) : ℝ := 180 - α

theorem supplement_of_complement_65 :
  supplement (complement 65) = 155 := by sorry

end supplement_of_complement_65_l1982_198254


namespace opposite_seats_theorem_l1982_198249

/-- Represents a circular seating arrangement -/
structure CircularArrangement where
  total_seats : ℕ
  is_valid : total_seats > 0

/-- Checks if two positions are opposite in a circular arrangement -/
def are_opposite (c : CircularArrangement) (pos1 pos2 : ℕ) : Prop :=
  pos1 ≤ c.total_seats ∧ pos2 ≤ c.total_seats ∧
  (pos2 - pos1) % c.total_seats = c.total_seats / 2

/-- The main theorem stating that if positions 10 and 29 are opposite, 
    the total number of seats is 38 -/
theorem opposite_seats_theorem :
  ∀ c : CircularArrangement, are_opposite c 10 29 → c.total_seats = 38 :=
by sorry

end opposite_seats_theorem_l1982_198249


namespace find_special_number_l1982_198226

theorem find_special_number : 
  ∃ n : ℕ, 
    (∃ k : ℕ, 3 * n = 2 * k + 1) ∧ 
    (∃ m : ℕ, 3 * n = 9 * m) ∧ 
    (∀ x : ℕ, x < n → ¬((∃ k : ℕ, 3 * x = 2 * k + 1) ∧ (∃ m : ℕ, 3 * x = 9 * m))) :=
by sorry

end find_special_number_l1982_198226


namespace otimes_three_four_l1982_198221

-- Define the ⊗ operation
def otimes (m : ℤ) (a b : ℕ) : ℚ :=
  (m * a + b) / (2 * a * b)

-- Theorem statement
theorem otimes_three_four (m : ℤ) :
  (∀ (a b : ℕ), a ≠ 0 → b ≠ 0 → otimes m a b = otimes m b a) →
  otimes m 1 4 = otimes m 2 3 →
  otimes m 3 4 = 11 / 12 := by
  sorry


end otimes_three_four_l1982_198221


namespace trapezoid_area_l1982_198201

/-- The area of a trapezoid with bases 3h and 5h, and height h, is equal to 4h² -/
theorem trapezoid_area (h : ℝ) : h * ((3 * h + 5 * h) / 2) = 4 * h^2 := by
  sorry

end trapezoid_area_l1982_198201


namespace trig_simplification_l1982_198262

theorem trig_simplification (α : ℝ) : 
  (Real.sin (135 * π / 180 - 2 * α))^2 - 
  (Real.sin (210 * π / 180 - 2 * α))^2 - 
  Real.sin (195 * π / 180) * Real.cos (165 * π / 180 - 4 * α) = 
  Real.sin (4 * α) := by
sorry

end trig_simplification_l1982_198262


namespace rectangle_area_l1982_198292

/-- Represents a square with a given side length -/
structure Square where
  side : ℝ
  area : ℝ := side * side

/-- Represents a rectangle with given width and height -/
structure Rectangle where
  width : ℝ
  height : ℝ
  area : ℝ := width * height

/-- The problem statement -/
theorem rectangle_area (s1 s2 s3 s4 : Square) (r : Rectangle) :
  s1.area = 4 ∧ s2.area = 4 ∧ s3.area = 1 ∧ s4.side = 2 * s3.side ∧
  r.width = s1.side + s4.side ∧ r.height = s1.side + s3.side →
  r.area = 12 := by
  sorry

#check rectangle_area

end rectangle_area_l1982_198292


namespace collins_initial_flowers_l1982_198235

/-- Proves that Collin's initial number of flowers is 25 given the problem conditions --/
theorem collins_initial_flowers :
  ∀ (collins_initial_flowers : ℕ) (ingrids_flowers : ℕ) (petals_per_flower : ℕ) (collins_total_petals : ℕ),
    ingrids_flowers = 33 →
    petals_per_flower = 4 →
    collins_total_petals = 144 →
    collins_total_petals = (collins_initial_flowers + ingrids_flowers / 3) * petals_per_flower →
    collins_initial_flowers = 25 :=
by sorry

end collins_initial_flowers_l1982_198235


namespace pet_store_siamese_cats_l1982_198267

theorem pet_store_siamese_cats 
  (house_cats : ℕ) 
  (cats_sold : ℕ) 
  (cats_remaining : ℕ) 
  (h1 : house_cats = 25)
  (h2 : cats_sold = 45)
  (h3 : cats_remaining = 18) :
  ∃ (initial_siamese : ℕ), 
    initial_siamese + house_cats = cats_sold + cats_remaining ∧ 
    initial_siamese = 38 := by
sorry

end pet_store_siamese_cats_l1982_198267


namespace zinc_in_mixture_l1982_198298

/-- Given a mixture of zinc and copper with a ratio of 9:11 and a total weight of 74 kg,
    prove that the amount of zinc in the mixture is 33.3 kg. -/
theorem zinc_in_mixture (ratio_zinc : ℚ) (ratio_copper : ℚ) (total_weight : ℚ) :
  ratio_zinc = 9 →
  ratio_copper = 11 →
  total_weight = 74 →
  (ratio_zinc / (ratio_zinc + ratio_copper)) * total_weight = 33.3 := by
  sorry

end zinc_in_mixture_l1982_198298


namespace veg_eaters_count_l1982_198240

/-- Represents the number of people in different dietary categories in a family. -/
structure FamilyDiet where
  only_veg : ℕ
  only_non_veg : ℕ
  both_veg_and_non_veg : ℕ

/-- Calculates the total number of people who eat veg in the family. -/
def total_veg_eaters (diet : FamilyDiet) : ℕ :=
  diet.only_veg + diet.both_veg_and_non_veg

/-- Theorem stating that the total number of people who eat veg in the family is 19. -/
theorem veg_eaters_count (diet : FamilyDiet)
  (h1 : diet.only_veg = 13)
  (h2 : diet.only_non_veg = 8)
  (h3 : diet.both_veg_and_non_veg = 6) :
  total_veg_eaters diet = 19 := by
  sorry

end veg_eaters_count_l1982_198240


namespace teacher_group_arrangements_l1982_198207

theorem teacher_group_arrangements : 
  let total_female : ℕ := 2
  let total_male : ℕ := 4
  let groups : ℕ := 2
  let female_per_group : ℕ := 1
  let male_per_group : ℕ := 2
  Nat.choose total_female female_per_group * Nat.choose total_male male_per_group = 12 :=
by sorry

end teacher_group_arrangements_l1982_198207


namespace tuesday_spending_multiple_l1982_198274

/-- Represents the spending on sneakers over three days -/
structure SneakerSpending where
  monday : ℕ
  tuesday_multiple : ℕ
  wednesday_multiple : ℕ
  total : ℕ

/-- The spending satisfies the given conditions -/
def valid_spending (s : SneakerSpending) : Prop :=
  s.monday = 60 ∧
  s.wednesday_multiple = 5 ∧
  s.total = 600 ∧
  s.monday + s.monday * s.tuesday_multiple + s.monday * s.wednesday_multiple = s.total

/-- The theorem to be proved -/
theorem tuesday_spending_multiple (s : SneakerSpending) :
  valid_spending s → s.tuesday_multiple = 4 := by
  sorry

end tuesday_spending_multiple_l1982_198274


namespace collectible_toy_price_changes_l1982_198256

/-- Represents the months of the year --/
inductive Month
  | january
  | february
  | march
  | april
  | may
  | june

/-- The price change for each month --/
def price_change : Month → ℝ
  | Month.january => -1.00
  | Month.february => 3.50
  | Month.march => -3.00
  | Month.april => 4.50
  | Month.may => -1.50
  | Month.june => -3.50

/-- The month with the greatest price drop --/
def greatest_drop : Month := Month.june

/-- The month with the greatest price increase --/
def greatest_increase : Month := Month.april

theorem collectible_toy_price_changes :
  (∀ m : Month, price_change greatest_drop ≤ price_change m) ∧
  (∀ m : Month, price_change m ≤ price_change greatest_increase) :=
by sorry

end collectible_toy_price_changes_l1982_198256


namespace max_multicolored_sets_l1982_198236

/-- A color distribution is a list of positive integers representing the number of points of each color. -/
def ColorDistribution := List Nat

/-- The number of multi-colored sets for a given color distribution. -/
def multiColoredSets (d : ColorDistribution) : Nat :=
  d.prod

/-- Predicate to check if a color distribution is valid for the problem. -/
def isValidDistribution (d : ColorDistribution) : Prop :=
  d.length > 0 ∧ 
  d.sum = 2012 ∧ 
  d.Nodup ∧
  d.all (· > 0)

/-- The theorem stating that 61 colors maximize the number of multi-colored sets. -/
theorem max_multicolored_sets : 
  ∃ (d : ColorDistribution), isValidDistribution d ∧ d.length = 61 ∧
  ∀ (d' : ColorDistribution), isValidDistribution d' → d'.length ≠ 61 → 
    multiColoredSets d ≥ multiColoredSets d' :=
  sorry

end max_multicolored_sets_l1982_198236


namespace sphere_surface_area_from_rectangular_solid_l1982_198275

theorem sphere_surface_area_from_rectangular_solid (a b c : ℝ) (h1 : a = 3) (h2 : b = 4) (h3 : c = 5) : 
  let diagonal := Real.sqrt (a^2 + b^2 + c^2)
  let radius := diagonal / 2
  4 * Real.pi * radius^2 = 50 * Real.pi :=
by sorry

end sphere_surface_area_from_rectangular_solid_l1982_198275


namespace daylight_rice_yield_related_l1982_198213

-- Define the concept of related variables
def are_related (x y : Type) : Prop := 
  ¬(∃ f : x → y, Function.Injective f ∧ Function.Surjective f) ∧ 
  ∃ (f : x → y), ∀ (a b : x), a ≠ b → f a ≠ f b

-- Define the variables
def edge_length : Type := Real
def cube_volume : Type := Real
def angle_radian : Type := Real
def sine_value : Type := Real
def daylight_duration : Type := Real
def rice_yield : Type := Real
def person_height : Type := Real
def eyesight : Type := Real

-- State the theorem
theorem daylight_rice_yield_related :
  (¬ are_related edge_length cube_volume) ∧
  (¬ are_related angle_radian sine_value) ∧
  (are_related daylight_duration rice_yield) ∧
  (¬ are_related person_height eyesight) :=
by sorry

end daylight_rice_yield_related_l1982_198213


namespace simplify_square_roots_l1982_198242

theorem simplify_square_roots : Real.sqrt 12 * Real.sqrt 27 - 3 = 15 := by
  sorry

end simplify_square_roots_l1982_198242


namespace absolute_value_sum_l1982_198217

theorem absolute_value_sum : |(-8 : ℤ)| + |(-4 : ℤ)| = 12 := by
  sorry

end absolute_value_sum_l1982_198217


namespace gcd_153_119_l1982_198272

theorem gcd_153_119 : Nat.gcd 153 119 = 17 := by
  sorry

end gcd_153_119_l1982_198272


namespace water_added_to_tank_l1982_198288

theorem water_added_to_tank (tank_capacity : ℚ) 
  (initial_fraction : ℚ) (final_fraction : ℚ) : 
  tank_capacity = 72 ∧ initial_fraction = 3/4 ∧ final_fraction = 7/8 →
  (final_fraction - initial_fraction) * tank_capacity = 9 := by
  sorry

end water_added_to_tank_l1982_198288


namespace probability_both_white_probability_at_least_one_white_l1982_198205

/-- Represents the color of a ball -/
inductive BallColor
  | Red
  | White

/-- Represents the outcome of drawing two balls -/
def DrawOutcome := BallColor × BallColor

/-- The set of all possible outcomes when drawing two balls with replacement -/
def allOutcomes : Finset DrawOutcome := sorry

/-- The set of outcomes where both balls are white -/
def bothWhite : Finset DrawOutcome := sorry

/-- The set of outcomes where at least one ball is white -/
def atLeastOneWhite : Finset DrawOutcome := sorry

/-- The probability of an event occurring -/
def probability (event : Finset DrawOutcome) : ℚ :=
  (event.card : ℚ) / (allOutcomes.card : ℚ)

theorem probability_both_white :
  probability bothWhite = 4/9 := by sorry

theorem probability_at_least_one_white :
  probability atLeastOneWhite = 8/9 := by sorry

end probability_both_white_probability_at_least_one_white_l1982_198205


namespace remainder_problem_l1982_198247

theorem remainder_problem (P D Q R Q' R' : ℕ) 
  (h1 : P = Q * D + 2 * R)
  (h2 : Q = 2 * D * Q' + R') :
  P % (2 * D^2) = D * R' + 2 * R := by
sorry

end remainder_problem_l1982_198247


namespace cost_of_candies_l1982_198293

/-- The cost of buying lollipops and chocolates -/
theorem cost_of_candies (lollipop_cost : ℕ) (chocolate_cost : ℕ) 
  (lollipop_count : ℕ) (chocolate_count : ℕ) : 
  lollipop_cost = 3 →
  chocolate_cost = 2 →
  lollipop_count = 500 →
  chocolate_count = 300 →
  (lollipop_cost * lollipop_count + chocolate_cost * chocolate_count : ℕ) / 100 = 21 :=
by
  sorry

#check cost_of_candies

end cost_of_candies_l1982_198293


namespace profit_ratio_theorem_l1982_198225

/-- Represents the investment of a partner -/
structure Investment where
  amount : ℕ
  duration : ℕ

/-- Calculates the capital-time product of an investment -/
def capitalTimeProduct (i : Investment) : ℕ :=
  i.amount * i.duration

/-- Represents the ratio of two numbers -/
structure Ratio where
  numerator : ℕ
  denominator : ℕ

theorem profit_ratio_theorem (a b : Investment) 
    (h1 : a.amount = 36000) (h2 : a.duration = 12)
    (h3 : b.amount = 54000) (h4 : b.duration = 4) :
    Ratio.mk (capitalTimeProduct a) (capitalTimeProduct b) = Ratio.mk 2 1 := by
  sorry

end profit_ratio_theorem_l1982_198225


namespace joan_gave_63_seashells_l1982_198203

/-- The number of seashells Joan gave to Mike -/
def seashells_given_to_mike (initial_seashells : ℕ) (remaining_seashells : ℕ) : ℕ :=
  initial_seashells - remaining_seashells

/-- Theorem: Joan gave 63 seashells to Mike -/
theorem joan_gave_63_seashells :
  seashells_given_to_mike 79 16 = 63 := by
  sorry

end joan_gave_63_seashells_l1982_198203


namespace quadratic_rational_solutions_l1982_198239

theorem quadratic_rational_solutions (k : ℕ+) : 
  (∃ x : ℚ, k * x^2 + 12 * x + k = 0) ↔ k = 6 := by
  sorry

end quadratic_rational_solutions_l1982_198239


namespace election_winner_percentage_l1982_198228

theorem election_winner_percentage :
  ∀ (total_votes : ℕ) (winner_votes : ℕ) (margin : ℕ),
    winner_votes = 806 →
    margin = 312 →
    total_votes = winner_votes + (winner_votes - margin) →
    (winner_votes : ℚ) / (total_votes : ℚ) = 62 / 100 :=
by
  sorry

end election_winner_percentage_l1982_198228


namespace elizabeth_money_l1982_198245

/-- The amount of money Elizabeth has, given the costs of pens and pencils and the relationship between the number of pens and pencils she can buy. -/
theorem elizabeth_money : 
  let pencil_cost : ℚ := 8/5  -- $1.60 expressed as a rational number
  let pen_cost : ℚ := 2       -- $2.00
  let pencil_count : ℕ := 5   -- Number of pencils
  let pen_count : ℕ := 6      -- Number of pens
  (pencil_cost * pencil_count + pen_cost * pen_count : ℚ) = 20 := by
  sorry

end elizabeth_money_l1982_198245


namespace dave_apps_remaining_l1982_198264

/-- Calculates the number of apps remaining after deletion -/
def apps_remaining (initial : Nat) (deleted : Nat) : Nat :=
  initial - deleted

theorem dave_apps_remaining :
  apps_remaining 16 11 = 5 := by
  sorry

end dave_apps_remaining_l1982_198264


namespace clown_balloons_theorem_l1982_198204

def balloons_problem (initial_dozens : ℕ) (boys : ℕ) (girls : ℕ) : ℕ :=
  initial_dozens * 12 - (boys + girls)

theorem clown_balloons_theorem :
  balloons_problem 3 3 12 = 21 := by
  sorry

end clown_balloons_theorem_l1982_198204


namespace P_divisible_by_factor_l1982_198295

def P (x : ℝ) : ℝ := (x + 1)^6 - x^6 - 2*x - 1

theorem P_divisible_by_factor : ∃ Q : ℝ → ℝ, ∀ x : ℝ, P x = x * (x + 1) * (2*x + 1) * Q x := by
  sorry

end P_divisible_by_factor_l1982_198295


namespace parallel_vectors_difference_magnitude_l1982_198229

/-- Given two vectors a and b in ℝ², where a is parallel to b, 
    prove that the magnitude of their difference is 2√5 -/
theorem parallel_vectors_difference_magnitude 
  (a b : ℝ × ℝ) 
  (h_a : a = (1, 2)) 
  (h_b : b.2 = 6) 
  (h_parallel : ∃ (k : ℝ), a = k • b) : 
  ‖a - b‖ = 2 * Real.sqrt 5 := by
  sorry

end parallel_vectors_difference_magnitude_l1982_198229


namespace strawberry_bucket_problem_l1982_198263

/-- Proves that the number of buckets used is 5 given the conditions of the strawberry problem -/
theorem strawberry_bucket_problem (total_strawberries : ℕ) (removed_per_bucket : ℕ) (remaining_per_bucket : ℕ) 
  (h1 : total_strawberries = 300)
  (h2 : removed_per_bucket = 20)
  (h3 : remaining_per_bucket = 40) :
  (total_strawberries / (removed_per_bucket + remaining_per_bucket) : ℕ) = 5 := by
  sorry

end strawberry_bucket_problem_l1982_198263


namespace sum_in_base4_is_1022_l1982_198244

/-- Converts a base 4 number to base 10 --/
def base4ToBase10 (digits : List Nat) : Nat :=
  digits.enum.foldl (fun acc (i, d) => acc + d * (4 ^ i)) 0

/-- Converts a base 10 number to base 4 --/
def base10ToBase4 (n : Nat) : List Nat :=
  if n = 0 then [0] else
    let rec aux (m : Nat) (acc : List Nat) :=
      if m = 0 then acc
      else aux (m / 4) ((m % 4) :: acc)
    aux n []

/-- The sum of 321₄, 32₄, and 3₄ in base 4 --/
def sumInBase4 : List Nat :=
  let sum := base4ToBase10 [1, 2, 3] + base4ToBase10 [2, 3] + base4ToBase10 [3]
  base10ToBase4 sum

theorem sum_in_base4_is_1022 : sumInBase4 = [1, 0, 2, 2] := by
  sorry

end sum_in_base4_is_1022_l1982_198244


namespace princess_daphne_jewelry_cost_l1982_198277

/-- The cost of Princess Daphne's jewelry purchase -/
def total_cost : ℕ := 240000

/-- The cost of a single necklace -/
def necklace_cost : ℕ := 40000

/-- The cost of the earrings -/
def earrings_cost : ℕ := 3 * necklace_cost

theorem princess_daphne_jewelry_cost :
  3 * necklace_cost + earrings_cost = total_cost :=
by sorry

end princess_daphne_jewelry_cost_l1982_198277


namespace trig_expression_simplification_l1982_198265

theorem trig_expression_simplification :
  let num := Real.sin (20 * π / 180) + Real.sin (40 * π / 180) + Real.sin (60 * π / 180) + Real.sin (80 * π / 180) +
             Real.sin (100 * π / 180) + Real.sin (120 * π / 180) + Real.sin (140 * π / 180) + Real.sin (160 * π / 180)
  let den := Real.cos (15 * π / 180) * Real.cos (30 * π / 180) * Real.cos (45 * π / 180)
  num / den = (16 * Real.sin (50 * π / 180) * Real.sin (70 * π / 180) * Real.cos (10 * π / 180)) /
              (Real.cos (15 * π / 180) * Real.cos (30 * π / 180) * Real.sqrt 2) := by
  sorry


end trig_expression_simplification_l1982_198265


namespace baker_sold_cakes_l1982_198246

/-- Given that Baker bought 31 cakes and sold 47 more cakes than he bought,
    prove that Baker sold 78 cakes. -/
theorem baker_sold_cakes : ℕ → Prop :=
  fun cakes_bought : ℕ =>
    cakes_bought = 31 →
    ∃ cakes_sold : ℕ,
      cakes_sold = cakes_bought + 47 ∧
      cakes_sold = 78

/-- Proof of the theorem -/
lemma prove_baker_sold_cakes : baker_sold_cakes 31 := by
  sorry

end baker_sold_cakes_l1982_198246


namespace portrait_in_silver_box_l1982_198214

-- Define the possible box locations
inductive Box
| Gold
| Silver
| Lead

-- Define the propositions
def p (portrait_location : Box) : Prop := portrait_location = Box.Gold
def q (portrait_location : Box) : Prop := portrait_location ≠ Box.Silver
def r (portrait_location : Box) : Prop := portrait_location ≠ Box.Gold

-- Theorem statement
theorem portrait_in_silver_box :
  ∃! (portrait_location : Box),
    (p portrait_location ∨ q portrait_location ∨ r portrait_location) ∧
    (¬(p portrait_location ∧ q portrait_location) ∧
     ¬(p portrait_location ∧ r portrait_location) ∧
     ¬(q portrait_location ∧ r portrait_location)) →
  portrait_location = Box.Silver :=
by sorry

end portrait_in_silver_box_l1982_198214


namespace ideal_gas_pressure_change_l1982_198280

/-- Given an ideal gas at constant temperature, calculate the new pressure when the volume changes. -/
theorem ideal_gas_pressure_change (V1 V2 P1 P2 : ℝ) (hV1 : V1 = 4.56) (hV2 : V2 = 2.28) (hP1 : P1 = 10) :
  V1 * P1 = V2 * P2 → P2 = 20 := by
  sorry

#check ideal_gas_pressure_change

end ideal_gas_pressure_change_l1982_198280


namespace value_of_y_l1982_198231

theorem value_of_y : ∃ y : ℚ, (3 * y) / 7 = 14 ∧ y = 98 / 3 := by sorry

end value_of_y_l1982_198231


namespace expression_evaluation_l1982_198299

theorem expression_evaluation :
  (2 * Real.sqrt 2 - Real.pi) ^ 0 - 4 * Real.cos (60 * π / 180) + |Real.sqrt 2 - 2| - Real.sqrt 18 = 1 - 4 * Real.sqrt 2 := by
  sorry

end expression_evaluation_l1982_198299


namespace octahedral_die_red_faces_l1982_198218

theorem octahedral_die_red_faces (n : ℕ) (k : ℕ) (opposite_pairs : ℕ) :
  n = 8 →
  k = 2 →
  opposite_pairs = 4 →
  Nat.choose n k - opposite_pairs = 24 :=
by sorry

end octahedral_die_red_faces_l1982_198218


namespace storybook_pages_l1982_198211

/-- The number of days between two dates (inclusive) -/
def daysBetween (startDate endDate : Nat) : Nat :=
  endDate - startDate + 1

theorem storybook_pages : 
  let startDate := 10  -- March 10th
  let endDate := 20    -- March 20th
  let pagesPerDay := 11
  let readingDays := daysBetween startDate endDate
  readingDays * pagesPerDay = 121 := by
  sorry

end storybook_pages_l1982_198211


namespace greatest_average_speed_l1982_198215

/-- Checks if a number is a palindrome -/
def is_palindrome (n : ℕ) : Prop := sorry

/-- Finds the greatest palindrome less than or equal to a given number -/
def greatest_palindrome_le (n : ℕ) : ℕ := sorry

theorem greatest_average_speed (initial_reading : ℕ) (trip_duration : ℕ) (max_speed : ℕ) :
  is_palindrome initial_reading →
  initial_reading = 13831 →
  trip_duration = 5 →
  max_speed = 80 →
  let max_distance := max_speed * trip_duration
  let max_final_reading := initial_reading + max_distance
  let actual_final_reading := greatest_palindrome_le max_final_reading
  let distance_traveled := actual_final_reading - initial_reading
  let average_speed := distance_traveled / trip_duration
  average_speed = 62 := by sorry

end greatest_average_speed_l1982_198215


namespace function_properties_l1982_198273

noncomputable def f (a x : ℝ) : ℝ := a * x^2 - (a + 2) * x + Real.log x

theorem function_properties (a : ℝ) :
  (∀ x : ℝ, x > 0 → f a x = a * x^2 - (a + 2) * x + Real.log x) →
  (a = 1 → ∀ x : ℝ, x > 0 → (f 1 x - f 1 1) = 0 * (x - 1)) ∧
  (a > 0 → (∀ x : ℝ, 1 ≤ x → x ≤ Real.exp 1 → f a x ≥ -2) → (∀ x : ℝ, 1 ≤ x → x ≤ Real.exp 1 → f a x = -2) → a ≥ 1) ∧
  ((∀ x₁ x₂ : ℝ, x₁ > 0 → x₂ > 0 → x₁ ≠ x₂ → (f a x₁ + 2 * x₁ - (f a x₂ + 2 * x₂)) / (x₁ - x₂) > 0) → 0 ≤ a ∧ a ≤ 8) :=
by sorry

end function_properties_l1982_198273


namespace min_value_A_min_value_A_equality_l1982_198248

theorem min_value_A (x y z : ℝ) (hx : x ≥ 1) (hy : y ≥ 1) (hz : z ≥ 1) :
  let A := (Real.sqrt (3 * x^4 + y) + Real.sqrt (3 * y^4 + z) + Real.sqrt (3 * z^4 + x) - 3) / (x * y + y * z + z * x)
  A ≥ 1 := by
  sorry

theorem min_value_A_equality (x y z : ℝ) (hx : x ≥ 1) (hy : y ≥ 1) (hz : z ≥ 1) :
  let A := (Real.sqrt (3 * x^4 + y) + Real.sqrt (3 * y^4 + z) + Real.sqrt (3 * z^4 + x) - 3) / (x * y + y * z + z * x)
  (A = 1) ↔ (x = 1 ∧ y = 1 ∧ z = 1) := by
  sorry

end min_value_A_min_value_A_equality_l1982_198248


namespace remainder_6_pow_23_mod_5_l1982_198202

theorem remainder_6_pow_23_mod_5 : 6^23 % 5 = 1 := by
  sorry

end remainder_6_pow_23_mod_5_l1982_198202


namespace current_speed_l1982_198238

/-- Given a man's speed with and against a current, calculate the speed of the current. -/
theorem current_speed (speed_with_current speed_against_current : ℝ) 
  (h1 : speed_with_current = 20)
  (h2 : speed_against_current = 14) :
  ∃ (current_speed : ℝ), current_speed = 3 ∧ 
    speed_with_current = speed_against_current + 2 * current_speed :=
by sorry

end current_speed_l1982_198238


namespace second_particle_catches_up_l1982_198212

/-- The time (in minutes) when the second particle enters the pipe after the first -/
def time_difference : ℝ := 6.8

/-- The constant speed of the first particle in meters per minute -/
def speed_first : ℝ := 5

/-- The initial speed of the second particle in meters per minute -/
def initial_speed_second : ℝ := 3

/-- The acceleration of the second particle in meters per minute² -/
def acceleration_second : ℝ := 0.5

/-- The distance traveled by the first particle after time t -/
def distance_first (t : ℝ) : ℝ :=
  speed_first * (time_difference + t)

/-- The distance traveled by the second particle after time t -/
def distance_second (t : ℝ) : ℝ :=
  0.25 * t^2 + 2.75 * t

/-- The time when the second particle catches up with the first -/
def catch_up_time : ℝ := 17

theorem second_particle_catches_up :
  distance_first catch_up_time = distance_second catch_up_time :=
by sorry

end second_particle_catches_up_l1982_198212


namespace triangle_ratio_proof_l1982_198291

theorem triangle_ratio_proof (A B C : ℝ) (a b c : ℝ) :
  0 < A ∧ 0 < B ∧ 0 < C ∧
  A + B + C = π ∧
  A = π / 3 ∧
  b = 1 ∧
  (1 / 2) * b * c * Real.sin A = Real.sqrt 3 →
  (a + 2 * b - 3 * c) / (Real.sin A + 2 * Real.sin B - 3 * Real.sin C) = 2 * Real.sqrt 39 / 3 :=
by sorry

end triangle_ratio_proof_l1982_198291


namespace equation_solution_l1982_198259

theorem equation_solution (k : ℝ) : 
  ((-2 : ℝ)^2 + 4*k*(-2) + 2*k^2 = 4) → (k = 0 ∨ k = 4) := by
  sorry

end equation_solution_l1982_198259


namespace comparison_of_expressions_l1982_198269

theorem comparison_of_expressions (a b : ℝ) (ha : a > 0) (hb : b > 0) (hab : a ≠ b) :
  (∃ a b, (a + 1/a) * (b + 1/b) > (Real.sqrt (a*b) + 1/Real.sqrt (a*b))^2) ∧
  (∃ a b, (a + 1/a) * (b + 1/b) > ((a+b)/2 + 2/(a+b))^2) ∧
  (∃ a b, ((a+b)/2 + 2/(a+b))^2 > (a + 1/a) * (b + 1/b)) :=
by sorry

end comparison_of_expressions_l1982_198269


namespace inequality_proof_l1982_198257

theorem inequality_proof (a b c : ℝ) 
  (ha : a = 2 * Real.sqrt 2 - 2) 
  (hb : b = Real.exp 2 / 7) 
  (hc : c = Real.log 2) : 
  b > a ∧ a > c := by
  sorry

end inequality_proof_l1982_198257


namespace slope_angle_range_l1982_198200

-- Define Circle C
def CircleC (x y : ℝ) : Prop := x^2 + (y - 1)^2 = 4

-- Define Line l
def LineL (k : ℝ) (x y : ℝ) : Prop := y = k * x + 2

-- Define the condition that O is inside circle with diameter AB
def OInsideAB (k : ℝ) : Prop := 4 * (k^2 + 1) > 4 * k^2 + 3

-- Main theorem
theorem slope_angle_range :
  ∀ k : ℝ,
  (∃ x y : ℝ, CircleC x y ∧ LineL k x y) →  -- Line l intersects Circle C
  OInsideAB k →                            -- O is inside circle with diameter AB
  Real.arctan (1/2) < Real.arctan k ∧ Real.arctan k < π - Real.arctan (1/2) :=
by sorry

end slope_angle_range_l1982_198200


namespace expansion_coefficients_l1982_198250

theorem expansion_coefficients (a₀ a₁ a₂ a₃ a₄ a₅ a₆ a₇ : ℝ) : 
  (∀ x : ℝ, (x + 1)^7 = a₀ + a₁*x + a₂*x^2 + a₃*x^3 + a₄*x^4 + a₅*x^5 + a₆*x^6 + a₇*x^7) →
  (a₁ = 7 ∧ a₁ + a₂ + a₃ + a₄ + a₅ + a₆ + a₇ = 127) := by
sorry

end expansion_coefficients_l1982_198250


namespace cuboid_area_example_l1982_198216

/-- The surface area of a cuboid with given dimensions -/
def cuboid_surface_area (length breadth height : ℝ) : ℝ :=
  2 * (length * breadth + breadth * height + length * height)

/-- Theorem: The surface area of a cuboid with length 8 cm, breadth 6 cm, and height 9 cm is 348 cm² -/
theorem cuboid_area_example : cuboid_surface_area 8 6 9 = 348 := by
  sorry

end cuboid_area_example_l1982_198216


namespace combined_exterior_angles_pentagon_hexagon_l1982_198227

-- Define the sum of exterior angles for any convex polygon
def sum_exterior_angles (n : ℕ) : ℝ := 360

-- Define a pentagon
def pentagon : ℕ := 5

-- Define a hexagon
def hexagon : ℕ := 6

-- Theorem statement
theorem combined_exterior_angles_pentagon_hexagon :
  sum_exterior_angles pentagon + sum_exterior_angles hexagon = 720 := by
  sorry

end combined_exterior_angles_pentagon_hexagon_l1982_198227


namespace certain_number_is_three_l1982_198286

theorem certain_number_is_three :
  ∀ certain_number : ℕ,
  (2^14 : ℕ) - (2^12 : ℕ) = certain_number * (2^12 : ℕ) →
  certain_number = 3 := by
sorry

end certain_number_is_three_l1982_198286


namespace students_on_field_trip_l1982_198261

/-- The number of seats on each school bus -/
def seats_per_bus : ℕ := 10

/-- The number of buses needed for the trip -/
def number_of_buses : ℕ := 6

/-- Theorem stating the number of students going on the field trip -/
theorem students_on_field_trip : seats_per_bus * number_of_buses = 60 := by
  sorry

end students_on_field_trip_l1982_198261


namespace intersection_condition_l1982_198266

open Set Real

def A : Set ℝ := {x | (x - 1) / (x + 1) < 0}
def B (b : ℝ) : Set ℝ := {x | (x - b)^2 < 1}

theorem intersection_condition (b : ℝ) : A ∩ B b ≠ ∅ ↔ -2 < b ∧ b < 2 := by
  sorry

end intersection_condition_l1982_198266


namespace common_difference_of_arithmetic_sequence_l1982_198241

def arithmetic_sequence (a : ℕ → ℝ) := ∃ d : ℝ, ∀ n : ℕ, a (n + 1) = a n + d

theorem common_difference_of_arithmetic_sequence (a : ℕ → ℝ) (h : arithmetic_sequence a) 
  (h2 : a 2 = 9) (h5 : a 5 = 33) : 
  ∃ d : ℝ, d = 8 ∧ ∀ n : ℕ, a (n + 1) = a n + d :=
by
  sorry

end common_difference_of_arithmetic_sequence_l1982_198241


namespace six_customOp_three_l1982_198220

/-- Definition of the custom operation " -/
def customOp (m n : ℕ) : ℕ := n ^ 2 - m

/-- Theorem stating that 6 " 3 = 3 -/
theorem six_customOp_three : customOp 6 3 = 3 := by
  sorry

end six_customOp_three_l1982_198220


namespace south_movement_l1982_198289

-- Define a type for direction
inductive Direction
  | North
  | South

-- Define a function to represent movement
def movement (d : Direction) (distance : ℝ) : ℝ :=
  match d with
  | Direction.North => distance
  | Direction.South => -distance

-- Theorem statement
theorem south_movement :
  movement Direction.North 8 = 8 →
  movement Direction.South 5 = -5 :=
by
  sorry

end south_movement_l1982_198289


namespace rectangle_area_l1982_198223

/-- A rectangle with length thrice its breadth and perimeter 88 meters has an area of 363 square meters. -/
theorem rectangle_area (b : ℝ) (h1 : b > 0) : 
  let l := 3 * b
  let perimeter := 2 * (l + b)
  perimeter = 88 → l * b = 363 := by
  sorry

end rectangle_area_l1982_198223


namespace unique_gcd_triplet_l1982_198297

theorem unique_gcd_triplet :
  ∃! (x y z : ℕ),
    (∃ (a b c : ℕ), x = Nat.gcd a b ∧ y = Nat.gcd b c ∧ z = Nat.gcd c a) ∧
    x ∈ ({6, 8, 12, 18, 24} : Set ℕ) ∧
    y ∈ ({14, 20, 28, 44, 56} : Set ℕ) ∧
    z ∈ ({5, 15, 18, 27, 42} : Set ℕ) ∧
    x = 8 ∧ y = 14 ∧ z = 18 := by
  sorry

end unique_gcd_triplet_l1982_198297


namespace rectangle_area_y_l1982_198290

theorem rectangle_area_y (y : ℝ) : y > 0 →
  let E : ℝ × ℝ := (0, 0)
  let F : ℝ × ℝ := (0, 6)
  let G : ℝ × ℝ := (y, 6)
  let H : ℝ × ℝ := (y, 0)
  let area := (G.1 - E.1) * (F.2 - E.2)
  area = 42 →
  y = 7 := by sorry

end rectangle_area_y_l1982_198290


namespace max_value_fraction_l1982_198253

theorem max_value_fraction (a b c : ℝ) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hbc : b + c ≤ a) :
  ∃ (max : ℝ), max = 1/8 ∧ ∀ x, x = b * c / (a^2 + 2*a*b + b^2) → x ≤ max :=
sorry

end max_value_fraction_l1982_198253


namespace egg_laying_hens_l1982_198285

theorem egg_laying_hens (total_chickens roosters non_laying_hens : ℕ) 
  (h1 : total_chickens = 325)
  (h2 : roosters = 28)
  (h3 : non_laying_hens = 20) :
  total_chickens - roosters - non_laying_hens = 277 := by
  sorry

#check egg_laying_hens

end egg_laying_hens_l1982_198285


namespace product_of_roots_l1982_198278

theorem product_of_roots (x : ℝ) : 
  (∃ r₁ r₂ r₃ r₄ : ℝ, x^4 - 12*x^3 + 50*x^2 + 48*x - 35 = (x - r₁) * (x - r₂) * (x - r₃) * (x - r₄)) →
  (∃ r₁ r₂ r₃ r₄ : ℝ, x^4 - 12*x^3 + 50*x^2 + 48*x - 35 = (x - r₁) * (x - r₂) * (x - r₃) * (x - r₄) ∧
                       r₁ * r₂ * r₃ * r₄ = 35) :=
by sorry

end product_of_roots_l1982_198278


namespace square_area_error_l1982_198258

theorem square_area_error (x : ℝ) (h : x > 0) :
  let measured_side := x * (1 + 0.17)
  let actual_area := x^2
  let calculated_area := measured_side^2
  let area_error := (calculated_area - actual_area) / actual_area
  area_error = 0.3689 := by
sorry

end square_area_error_l1982_198258


namespace snow_cone_stand_problem_l1982_198206

/-- Represents the snow-cone stand financial problem --/
theorem snow_cone_stand_problem 
  (borrowed : ℝ)  -- Amount borrowed from brother
  (repay : ℝ)     -- Amount to repay brother
  (ingredients : ℝ) -- Cost of ingredients
  (sold : ℕ)      -- Number of snow cones sold
  (price : ℝ)     -- Price per snow cone
  (remaining : ℝ) -- Amount remaining after repayment
  (h1 : repay = 110)
  (h2 : ingredients = 75)
  (h3 : sold = 200)
  (h4 : price = 0.75)
  (h5 : remaining = 65)
  (h6 : sold * price = borrowed + remaining - ingredients) :
  borrowed = 250 := by
  sorry

end snow_cone_stand_problem_l1982_198206


namespace equality_of_powers_l1982_198284

theorem equality_of_powers (a b c d e f : ℕ+) 
  (h1 : 20^21 = 2^(a:ℕ) * 5^(b:ℕ))
  (h2 : 20^21 = 4^(c:ℕ) * 5^(d:ℕ))
  (h3 : 20^21 = 8^(e:ℕ) * 5^(f:ℕ)) :
  100 * (b:ℕ) * (d:ℕ) * (f:ℕ) / ((a:ℕ) * (c:ℕ) * (e:ℕ)) = 75 := by
  sorry

end equality_of_powers_l1982_198284


namespace parabola_ellipse_intersection_l1982_198281

/-- Represents a parabola with equation y² = -4x -/
structure Parabola where
  equation : ∀ x y, y^2 = -4*x

/-- Represents an ellipse with equation x²/4 + y²/b² = 1, where b > 0 -/
structure Ellipse where
  b : ℝ
  b_pos : b > 0
  equation : ∀ x y, x^2/4 + y^2/b^2 = 1

/-- The x-coordinate of the latus rectum for a parabola y² = -4x -/
def latus_rectum_x (p : Parabola) : ℝ := 1

/-- The x-coordinate of the focus for an ellipse x²/4 + y²/b² = 1 -/
def focus_x (e : Ellipse) : ℝ := 1

/-- Theorem stating that if the latus rectum of the parabola passes through
    the focus of the ellipse, then b = √3 -/
theorem parabola_ellipse_intersection
  (p : Parabola) (e : Ellipse)
  (h : latus_rectum_x p = focus_x e) :
  e.b = Real.sqrt 3 := by sorry

end parabola_ellipse_intersection_l1982_198281


namespace train_length_l1982_198252

/-- Calculates the length of a train given its speed and the time and distance it takes to cross a bridge -/
theorem train_length (train_speed : ℝ) (bridge_length : ℝ) (crossing_time : ℝ) : 
  train_speed = 57.6 * (1000 / 3600) →
  bridge_length = 150 →
  crossing_time = 25 →
  (train_speed * crossing_time) - bridge_length = 250 := by
sorry

end train_length_l1982_198252


namespace journey_rate_problem_l1982_198260

/-- Proves that given a 640-mile journey split into two equal halves, 
    where the second half takes 200% longer than the first half, 
    and the average rate for the entire trip is 40 miles per hour, 
    the average rate for the first half of the trip is 80 miles per hour. -/
theorem journey_rate_problem (total_distance : ℝ) (first_half_rate : ℝ) :
  total_distance = 640 →
  (total_distance / 2) / first_half_rate + 3 * ((total_distance / 2) / first_half_rate) = total_distance / 40 →
  first_half_rate = 80 := by
  sorry

end journey_rate_problem_l1982_198260
