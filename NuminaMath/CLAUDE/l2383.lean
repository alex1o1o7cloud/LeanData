import Mathlib

namespace NUMINAMATH_CALUDE_sum_of_digits_0_to_99_l2383_238398

/-- Sum of digits of a natural number -/
def sumOfDigits (n : ℕ) : ℕ := sorry

/-- Sum of digits for a range of natural numbers -/
def sumOfDigitsRange (a b : ℕ) : ℕ := 
  (Finset.range (b - a + 1)).sum (fun i => sumOfDigits (a + i))

theorem sum_of_digits_0_to_99 :
  sumOfDigitsRange 0 99 = 900 :=
by
  sorry

/-- Given condition -/
axiom sum_of_digits_18_to_21 : sumOfDigitsRange 18 21 = 24

#check sum_of_digits_0_to_99
#check sum_of_digits_18_to_21

end NUMINAMATH_CALUDE_sum_of_digits_0_to_99_l2383_238398


namespace NUMINAMATH_CALUDE_angle_sum_around_point_l2383_238366

theorem angle_sum_around_point (y : ℝ) : 
  y + y + 140 = 360 → y = 110 := by sorry

end NUMINAMATH_CALUDE_angle_sum_around_point_l2383_238366


namespace NUMINAMATH_CALUDE_xy_power_2023_l2383_238334

theorem xy_power_2023 (x y : ℝ) (h : |x + 1| + Real.sqrt (y - 1) = 0) : 
  (x * y) ^ 2023 = -1 := by
  sorry

end NUMINAMATH_CALUDE_xy_power_2023_l2383_238334


namespace NUMINAMATH_CALUDE_quadratic_equation_condition_l2383_238365

theorem quadratic_equation_condition (m : ℝ) : 
  (∀ x, (m - 1) * x^2 + 3 * x - 1 = 0 → (m - 1) ≠ 0) → m ≠ 1 :=
by sorry

end NUMINAMATH_CALUDE_quadratic_equation_condition_l2383_238365


namespace NUMINAMATH_CALUDE_largest_three_digit_congruence_l2383_238361

theorem largest_three_digit_congruence :
  ∃ m : ℕ,
    100 ≤ m ∧ m ≤ 999 ∧
    40 * m ≡ 120 [MOD 200] ∧
    ∀ n : ℕ, 100 ≤ n ∧ n ≤ 999 ∧ 40 * n ≡ 120 [MOD 200] → n ≤ m ∧
    m = 998 :=
by sorry

end NUMINAMATH_CALUDE_largest_three_digit_congruence_l2383_238361


namespace NUMINAMATH_CALUDE_bruce_purchase_l2383_238332

/-- The total amount Bruce paid to the shopkeeper for grapes and mangoes -/
def total_amount (grape_qty : ℕ) (grape_rate : ℕ) (mango_qty : ℕ) (mango_rate : ℕ) : ℕ :=
  grape_qty * grape_rate + mango_qty * mango_rate

/-- Theorem stating that Bruce paid 1110 for his purchase -/
theorem bruce_purchase : total_amount 8 70 10 55 = 1110 := by
  sorry

end NUMINAMATH_CALUDE_bruce_purchase_l2383_238332


namespace NUMINAMATH_CALUDE_evaluate_expression_l2383_238372

theorem evaluate_expression : (-3)^6 / 3^4 + 2^5 - 7^2 = -8 := by
  sorry

end NUMINAMATH_CALUDE_evaluate_expression_l2383_238372


namespace NUMINAMATH_CALUDE_second_throw_difference_l2383_238373

/-- Represents the number of skips for each throw -/
structure Throws :=
  (first : ℕ)
  (second : ℕ)
  (third : ℕ)
  (fourth : ℕ)
  (fifth : ℕ)

/-- Conditions for the stone skipping problem -/
def StoneSkippingProblem (t : Throws) : Prop :=
  t.third = 2 * t.second ∧
  t.fourth = t.third - 3 ∧
  t.fifth = t.fourth + 1 ∧
  t.fifth = 8 ∧
  t.first + t.second + t.third + t.fourth + t.fifth = 33

theorem second_throw_difference (t : Throws) 
  (h : StoneSkippingProblem t) : t.second - t.first = 2 := by
  sorry

end NUMINAMATH_CALUDE_second_throw_difference_l2383_238373


namespace NUMINAMATH_CALUDE_no_odd_integer_solution_l2383_238392

theorem no_odd_integer_solution (n : ℕ+) (x y z : ℤ) 
  (hx : Odd x) (hy : Odd y) (hz : Odd z) : 
  (x + y)^n.val + (y + z)^n.val ≠ (x + z)^n.val := by
  sorry

end NUMINAMATH_CALUDE_no_odd_integer_solution_l2383_238392


namespace NUMINAMATH_CALUDE_smallest_lcm_four_digit_gcd_five_l2383_238359

theorem smallest_lcm_four_digit_gcd_five (k l : ℕ) : 
  1000 ≤ k ∧ k < 10000 ∧ 
  1000 ≤ l ∧ l < 10000 ∧ 
  Nat.gcd k l = 5 →
  201000 ≤ Nat.lcm k l ∧ 
  ∃ (k₀ l₀ : ℕ), 1000 ≤ k₀ ∧ k₀ < 10000 ∧ 
                 1000 ≤ l₀ ∧ l₀ < 10000 ∧ 
                 Nat.gcd k₀ l₀ = 5 ∧
                 Nat.lcm k₀ l₀ = 201000 :=
by sorry

end NUMINAMATH_CALUDE_smallest_lcm_four_digit_gcd_five_l2383_238359


namespace NUMINAMATH_CALUDE_some_number_value_l2383_238349

theorem some_number_value (a n : ℕ) (h1 : a = 105) (h2 : a^3 = n * 25 * 315 * 7) : n = 63 := by
  sorry

end NUMINAMATH_CALUDE_some_number_value_l2383_238349


namespace NUMINAMATH_CALUDE_total_airflow_theorem_l2383_238385

/-- Represents a fan with its airflow rate, operation time, and days of operation -/
structure Fan where
  airflow_rate : ℝ  -- Liters per second
  operation_time : ℝ  -- Minutes per day
  days_of_operation : ℕ

/-- Calculates the total airflow for a fan in one week -/
def fan_airflow (f : Fan) : ℝ :=
  f.airflow_rate * f.operation_time * 60 * f.days_of_operation

/-- The five fans in the room -/
def fan_A : Fan := ⟨10, 10, 7⟩
def fan_B : Fan := ⟨15, 20, 5⟩
def fan_C : Fan := ⟨25, 30, 5⟩
def fan_D : Fan := ⟨20, 15, 2⟩
def fan_E : Fan := ⟨30, 60, 6⟩

/-- Theorem: The total airflow generated by all five fans in one week is 1,041,000 liters -/
theorem total_airflow_theorem :
  fan_airflow fan_A + fan_airflow fan_B + fan_airflow fan_C +
  fan_airflow fan_D + fan_airflow fan_E = 1041000 := by
  sorry

end NUMINAMATH_CALUDE_total_airflow_theorem_l2383_238385


namespace NUMINAMATH_CALUDE_min_value_fraction_equality_condition_l2383_238331

theorem min_value_fraction (x : ℝ) : (x^2 + 8) / Real.sqrt (x^2 + 4) ≥ 4 := by
  sorry

theorem equality_condition : ∃ x : ℝ, (x^2 + 8) / Real.sqrt (x^2 + 4) = 4 := by
  sorry

end NUMINAMATH_CALUDE_min_value_fraction_equality_condition_l2383_238331


namespace NUMINAMATH_CALUDE_stratified_sample_size_l2383_238308

/-- Represents the structure of a company's workforce -/
structure Company where
  staff : ℕ
  middle_managers : ℕ
  senior_managers : ℕ

/-- Calculates the total number of employees in the company -/
def Company.total (c : Company) : ℕ := c.staff + c.middle_managers + c.senior_managers

/-- Represents a stratified sampling scenario -/
structure StratifiedSample where
  company : Company
  sample_size : ℕ
  selected_senior_managers : ℕ

/-- Theorem stating the correct sample size for the given conditions -/
theorem stratified_sample_size
  (c : Company)
  (sample : StratifiedSample)
  (h1 : c.staff = 160)
  (h2 : c.middle_managers = 30)
  (h3 : c.senior_managers = 10)
  (h4 : sample.company = c)
  (h5 : sample.selected_senior_managers = 1) :
  sample.sample_size = 20 := by
  sorry


end NUMINAMATH_CALUDE_stratified_sample_size_l2383_238308


namespace NUMINAMATH_CALUDE_unique_circle_digits_l2383_238351

theorem unique_circle_digits : ∃! (a b c d e : ℕ),
  (a ≠ 0 ∧ b ≠ 0 ∧ c ≠ 0 ∧ d ≠ 0 ∧ e ≠ 0) ∧
  (a < 10 ∧ b < 10 ∧ c < 10 ∧ d < 10 ∧ e < 10) ∧
  (a ≠ b ∧ a ≠ c ∧ a ≠ d ∧ a ≠ e ∧ b ≠ c ∧ b ≠ d ∧ b ≠ e ∧ c ≠ d ∧ c ≠ e ∧ d ≠ e) ∧
  (a + b = (c + d + e) / 7) ∧
  (a + c = (b + d + e) / 5) :=
by sorry

end NUMINAMATH_CALUDE_unique_circle_digits_l2383_238351


namespace NUMINAMATH_CALUDE_total_tickets_sold_l2383_238391

/-- Proves that the total number of tickets sold is 350 --/
theorem total_tickets_sold (orchestra_price balcony_price : ℕ)
  (total_cost : ℕ) (balcony_excess : ℕ) :
  orchestra_price = 12 →
  balcony_price = 8 →
  total_cost = 3320 →
  balcony_excess = 90 →
  ∃ (orchestra_tickets balcony_tickets : ℕ),
    orchestra_tickets * orchestra_price + balcony_tickets * balcony_price = total_cost ∧
    balcony_tickets = orchestra_tickets + balcony_excess ∧
    orchestra_tickets + balcony_tickets = 350 :=
by sorry

end NUMINAMATH_CALUDE_total_tickets_sold_l2383_238391


namespace NUMINAMATH_CALUDE_average_marks_l2383_238345

theorem average_marks (total_subjects : Nat) (subjects_avg_5 : Nat) (subject_6_mark : Nat) :
  total_subjects = 6 →
  subjects_avg_5 = 74 →
  subject_6_mark = 92 →
  ((subjects_avg_5 * 5 + subject_6_mark) : ℚ) / total_subjects = 77 := by
  sorry

end NUMINAMATH_CALUDE_average_marks_l2383_238345


namespace NUMINAMATH_CALUDE_yankees_to_mets_ratio_l2383_238387

/-- Represents the number of fans for each team -/
structure FanCounts where
  yankees : ℕ
  mets : ℕ
  red_sox : ℕ

/-- The total number of baseball fans in the town -/
def total_fans : ℕ := 330

/-- The given number of NY Mets fans -/
def mets_fans : ℕ := 88

/-- Theorem stating that the ratio of NY Yankees fans to NY Mets fans is 3:2 -/
theorem yankees_to_mets_ratio (fc : FanCounts) : 
  fc.yankees = fc.mets * 3 / 2 ∧ 
  fc.mets = mets_fans ∧ 
  fc.red_sox = fc.mets * 5 / 4 ∧ 
  fc.yankees + fc.mets + fc.red_sox = total_fans :=
by sorry

end NUMINAMATH_CALUDE_yankees_to_mets_ratio_l2383_238387


namespace NUMINAMATH_CALUDE_samsung_start_is_15_l2383_238309

/-- The number of Samsung cell phones left at the end of the day -/
def samsung_end : ℕ := 10

/-- The number of iPhones left at the end of the day -/
def iphone_end : ℕ := 5

/-- The number of damaged Samsung cell phones thrown out during the day -/
def samsung_thrown : ℕ := 2

/-- The number of defective iPhones thrown out during the day -/
def iphone_thrown : ℕ := 1

/-- The total number of cell phones sold today -/
def total_sold : ℕ := 4

/-- The number of Samsung cell phones David started the day with -/
def samsung_start : ℕ := samsung_end + samsung_thrown + (total_sold - iphone_thrown)

theorem samsung_start_is_15 : samsung_start = 15 := by
  sorry

end NUMINAMATH_CALUDE_samsung_start_is_15_l2383_238309


namespace NUMINAMATH_CALUDE_classroom_composition_l2383_238319

/-- In a class, each boy is friends with exactly two girls, and each girl is friends with exactly three boys. -/
structure Classroom where
  boys : ℕ
  girls : ℕ
  total_students : boys + girls = 31
  boy_girl_connections : 2 * boys = 3 * girls

/-- The number of boys and girls in the classroom satisfies the given conditions. -/
theorem classroom_composition : ∃ (c : Classroom), c.boys = 19 ∧ c.girls = 12 := by
  sorry

end NUMINAMATH_CALUDE_classroom_composition_l2383_238319


namespace NUMINAMATH_CALUDE_angle_b_is_30_degrees_l2383_238381

-- Define the structure of our triangle
structure Triangle :=
  (A B C : ℝ)  -- Angles of the triangle
  (white_angle gray_angle : ℝ)  -- Measures of white and gray angles
  (b : ℝ)  -- The angle we want to determine

-- State the theorem
theorem angle_b_is_30_degrees (t : Triangle) : 
  t.A = 60 ∧  -- Given angle is 60°
  t.A + t.B + t.C = 180 ∧  -- Sum of angles in a triangle is 180°
  t.A + 2 * t.gray_angle + (180 - 2 * t.white_angle) = 180 ∧  -- Equation for triangle ABC
  t.gray_angle + t.b + (180 - 2 * t.white_angle) = 180  -- Equation for triangle BCD
  → t.b = 30 := by
sorry  -- Proof is omitted as per instructions

end NUMINAMATH_CALUDE_angle_b_is_30_degrees_l2383_238381


namespace NUMINAMATH_CALUDE_integer_roots_of_polynomial_l2383_238327

def polynomial (a₂ a₁ : ℤ) (x : ℤ) : ℤ := x^3 + a₂*x^2 + a₁*x - 11

theorem integer_roots_of_polynomial (a₂ a₁ : ℤ) :
  {x : ℤ | polynomial a₂ a₁ x = 0} ⊆ {-11, -1, 1, 11} :=
by sorry

end NUMINAMATH_CALUDE_integer_roots_of_polynomial_l2383_238327


namespace NUMINAMATH_CALUDE_zeros_of_specific_f_graph_above_line_implies_b_gt_2_solution_set_when_b_eq_2_l2383_238377

-- Define the function f(x)
def f (a b x : ℝ) : ℝ := a * x^2 + (2*a + 1) * x + b

-- Statement 1
theorem zeros_of_specific_f :
  ∃ (x₁ x₂ : ℝ), x₁ = -4 ∧ x₂ = 1 ∧
  ∀ (x : ℝ), f 1 (-4) x = 0 ↔ (x = x₁ ∨ x = x₂) :=
sorry

-- Statement 2
theorem graph_above_line_implies_b_gt_2 (a b : ℝ) :
  (∀ x : ℝ, f a b x > x + 2) → b > 2 :=
sorry

-- Statement 3
theorem solution_set_when_b_eq_2 (a : ℝ) :
  let S := {x : ℝ | f a 2 x < 0}
  if a < 0 then
    S = {x : ℝ | x < -2 ∨ x > -1/a}
  else if a = 0 then
    S = {x : ℝ | x < -2}
  else if 0 < a ∧ a < 1/2 then
    S = {x : ℝ | -1/a < x ∧ x < -2}
  else if a = 1/2 then
    S = ∅
  else -- a > 1/2
    S = {x : ℝ | -2 < x ∧ x < -1/a} :=
sorry

end NUMINAMATH_CALUDE_zeros_of_specific_f_graph_above_line_implies_b_gt_2_solution_set_when_b_eq_2_l2383_238377


namespace NUMINAMATH_CALUDE_cookie_difference_l2383_238304

/-- Proves that the difference between the number of cookies in 8 boxes and 9 bags is 33,
    given that each bag contains 7 cookies and each box contains 12 cookies. -/
theorem cookie_difference :
  let cookies_per_bag : ℕ := 7
  let cookies_per_box : ℕ := 12
  let num_boxes : ℕ := 8
  let num_bags : ℕ := 9
  (num_boxes * cookies_per_box) - (num_bags * cookies_per_bag) = 33 := by
  sorry

end NUMINAMATH_CALUDE_cookie_difference_l2383_238304


namespace NUMINAMATH_CALUDE_intersection_equals_N_l2383_238390

def M : Set ℝ := {x | x ≤ 1}
def N : Set ℝ := {x | 0 ≤ x ∧ x ≤ 1}

theorem intersection_equals_N : M ∩ N = N := by sorry

end NUMINAMATH_CALUDE_intersection_equals_N_l2383_238390


namespace NUMINAMATH_CALUDE_number_of_possible_orders_l2383_238393

/-- The number of documents --/
def n : ℕ := 10

/-- The number of documents before the confirmed reviewed document --/
def m : ℕ := 8

/-- Calculates the number of possible orders for the remaining documents --/
def possibleOrders : ℕ := 
  Finset.sum (Finset.range (m + 1)) (fun k => (Nat.choose m k) * (k + 2))

/-- Theorem stating the number of possible orders --/
theorem number_of_possible_orders : possibleOrders = 1440 := by
  sorry

end NUMINAMATH_CALUDE_number_of_possible_orders_l2383_238393


namespace NUMINAMATH_CALUDE_banana_permutations_count_l2383_238336

/-- The number of distinct permutations of the letters in "BANANA" -/
def banana_permutations : ℕ := 60

/-- The total number of letters in "BANANA" -/
def total_letters : ℕ := 6

/-- The number of times 'A' appears in "BANANA" -/
def count_A : ℕ := 3

/-- The number of times 'N' appears in "BANANA" -/
def count_N : ℕ := 2

/-- Theorem stating that the number of distinct permutations of the letters in "BANANA" is 60 -/
theorem banana_permutations_count : 
  banana_permutations = (Nat.factorial total_letters) / ((Nat.factorial count_A) * (Nat.factorial count_N)) :=
by sorry

end NUMINAMATH_CALUDE_banana_permutations_count_l2383_238336


namespace NUMINAMATH_CALUDE_derivative_of_f_l2383_238378

noncomputable def f (x : ℝ) : ℝ := (2 * Real.pi * x)^2

theorem derivative_of_f (x : ℝ) : 
  deriv f x = 8 * Real.pi^2 * x := by sorry

end NUMINAMATH_CALUDE_derivative_of_f_l2383_238378


namespace NUMINAMATH_CALUDE_symmetry_implies_a_pow_b_eq_four_l2383_238314

/-- Two points are symmetric with respect to the x-axis if their x-coordinates are equal
    and their y-coordinates are opposite. -/
def symmetric_x_axis (p q : ℝ × ℝ) : Prop :=
  p.1 = q.1 ∧ p.2 = -q.2

theorem symmetry_implies_a_pow_b_eq_four (a b : ℝ) :
  symmetric_x_axis (a + 2, -2) (4, b) → a^b = 4 := by
  sorry

#check symmetry_implies_a_pow_b_eq_four

end NUMINAMATH_CALUDE_symmetry_implies_a_pow_b_eq_four_l2383_238314


namespace NUMINAMATH_CALUDE_gummy_juice_time_proof_l2383_238306

/-- Represents the time in hours since starting to mow the lawn -/
def DrinkTime : ℝ := 1.5

theorem gummy_juice_time_proof :
  let total_time : ℝ := 2.5 -- Total time spent mowing (from 10:00 AM to 12:30 PM)
  let normal_rate : ℝ := 1 / 3 -- Rate of mowing without juice (1/3 of lawn per hour)
  let boosted_rate : ℝ := 1 / 2 -- Rate of mowing with juice (1/2 of lawn per hour)
  let normal_portion : ℝ := DrinkTime * normal_rate -- Portion mowed without juice
  let boosted_portion : ℝ := (total_time - DrinkTime) * boosted_rate -- Portion mowed with juice
  normal_portion + boosted_portion = 1 -- Total lawn mowed equals 1
  ∧ DrinkTime = 1.5 -- Time when Bronquinha drank the juice (1.5 hours after 10:00 AM, which is 11:30 AM)
  := by sorry

#check gummy_juice_time_proof

end NUMINAMATH_CALUDE_gummy_juice_time_proof_l2383_238306


namespace NUMINAMATH_CALUDE_system_solution_l2383_238376

theorem system_solution :
  ∃ (x y : ℝ), 
    (x + 2*y = (7 - x) + (3 - 2*y)) ∧ 
    (x - 3*y = (x + 2) - (y - 2)) ∧ 
    x = 9 ∧ y = -2 := by
  sorry

end NUMINAMATH_CALUDE_system_solution_l2383_238376


namespace NUMINAMATH_CALUDE_simplify_radical_product_l2383_238355

theorem simplify_radical_product (x : ℝ) (h : x > 0) :
  Real.sqrt (48 * x) * Real.sqrt (3 * x) * (81 * x^2)^(1/3) = 36 * x * (3 * x^2)^(1/3) := by
  sorry

end NUMINAMATH_CALUDE_simplify_radical_product_l2383_238355


namespace NUMINAMATH_CALUDE_mathematics_permutations_l2383_238350

def word : String := "MATHEMATICS"

theorem mathematics_permutations :
  let n : ℕ := word.length
  let m_count : ℕ := word.count 'M'
  let a_count : ℕ := word.count 'A'
  let t_count : ℕ := word.count 'T'
  (n = 11 ∧ m_count = 2 ∧ a_count = 2 ∧ t_count = 2) →
  (Nat.factorial n) / (Nat.factorial m_count * Nat.factorial a_count * Nat.factorial t_count) = 4989600 := by
sorry

end NUMINAMATH_CALUDE_mathematics_permutations_l2383_238350


namespace NUMINAMATH_CALUDE_sine_cosine_power_inequality_l2383_238340

theorem sine_cosine_power_inequality (n m : ℕ) (hn : n > 0) (hm : m > 0) (hnm : n > m) :
  ∀ x : ℝ, 0 < x ∧ x < π / 2 →
    2 * |Real.sin x ^ n - Real.cos x ^ n| ≤ 3 * |Real.sin x ^ m - Real.cos x ^ m| :=
by sorry

end NUMINAMATH_CALUDE_sine_cosine_power_inequality_l2383_238340


namespace NUMINAMATH_CALUDE_modulus_of_complex_quotient_l2383_238399

theorem modulus_of_complex_quotient : 
  ∀ (z₁ z₂ : ℂ), 
    z₁ = Complex.mk 0 2 → 
    z₂ = Complex.mk 1 (-1) → 
    Complex.abs (z₁ / z₂) = Real.sqrt 2 := by
sorry

end NUMINAMATH_CALUDE_modulus_of_complex_quotient_l2383_238399


namespace NUMINAMATH_CALUDE_total_monthly_wages_after_new_hires_l2383_238337

/-- Calculate total monthly wages after new hires -/
theorem total_monthly_wages_after_new_hires 
  (initial_employees : ℕ) 
  (hourly_wage : ℕ) 
  (hours_per_day : ℕ) 
  (days_per_week : ℕ) 
  (weeks_per_month : ℕ) 
  (new_employees : ℕ) 
  (h1 : initial_employees = 500)
  (h2 : hourly_wage = 12)
  (h3 : hours_per_day = 10)
  (h4 : days_per_week = 5)
  (h5 : weeks_per_month = 4)
  (h6 : new_employees = 200) : 
  (initial_employees + new_employees) * 
  (hourly_wage * hours_per_day * days_per_week * weeks_per_month) = 1680000 := by
  sorry

#eval 700 * (12 * 10 * 5 * 4)  -- Should output 1680000

end NUMINAMATH_CALUDE_total_monthly_wages_after_new_hires_l2383_238337


namespace NUMINAMATH_CALUDE_inequality_solution_set_l2383_238389

theorem inequality_solution_set (x : ℝ) :
  (1 / (x^2 + 2) > (5/x) + (21/10)) ↔ (-2 < x ∧ x < 0) :=
by sorry

end NUMINAMATH_CALUDE_inequality_solution_set_l2383_238389


namespace NUMINAMATH_CALUDE_liam_nickels_problem_l2383_238301

theorem liam_nickels_problem :
  ∃! n : ℕ, 120 < n ∧ n < 400 ∧
    n % 4 = 2 ∧
    n % 5 = 3 ∧
    n % 6 = 4 ∧
    n = 374 := by
  sorry

end NUMINAMATH_CALUDE_liam_nickels_problem_l2383_238301


namespace NUMINAMATH_CALUDE_card_drawing_probability_l2383_238388

theorem card_drawing_probability : 
  let cards : Finset ℕ := {1, 2, 3, 4, 5}
  let odd_cards : Finset ℕ := {1, 3, 5}
  let even_cards : Finset ℕ := {2, 4}
  let total_cards := cards.card
  let odd_count := odd_cards.card
  let even_count := even_cards.card

  let prob_first_odd := odd_count / total_cards
  let prob_second_even_given_first_odd := even_count / (total_cards - 1)

  prob_second_even_given_first_odd = 1 / 2 :=
by
  sorry

end NUMINAMATH_CALUDE_card_drawing_probability_l2383_238388


namespace NUMINAMATH_CALUDE_ellipse_equation_l2383_238321

/-- The standard equation of an ellipse with given eccentricity and major axis length -/
theorem ellipse_equation (e : ℝ) (major_axis : ℝ) (h_e : e = 1 / 2) (h_major : major_axis = 4) :
  ∃ (a b : ℝ), a > 0 ∧ b > 0 ∧ a > b ∧
  (∀ (x y : ℝ), (x^2 / a^2 + y^2 / b^2 = 1) ↔ (x^2 / 4 + y^2 / 3 = 1)) :=
by sorry

end NUMINAMATH_CALUDE_ellipse_equation_l2383_238321


namespace NUMINAMATH_CALUDE_ten_circles_l2383_238342

/-- The maximum number of intersection points for n circles -/
def max_intersection_points (n : ℕ) : ℕ :=
  if n ≤ 1 then 0 else (n - 1) * n

/-- Given conditions -/
axiom two_circles : max_intersection_points 2 = 2
axiom three_circles : max_intersection_points 3 = 6

/-- Theorem to prove -/
theorem ten_circles : max_intersection_points 10 = 90 := by
  sorry

end NUMINAMATH_CALUDE_ten_circles_l2383_238342


namespace NUMINAMATH_CALUDE_f_monotone_increasing_interval_l2383_238397

-- Define the function f(x) = x^2 + 2x + 3
def f (x : ℝ) : ℝ := x^2 + 2*x + 3

-- State the theorem about the monotonically increasing interval of f
theorem f_monotone_increasing_interval :
  ∃ (a : ℝ), a = -1 ∧
  ∀ (x y : ℝ), x > a → y > x → f y > f x :=
sorry

end NUMINAMATH_CALUDE_f_monotone_increasing_interval_l2383_238397


namespace NUMINAMATH_CALUDE_contrapositive_equivalence_l2383_238374

theorem contrapositive_equivalence :
  (∀ x : ℝ, x^2 < 1 → -1 < x ∧ x < 1) ↔
  (∀ x : ℝ, (x ≥ 1 ∨ x ≤ -1) → x^2 ≥ 1) :=
by sorry

end NUMINAMATH_CALUDE_contrapositive_equivalence_l2383_238374


namespace NUMINAMATH_CALUDE_rate_per_axle_above_two_l2383_238312

/-- The toll formula for a truck crossing a bridge -/
def toll_formula (rate : ℝ) (x : ℕ) : ℝ :=
  3.50 + rate * (x - 2 : ℝ)

/-- The number of axles on the 18-wheel truck -/
def truck_axles : ℕ := 5

/-- The toll for the 18-wheel truck -/
def truck_toll : ℝ := 5

/-- The rate per axle above 2 axles is $0.50 -/
theorem rate_per_axle_above_two (rate : ℝ) :
  toll_formula rate truck_axles = truck_toll →
  rate = 0.50 := by
  sorry

end NUMINAMATH_CALUDE_rate_per_axle_above_two_l2383_238312


namespace NUMINAMATH_CALUDE_fred_onions_l2383_238343

/-- Proves that Fred grew 9 onions given the conditions of the problem -/
theorem fred_onions (sara : ℕ) (sally : ℕ) (fred : ℕ) (total : ℕ)
  (h1 : sara = 4)
  (h2 : sally = 5)
  (h3 : total = 18)
  (h4 : sara + sally + fred = total) :
  fred = 9 := by
  sorry

end NUMINAMATH_CALUDE_fred_onions_l2383_238343


namespace NUMINAMATH_CALUDE_complex_multiplication_example_l2383_238326

theorem complex_multiplication_example :
  let z₁ : ℂ := 2 + 2*I
  let z₂ : ℂ := 1 - 2*I
  z₁ * z₂ = 6 - 2*I :=
by sorry

end NUMINAMATH_CALUDE_complex_multiplication_example_l2383_238326


namespace NUMINAMATH_CALUDE_min_wings_theorem_l2383_238325

/-- Represents the number and cost of birds John bought -/
structure BirdPurchase where
  parrots : Nat
  pigeons : Nat
  canaries : Nat
  total_cost : Nat

/-- Calculates the total number of wings for a given bird purchase -/
def total_wings (purchase : BirdPurchase) : Nat :=
  2 * (purchase.parrots + purchase.pigeons + purchase.canaries)

/-- Checks if the purchase satisfies all conditions -/
def is_valid_purchase (purchase : BirdPurchase) : Prop :=
  purchase.parrots ≥ 1 ∧
  purchase.pigeons ≥ 1 ∧
  purchase.canaries ≥ 1 ∧
  purchase.total_cost = 200 ∧
  purchase.total_cost = 30 * purchase.parrots + 20 * purchase.pigeons + 15 * purchase.canaries

theorem min_wings_theorem :
  ∃ (purchase : BirdPurchase),
    is_valid_purchase purchase ∧
    (∀ (other : BirdPurchase), is_valid_purchase other → total_wings purchase ≤ total_wings other) ∧
    total_wings purchase = 24 := by
  sorry

end NUMINAMATH_CALUDE_min_wings_theorem_l2383_238325


namespace NUMINAMATH_CALUDE_hat_scarf_game_theorem_l2383_238318

/-- Represents the maximum guaranteed points in the hat-scarf game -/
def max_guaranteed_points (n k : ℕ) : ℕ :=
  n / k

theorem hat_scarf_game_theorem :
  (∀ n k : ℕ, max_guaranteed_points n k = n / k) ∧
  (max_guaranteed_points 2 2 = 1) := by
  sorry

#check hat_scarf_game_theorem

end NUMINAMATH_CALUDE_hat_scarf_game_theorem_l2383_238318


namespace NUMINAMATH_CALUDE_partition_sum_property_l2383_238330

theorem partition_sum_property (n : ℕ) (A B C : Finset ℕ) :
  n > 0 →
  A ∪ B ∪ C = Finset.range (3 * n) →
  A ∩ B = ∅ ∧ A ∩ C = ∅ ∧ B ∩ C = ∅ →
  Finset.card A = n ∧ Finset.card B = n ∧ Finset.card C = n →
  ∃ (x y z : ℕ), x ∈ A ∧ y ∈ B ∧ z ∈ C ∧
    (x + y = z ∨ x + z = y ∨ y + z = x) :=
by sorry

end NUMINAMATH_CALUDE_partition_sum_property_l2383_238330


namespace NUMINAMATH_CALUDE_opposite_of_negative_three_l2383_238394

theorem opposite_of_negative_three : -((-3 : ℤ)) = 3 := by sorry

end NUMINAMATH_CALUDE_opposite_of_negative_three_l2383_238394


namespace NUMINAMATH_CALUDE_commute_days_eq_seventeen_l2383_238364

/-- Represents the commute options for a woman over a period of working days. -/
structure CommuteData where
  total_days : ℕ
  morning_bus : ℕ
  afternoon_car : ℕ
  total_car : ℕ

/-- Theorem stating that given the specific commute data, the total number of working days is 17. -/
theorem commute_days_eq_seventeen (data : CommuteData) 
  (h1 : data.morning_bus = 10)
  (h2 : data.afternoon_car = 13)
  (h3 : data.total_car = 11)
  (h4 : data.morning_bus + (data.total_car - data.afternoon_car) = data.total_days)
  : data.total_days = 17 := by
  sorry

#check commute_days_eq_seventeen

end NUMINAMATH_CALUDE_commute_days_eq_seventeen_l2383_238364


namespace NUMINAMATH_CALUDE_prime_cube_plus_one_l2383_238323

theorem prime_cube_plus_one (p : ℕ) (hp : Prime p) :
  (∃ (x y : ℕ), p^x = y^3 + 1) ↔ p = 2 ∨ p = 3 := by
  sorry

end NUMINAMATH_CALUDE_prime_cube_plus_one_l2383_238323


namespace NUMINAMATH_CALUDE_arithmetic_sequence_75th_term_l2383_238346

/-- An arithmetic sequence is a sequence where the difference between
    any two consecutive terms is constant. -/
def is_arithmetic_sequence (a : ℕ → ℝ) : Prop :=
  ∃ d : ℝ, ∀ n : ℕ, a (n + 1) = a n + d

theorem arithmetic_sequence_75th_term
  (a : ℕ → ℝ)
  (h_arith : is_arithmetic_sequence a)
  (h_15 : a 15 = 8)
  (h_60 : a 60 = 20) :
  a 75 = 24 := by
  sorry


end NUMINAMATH_CALUDE_arithmetic_sequence_75th_term_l2383_238346


namespace NUMINAMATH_CALUDE_quadratic_root_bound_l2383_238386

theorem quadratic_root_bound (a b c : ℤ) (h_distinct : ∃ (x y : ℝ), x ≠ y ∧ 0 < x ∧ x < 1 ∧ 0 < y ∧ y < 1 ∧ a * x^2 + b * x + c = 0 ∧ a * y^2 + b * y + c = 0) (h_pos : 0 < a) : 5 ≤ a := by
  sorry

end NUMINAMATH_CALUDE_quadratic_root_bound_l2383_238386


namespace NUMINAMATH_CALUDE_intersection_theorem_l2383_238313

/-- The line equation y = 2√2(x-1) -/
def line (x y : ℝ) : Prop := y = 2 * Real.sqrt 2 * (x - 1)

/-- The parabola equation y² = 4x -/
def parabola (x y : ℝ) : Prop := y^2 = 4 * x

/-- Point M with coordinates (-1, m) -/
def point_M (m : ℝ) : ℝ × ℝ := (-1, m)

/-- Function to calculate the dot product of two 2D vectors -/
def dot_product (v1 v2 : ℝ × ℝ) : ℝ :=
  (v1.1 * v2.1) + (v1.2 * v2.2)

/-- Theorem stating that m = √2/2 given the conditions -/
theorem intersection_theorem (A B : ℝ × ℝ) (m : ℝ) :
  line A.1 A.2 →
  line B.1 B.2 →
  parabola A.1 A.2 →
  parabola B.1 B.2 →
  let M := point_M m
  let MA := (A.1 - M.1, A.2 - M.2)
  let MB := (B.1 - M.1, B.2 - M.2)
  dot_product MA MB = 0 →
  m = Real.sqrt 2 / 2 := by
  sorry

end NUMINAMATH_CALUDE_intersection_theorem_l2383_238313


namespace NUMINAMATH_CALUDE_system_solution_l2383_238357

theorem system_solution :
  let x₁ : ℝ := (35 + Real.sqrt 1321) / 24
  let y₁ : ℝ := (-125 - 7 * Real.sqrt 1321) / 72
  let x₂ : ℝ := (35 - Real.sqrt 1321) / 24
  let y₂ : ℝ := (-125 + 7 * Real.sqrt 1321) / 72
  (7 * x₁ + 3 * y₁ = 5 ∧ 4 * x₁^2 + 5 * y₁ = 9) ∧
  (7 * x₂ + 3 * y₂ = 5 ∧ 4 * x₂^2 + 5 * y₂ = 9) :=
by sorry

end NUMINAMATH_CALUDE_system_solution_l2383_238357


namespace NUMINAMATH_CALUDE_rectangular_field_area_l2383_238382

/-- Calculates the area of a rectangular field given its perimeter and width-to-length ratio --/
theorem rectangular_field_area (perimeter : ℝ) (width_ratio : ℝ) : 
  perimeter = 72 ∧ width_ratio = 1/3 → 
  (perimeter / (2 * (1 + 1/width_ratio))) * (perimeter / (2 * (1 + 1/width_ratio))) / width_ratio = 243 := by
sorry

end NUMINAMATH_CALUDE_rectangular_field_area_l2383_238382


namespace NUMINAMATH_CALUDE_theresa_final_week_hours_l2383_238328

/-- The number of weeks Theresa needs to work -/
def total_weeks : ℕ := 6

/-- The required average number of hours per week -/
def required_average : ℚ := 10

/-- The list of hours worked in the first 5 weeks -/
def hours_worked : List ℚ := [8, 11, 7, 12, 10]

/-- The sum of hours worked in the first 5 weeks -/
def sum_first_five : ℚ := hours_worked.sum

/-- The number of hours Theresa needs to work in the final week -/
def hours_final_week : ℚ := required_average * total_weeks - sum_first_five

theorem theresa_final_week_hours :
  hours_final_week = 12 := by sorry

end NUMINAMATH_CALUDE_theresa_final_week_hours_l2383_238328


namespace NUMINAMATH_CALUDE_frequency_41_to_45_l2383_238370

/-- Represents a school with teachers divided into age groups -/
structure School where
  total_teachers : ℕ
  age_groups : ℕ
  teachers_41_to_45 : ℕ

/-- Calculates the frequency of teachers in a specific age group -/
def frequency (s : School) : ℚ :=
  s.teachers_41_to_45 / s.total_teachers

/-- Theorem stating that the frequency of teachers aged 41-45 is 0.14 -/
theorem frequency_41_to_45 (s : School) 
  (h1 : s.total_teachers = 100) 
  (h2 : s.teachers_41_to_45 = 14) : 
  frequency s = 14/100 := by sorry

end NUMINAMATH_CALUDE_frequency_41_to_45_l2383_238370


namespace NUMINAMATH_CALUDE_layla_score_difference_l2383_238383

/-- Given Layla's score and the total score, calculate the difference between Layla's and Nahima's scores -/
def score_difference (layla_score : ℕ) (total_score : ℕ) : ℕ :=
  layla_score - (total_score - layla_score)

/-- Theorem: Given Layla's score of 70 and a total score of 112, Layla scored 28 more points than Nahima -/
theorem layla_score_difference :
  score_difference 70 112 = 28 := by
  sorry

#eval score_difference 70 112

end NUMINAMATH_CALUDE_layla_score_difference_l2383_238383


namespace NUMINAMATH_CALUDE_profit_percentage_calculation_l2383_238379

theorem profit_percentage_calculation (cost_price selling_price : ℝ) :
  cost_price = 620 →
  selling_price = 775 →
  (selling_price - cost_price) / cost_price * 100 = 25 := by
  sorry

end NUMINAMATH_CALUDE_profit_percentage_calculation_l2383_238379


namespace NUMINAMATH_CALUDE_symmetric_circle_l2383_238363

/-- Given a circle with equation (x+2)^2 + y^2 = 5 and a line of symmetry y = x,
    the symmetric circle has the equation x^2 + (y+2)^2 = 5 -/
theorem symmetric_circle (x y : ℝ) :
  (∃ (x₀ y₀ : ℝ), (x₀ + 2)^2 + y₀^2 = 5 ∧ y₀ = x₀) →
  (∃ (x₁ y₁ : ℝ), x₁^2 + (y₁ + 2)^2 = 5) :=
sorry

end NUMINAMATH_CALUDE_symmetric_circle_l2383_238363


namespace NUMINAMATH_CALUDE_class_average_marks_l2383_238341

/-- Calculates the average marks for a class given specific score distributions -/
theorem class_average_marks (total_students : ℕ) 
  (high_score_students : ℕ) (high_score : ℕ) 
  (mid_score_students : ℕ) (mid_score_diff : ℕ)
  (h1 : total_students = 50)
  (h2 : high_score_students = 10)
  (h3 : high_score = 90)
  (h4 : mid_score_students = 15)
  (h5 : mid_score_diff = 10) :
  let low_score_students := total_students - (high_score_students + mid_score_students)
  let low_score := 60
  let total_marks := high_score_students * high_score + 
                     mid_score_students * (high_score - mid_score_diff) + 
                     low_score_students * low_score
  total_marks / total_students = 72 := by
sorry

end NUMINAMATH_CALUDE_class_average_marks_l2383_238341


namespace NUMINAMATH_CALUDE_cows_ran_away_after_10_days_l2383_238305

/-- The number of days that passed before cows ran away -/
def days_before_cows_ran_away (initial_cows : ℕ) (initial_duration : ℕ) (cows_ran_away : ℕ) : ℕ :=
  (initial_cows * initial_duration - (initial_cows - cows_ran_away) * initial_duration) / initial_cows

theorem cows_ran_away_after_10_days :
  days_before_cows_ran_away 1000 50 200 = 10 := by
  sorry

end NUMINAMATH_CALUDE_cows_ran_away_after_10_days_l2383_238305


namespace NUMINAMATH_CALUDE_polynomial_expansion_l2383_238354

theorem polynomial_expansion (x : ℝ) : 
  (2*x^2 + 5*x + 8)*(x+1) - (x+1)*(x^2 - 2*x + 50) + (3*x - 7)*(x+1)*(x - 2) = 
  4*x^3 - 2*x^2 - 34*x - 28 := by
sorry

end NUMINAMATH_CALUDE_polynomial_expansion_l2383_238354


namespace NUMINAMATH_CALUDE_fence_cost_per_foot_l2383_238338

/-- Proves that for a square plot with an area of 36 sq ft and a total fencing cost of Rs. 1392, the price per foot of fencing is Rs. 58. -/
theorem fence_cost_per_foot (plot_area : ℝ) (total_cost : ℝ) (h1 : plot_area = 36) (h2 : total_cost = 1392) :
  let side_length : ℝ := Real.sqrt plot_area
  let perimeter : ℝ := 4 * side_length
  let cost_per_foot : ℝ := total_cost / perimeter
  cost_per_foot = 58 := by
  sorry

end NUMINAMATH_CALUDE_fence_cost_per_foot_l2383_238338


namespace NUMINAMATH_CALUDE_karen_cookies_to_grandparents_l2383_238320

/-- The number of cookies Karen gave to her grandparents -/
def cookies_to_grandparents (total_cookies class_size cookies_per_student cookies_for_self : ℕ) : ℕ :=
  total_cookies - (cookies_for_self + class_size * cookies_per_student)

/-- Theorem stating the number of cookies Karen gave to her grandparents -/
theorem karen_cookies_to_grandparents :
  cookies_to_grandparents 50 16 2 10 = 8 := by
  sorry

end NUMINAMATH_CALUDE_karen_cookies_to_grandparents_l2383_238320


namespace NUMINAMATH_CALUDE_book_price_calculation_l2383_238335

theorem book_price_calculation (discounted_price original_price : ℝ) : 
  discounted_price = 8 →
  discounted_price = (1 / 8) * original_price →
  original_price = 64 := by
sorry

end NUMINAMATH_CALUDE_book_price_calculation_l2383_238335


namespace NUMINAMATH_CALUDE_min_area_special_square_l2383_238347

/-- A square with one side on y = 2x - 17 and two vertices on y = x^2 -/
structure SpecialSquare where
  -- Coordinates of the two vertices on the parabola
  x₁ : ℝ
  x₂ : ℝ
  -- Conditions
  vertex_on_parabola : x₁ < x₂ ∧ (x₁, x₁^2) ∈ {p : ℝ × ℝ | p.2 = p.1^2} ∧ (x₂, x₂^2) ∈ {p : ℝ × ℝ | p.2 = p.1^2}
  side_on_line : ∃ (a b : ℝ), (a, 2*a - 17) ∈ {p : ℝ × ℝ | p.2 = 2*p.1 - 17} ∧ 
                               (b, 2*b - 17) ∈ {p : ℝ × ℝ | p.2 = 2*p.1 - 17} ∧
                               (b - a)^2 + (2*b - 17 - (2*a - 17))^2 = (x₂ - x₁)^2 + (x₂^2 - x₁^2)^2

/-- The area of a SpecialSquare -/
def area (s : SpecialSquare) : ℝ := (s.x₂ - s.x₁)^2 + (s.x₂^2 - s.x₁^2)^2

/-- Theorem stating the minimum area of a SpecialSquare is 80 -/
theorem min_area_special_square : 
  ∀ s : SpecialSquare, area s ≥ 80 ∧ ∃ s' : SpecialSquare, area s' = 80 := by
  sorry

end NUMINAMATH_CALUDE_min_area_special_square_l2383_238347


namespace NUMINAMATH_CALUDE_d₂_equals_six_l2383_238396

/-- E(n) is the number of quintuples (b₁, b₂, b₃, b₄, b₅) of distinct integers
    with 1 ≤ bᵢ ≤ n for all i such that n divides b₁+b₂+b₃+b₄+b₅ -/
def E (n : ℕ) : ℕ := sorry

/-- p(x) is a polynomial of degree 4 that satisfies E(n) = p(n)
    for all odd integers n ≥ 7 divisible by 3 -/
noncomputable def p : ℝ → ℝ := 
  fun x => d₄ * x^4 + d₃ * x^3 + d₂ * x^2 + d₁ * x + d₀
  where
    d₄ : ℝ := sorry
    d₃ : ℝ := sorry
    d₂ : ℝ := sorry
    d₁ : ℝ := sorry
    d₀ : ℝ := sorry

theorem d₂_equals_six :
  ∀ n : ℕ, n ≥ 7 → Odd n → 3 ∣ n → E n = p n → d₂ = 6 := by sorry

end NUMINAMATH_CALUDE_d₂_equals_six_l2383_238396


namespace NUMINAMATH_CALUDE_parking_lot_problem_l2383_238317

theorem parking_lot_problem (total_vehicles : ℕ) (total_wheels : ℕ) 
  (car_wheels : ℕ) (motorcycle_wheels : ℕ) :
  total_vehicles = 30 →
  total_wheels = 84 →
  car_wheels = 4 →
  motorcycle_wheels = 2 →
  ∃ (cars : ℕ) (motorcycles : ℕ),
    cars + motorcycles = total_vehicles ∧
    car_wheels * cars + motorcycle_wheels * motorcycles = total_wheels ∧
    motorcycles = 18 := by
  sorry

end NUMINAMATH_CALUDE_parking_lot_problem_l2383_238317


namespace NUMINAMATH_CALUDE_sqrt_x_minus_two_meaningful_l2383_238303

theorem sqrt_x_minus_two_meaningful (x : ℝ) : 
  (∃ y : ℝ, y ^ 2 = x - 2) ↔ x ≥ 2 := by sorry

end NUMINAMATH_CALUDE_sqrt_x_minus_two_meaningful_l2383_238303


namespace NUMINAMATH_CALUDE_first_discount_is_twenty_percent_l2383_238356

/-- Proves that the first discount is 20% given the conditions of the problem -/
theorem first_discount_is_twenty_percent
  (list_price : ℝ)
  (final_price : ℝ)
  (second_discount : ℝ)
  (h1 : list_price = 150)
  (h2 : final_price = 105)
  (h3 : second_discount = 12.5)
  : ∃ (first_discount : ℝ),
    first_discount = 20 ∧
    final_price = list_price * (1 - first_discount / 100) * (1 - second_discount / 100) :=
by sorry

end NUMINAMATH_CALUDE_first_discount_is_twenty_percent_l2383_238356


namespace NUMINAMATH_CALUDE_distance_traveled_correct_mrs_hilt_trip_distance_l2383_238300

/-- Calculates the distance traveled given initial and final odometer readings -/
def distance_traveled (initial_reading final_reading : ℝ) : ℝ :=
  final_reading - initial_reading

/-- Theorem: The distance traveled is the difference between final and initial odometer readings -/
theorem distance_traveled_correct (initial_reading final_reading : ℝ) :
  distance_traveled initial_reading final_reading = final_reading - initial_reading :=
by sorry

/-- Mrs. Hilt's trip distance calculation -/
theorem mrs_hilt_trip_distance :
  distance_traveled 212.3 372 = 159.7 :=
by sorry

end NUMINAMATH_CALUDE_distance_traveled_correct_mrs_hilt_trip_distance_l2383_238300


namespace NUMINAMATH_CALUDE_smallest_square_coverage_l2383_238324

/-- Represents a rectangle with integer dimensions -/
structure Rectangle where
  width : ℕ
  height : ℕ

/-- Represents a square with integer side length -/
structure Square where
  side : ℕ

/-- Calculates the area of a rectangle -/
def rectangleArea (r : Rectangle) : ℕ := r.width * r.height

/-- Calculates the area of a square -/
def squareArea (s : Square) : ℕ := s.side * s.side

/-- Checks if a square can be exactly covered by a given number of rectangles -/
def canCoverSquare (s : Square) (r : Rectangle) (n : ℕ) : Prop :=
  squareArea s = n * rectangleArea r

/-- The theorem to be proved -/
theorem smallest_square_coverage :
  ∃ (s : Square) (n : ℕ),
    let r : Rectangle := ⟨2, 3⟩
    canCoverSquare s r n ∧
    (∀ (s' : Square) (n' : ℕ), canCoverSquare s' r n' → squareArea s ≤ squareArea s') ∧
    n = 6 :=
  sorry

end NUMINAMATH_CALUDE_smallest_square_coverage_l2383_238324


namespace NUMINAMATH_CALUDE_min_value_theorem_l2383_238367

theorem min_value_theorem (a b c d : ℝ) 
  (h : |b - Real.log a / a| + |c - d + 2| = 0) : 
  ∃ (min_val : ℝ), min_val = 9/2 ∧ 
    ∀ (x y : ℝ), (x - y)^2 + (Real.log x / x - (y + 2))^2 ≥ min_val :=
sorry

end NUMINAMATH_CALUDE_min_value_theorem_l2383_238367


namespace NUMINAMATH_CALUDE_eriks_bread_purchase_eriks_bread_purchase_correct_l2383_238316

theorem eriks_bread_purchase (initial_money : ℕ) (orange_juice_cartons : ℕ) 
  (bread_cost : ℕ) (juice_cost : ℕ) (money_left : ℕ) : ℕ :=
  let total_spent := initial_money - money_left
  let juice_total_cost := orange_juice_cartons * juice_cost
  let bread_total_cost := total_spent - juice_total_cost
  bread_total_cost / bread_cost

#check @eriks_bread_purchase

theorem eriks_bread_purchase_correct : 
  eriks_bread_purchase 86 3 3 6 59 = 3 := by
  sorry

end NUMINAMATH_CALUDE_eriks_bread_purchase_eriks_bread_purchase_correct_l2383_238316


namespace NUMINAMATH_CALUDE_arctan_sum_three_four_l2383_238333

theorem arctan_sum_three_four : Real.arctan (3/4) + Real.arctan (4/3) = π/2 := by
  sorry

end NUMINAMATH_CALUDE_arctan_sum_three_four_l2383_238333


namespace NUMINAMATH_CALUDE_toy_cars_count_l2383_238384

/-- The number of toy cars given to boys in a charity event -/
def toy_cars_to_boys (total_toys : ℕ) (dolls_to_girls : ℕ) : ℕ :=
  total_toys - dolls_to_girls

/-- Theorem stating that the number of toy cars given to boys is 134 -/
theorem toy_cars_count :
  toy_cars_to_boys 403 269 = 134 := by
  sorry

end NUMINAMATH_CALUDE_toy_cars_count_l2383_238384


namespace NUMINAMATH_CALUDE_num_routes_eq_factorial_power_l2383_238344

/-- Represents the number of southern cities -/
def num_southern_cities : ℕ := 4

/-- Represents the number of northern cities -/
def num_northern_cities : ℕ := 5

/-- Represents the number of transfers between southern cities -/
def num_transfers : ℕ := num_southern_cities

/-- Calculates the number of different routes for the traveler -/
def num_routes : ℕ := (Nat.factorial (num_southern_cities - 1)) * (num_northern_cities ^ num_transfers)

/-- Theorem stating that the number of routes is equal to 3! × 5^4 -/
theorem num_routes_eq_factorial_power : num_routes = 3750 := by sorry

end NUMINAMATH_CALUDE_num_routes_eq_factorial_power_l2383_238344


namespace NUMINAMATH_CALUDE_quadratic_inequality_solution_set_l2383_238322

theorem quadratic_inequality_solution_set (a : ℝ) :
  let solution_set := {x : ℝ | a * x^2 - (2*a - 1) * x + (a - 1) < 0}
  if a > 0 then
    solution_set = {x : ℝ | (a - 1) / a < x ∧ x < 1}
  else if a = 0 then
    solution_set = {x : ℝ | x < 1}
  else
    solution_set = {x : ℝ | x > (a - 1) / a ∨ x < 1} :=
by sorry

end NUMINAMATH_CALUDE_quadratic_inequality_solution_set_l2383_238322


namespace NUMINAMATH_CALUDE_functional_equation_solution_l2383_238311

theorem functional_equation_solution (f : ℕ → ℕ) 
  (h : ∀ x y : ℕ, f (x + y) = f x + f y) : 
  ∃ a : ℕ, ∀ x : ℕ, f x = a * x :=
sorry

end NUMINAMATH_CALUDE_functional_equation_solution_l2383_238311


namespace NUMINAMATH_CALUDE_longest_side_of_triangle_l2383_238329

theorem longest_side_of_triangle (y : ℝ) : 
  8 + (y + 5) + (3 * y + 2) = 47 → 
  max 8 (max (y + 5) (3 * y + 2)) = 26 := by
sorry

end NUMINAMATH_CALUDE_longest_side_of_triangle_l2383_238329


namespace NUMINAMATH_CALUDE_milk_for_cookies_l2383_238307

/-- Given that 18 cookies require 3 quarts of milk, and there are 2 pints in a quart,
    prove that 6 cookies require 2 pints of milk. -/
theorem milk_for_cookies (cookies_large : ℕ) (milk_quarts : ℕ) (cookies_small : ℕ) 
  (pints_per_quart : ℕ) (h1 : cookies_large = 18) (h2 : milk_quarts = 3) 
  (h3 : cookies_small = 6) (h4 : pints_per_quart = 2) : 
  (milk_quarts * pints_per_quart * cookies_small) / cookies_large = 2 :=
by sorry

end NUMINAMATH_CALUDE_milk_for_cookies_l2383_238307


namespace NUMINAMATH_CALUDE_trees_on_specific_road_l2383_238375

/-- Calculates the number of trees that can be planted along a road -/
def treesAlongRoad (roadLength : ℕ) (treeSpacing : ℕ) : ℕ :=
  let intervalsPerSide := roadLength / treeSpacing
  let treesPerSide := intervalsPerSide - 1
  2 * treesPerSide

/-- The theorem stating the number of trees along the specific road -/
theorem trees_on_specific_road :
  treesAlongRoad 100 5 = 38 := by
  sorry

#eval treesAlongRoad 100 5

end NUMINAMATH_CALUDE_trees_on_specific_road_l2383_238375


namespace NUMINAMATH_CALUDE_problem_statement_l2383_238380

theorem problem_statement (a b : ℝ) (h : |a - 1| + (b + 2)^2 = 0) : 
  (a + b)^2002 + a^2001 = 2 := by
  sorry

end NUMINAMATH_CALUDE_problem_statement_l2383_238380


namespace NUMINAMATH_CALUDE_total_sweets_l2383_238353

theorem total_sweets (red_sweets : ℕ) (green_sweets : ℕ) (other_sweets : ℕ)
  (h1 : red_sweets = 49)
  (h2 : green_sweets = 59)
  (h3 : other_sweets = 177) :
  red_sweets + green_sweets + other_sweets = 285 := by
sorry

end NUMINAMATH_CALUDE_total_sweets_l2383_238353


namespace NUMINAMATH_CALUDE_baker_initial_cakes_l2383_238362

theorem baker_initial_cakes 
  (bought : ℕ) 
  (sold : ℕ) 
  (difference : ℕ) 
  (h1 : bought = 139)
  (h2 : sold = 145)
  (h3 : sold = bought + difference)
  (h4 : difference = 6) : 
  sold - bought = 6 := by
  sorry

end NUMINAMATH_CALUDE_baker_initial_cakes_l2383_238362


namespace NUMINAMATH_CALUDE_f_of_3_equals_15_l2383_238360

-- Define the function f
def f (x : ℝ) : ℝ := x^3 - x^2 - x

-- Theorem statement
theorem f_of_3_equals_15 : f 3 = 15 := by
  sorry

end NUMINAMATH_CALUDE_f_of_3_equals_15_l2383_238360


namespace NUMINAMATH_CALUDE_bobs_grade_l2383_238310

theorem bobs_grade (jenny_grade jason_grade bob_grade : ℕ) : 
  jenny_grade = 95 →
  jason_grade = jenny_grade - 25 →
  bob_grade = jason_grade / 2 →
  bob_grade = 35 := by
  sorry

end NUMINAMATH_CALUDE_bobs_grade_l2383_238310


namespace NUMINAMATH_CALUDE_square_root_of_25_l2383_238358

theorem square_root_of_25 : Real.sqrt 25 = 5 ∨ Real.sqrt 25 = -5 := by
  sorry

end NUMINAMATH_CALUDE_square_root_of_25_l2383_238358


namespace NUMINAMATH_CALUDE_closest_to_sqrt_65_minus_sqrt_63_l2383_238371

theorem closest_to_sqrt_65_minus_sqrt_63 :
  let options : List ℝ := [0.12, 0.13, 0.14, 0.15, 0.16]
  ∀ x ∈ options, x ≠ 0.13 →
    |Real.sqrt 65 - Real.sqrt 63 - 0.13| < |Real.sqrt 65 - Real.sqrt 63 - x| := by
  sorry

end NUMINAMATH_CALUDE_closest_to_sqrt_65_minus_sqrt_63_l2383_238371


namespace NUMINAMATH_CALUDE_mrs_snyder_income_l2383_238352

/-- Mrs. Snyder's previous monthly income --/
def previous_income : ℝ := 1000

/-- Mrs. Snyder's salary increase --/
def salary_increase : ℝ := 600

/-- Percentage of previous income spent on rent and utilities --/
def previous_percentage : ℝ := 0.40

/-- Percentage of new income spent on rent and utilities --/
def new_percentage : ℝ := 0.25

theorem mrs_snyder_income :
  previous_income * previous_percentage = 
  (previous_income + salary_increase) * new_percentage := by
  sorry

#check mrs_snyder_income

end NUMINAMATH_CALUDE_mrs_snyder_income_l2383_238352


namespace NUMINAMATH_CALUDE_real_part_of_z_l2383_238369

theorem real_part_of_z (z : ℂ) (h : Complex.I * (z + 1) = -3 + 2 * Complex.I) : 
  z.re = 1 := by
  sorry

end NUMINAMATH_CALUDE_real_part_of_z_l2383_238369


namespace NUMINAMATH_CALUDE_line_point_k_value_l2383_238315

/-- A line contains the points (2, -1), (10, k), and (25, 4). The value of k is 17/23. -/
theorem line_point_k_value (k : ℚ) : 
  (∃ (line : ℝ → ℝ), 
    line 2 = -1 ∧ 
    line 10 = k ∧ 
    line 25 = 4) → 
  k = 17/23 := by
sorry

end NUMINAMATH_CALUDE_line_point_k_value_l2383_238315


namespace NUMINAMATH_CALUDE_adelaide_ducks_main_theorem_l2383_238368

/-- Proves that Adelaide bought 30 ducks given the conditions of the problem -/
theorem adelaide_ducks : ℕ → ℕ → ℕ → Prop :=
  fun adelaide ephraim kolton =>
    adelaide = 2 * ephraim ∧
    ephraim = kolton - 45 ∧
    (adelaide + ephraim + kolton) / 3 = 35 →
    adelaide = 30

/-- Main theorem statement -/
theorem main_theorem : ∃ (a e k : ℕ), adelaide_ducks a e k :=
  sorry

end NUMINAMATH_CALUDE_adelaide_ducks_main_theorem_l2383_238368


namespace NUMINAMATH_CALUDE_probability_specific_arrangement_l2383_238302

def total_tiles : ℕ := 7
def x_tiles : ℕ := 4
def o_tiles : ℕ := 3

theorem probability_specific_arrangement :
  (1 : ℚ) / (Nat.choose total_tiles x_tiles) = 1 / 35 := by sorry

end NUMINAMATH_CALUDE_probability_specific_arrangement_l2383_238302


namespace NUMINAMATH_CALUDE_imaginary_power_2011_l2383_238339

theorem imaginary_power_2011 (i : ℂ) (h : i^2 = -1) : i^2011 = -i := by
  sorry

end NUMINAMATH_CALUDE_imaginary_power_2011_l2383_238339


namespace NUMINAMATH_CALUDE_distance_ratio_cars_l2383_238348

/-- Represents a car with its speed and travel time -/
structure Car where
  speed : ℝ
  time : ℝ

/-- Calculates the distance traveled by a car -/
def distance (car : Car) : ℝ := car.speed * car.time

/-- Theorem: The ratio of distances covered by Car A and Car B is 2:1 -/
theorem distance_ratio_cars (carA carB : Car)
  (hA_speed : carA.speed = 80)
  (hA_time : carA.time = 5)
  (hB_speed : carB.speed = 100)
  (hB_time : carB.time = 2) :
  distance carA / distance carB = 2 := by
  sorry

#check distance_ratio_cars

end NUMINAMATH_CALUDE_distance_ratio_cars_l2383_238348


namespace NUMINAMATH_CALUDE_theorem_1_theorem_2_l2383_238395

-- Define the types for lines and planes
variable (Line Plane : Type)

-- Define the relations
variable (perpendicular : Line → Plane → Prop)
variable (parallel : Line → Plane → Prop)
variable (intersect : Plane → Plane → Line → Prop)
variable (contains : Plane → Line → Prop)
variable (perpendicular_lines : Line → Line → Prop)
variable (perpendicular_planes : Plane → Plane → Prop)

-- Theorem 1
theorem theorem_1 (m n : Line) (α : Plane) :
  perpendicular m α → parallel n α → perpendicular_lines m n :=
sorry

-- Theorem 2
theorem theorem_2 (m : Line) (α β γ : Plane) :
  perpendicular_planes α γ → perpendicular_planes β γ → intersect α β m → perpendicular m γ :=
sorry

-- Assumptions
axiom different_lines (m n : Line) : m ≠ n
axiom different_planes (α β γ : Plane) : α ≠ β ∧ β ≠ γ ∧ α ≠ γ

end NUMINAMATH_CALUDE_theorem_1_theorem_2_l2383_238395
