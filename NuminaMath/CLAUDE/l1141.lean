import Mathlib

namespace total_fish_count_l1141_114184

theorem total_fish_count (pikes sturgeon herring : ℕ) 
  (h1 : pikes = 30)
  (h2 : sturgeon = 40)
  (h3 : herring = 75) :
  pikes + sturgeon + herring = 145 := by
  sorry

end total_fish_count_l1141_114184


namespace common_ratio_of_geometric_series_l1141_114196

def geometric_series : ℕ → ℚ
  | 0 => 7/8
  | 1 => -21/32
  | 2 => 63/128
  | (n+3) => (-3/4) * geometric_series n

theorem common_ratio_of_geometric_series :
  ∀ n : ℕ, n ≥ 1 → geometric_series (n+1) / geometric_series n = -3/4 :=
by
  sorry

end common_ratio_of_geometric_series_l1141_114196


namespace tea_mixture_price_is_153_l1141_114180

/-- Calculates the price of a tea mixture given the prices of three tea varieties and their mixing ratio. -/
def tea_mixture_price (p1 p2 p3 : ℚ) (r1 r2 r3 : ℚ) : ℚ :=
  (p1 * r1 + p2 * r2 + p3 * r3) / (r1 + r2 + r3)

/-- Theorem stating that the price of a specific tea mixture is 153. -/
theorem tea_mixture_price_is_153 :
  tea_mixture_price 126 135 175.5 1 1 2 = 153 := by
  sorry

end tea_mixture_price_is_153_l1141_114180


namespace ellipse_m_value_l1141_114141

/-- Definition of an ellipse with semi-major axis a and semi-minor axis b -/
def is_ellipse (a b : ℝ) (P : ℝ × ℝ) : Prop :=
  (P.1^2 / a^2) + (P.2^2 / b^2) = 1

/-- The sum of distances from any point on an ellipse to its foci is constant -/
axiom ellipse_foci_distance_sum (a b : ℝ) (P F₁ F₂ : ℝ × ℝ) :
  is_ellipse a b P → (dist P F₁ + dist P F₂ = 2 * a)

/-- Theorem: For an ellipse with equation x²/m + y²/16 = 1, 
    if the distances from any point to the foci are 3 and 7, then m = 25 -/
theorem ellipse_m_value (m : ℝ) (P F₁ F₂ : ℝ × ℝ) :
  is_ellipse (Real.sqrt m) 4 P →
  dist P F₁ = 3 →
  dist P F₂ = 7 →
  m = 25 := by sorry

end ellipse_m_value_l1141_114141


namespace smallest_n_divisible_by_1419_l1141_114189

def consecutiveEvenProduct (n : ℕ) : ℕ :=
  (List.range ((n / 2) - 1)).foldl (λ acc i => acc * (2 * (i + 2))) 2

theorem smallest_n_divisible_by_1419 : 
  (∀ m : ℕ, m < 106 → m % 2 = 0 → ¬(consecutiveEvenProduct m % 1419 = 0)) ∧ 
  (consecutiveEvenProduct 106 % 1419 = 0) := by
  sorry

end smallest_n_divisible_by_1419_l1141_114189


namespace dormitory_second_year_fraction_l1141_114120

theorem dormitory_second_year_fraction :
  ∀ (F S : ℚ),
  F + S = 1 →
  (4 : ℚ) / 5 * F = F - (1 : ℚ) / 5 * F →
  (1 : ℚ) / 3 * ((1 : ℚ) / 5 * F) = (1 : ℚ) / 15 * S →
  (14 : ℚ) / 15 * S = (7 : ℚ) / 15 →
  S = (1 : ℚ) / 2 :=
by
  sorry

end dormitory_second_year_fraction_l1141_114120


namespace complex_number_problem_l1141_114157

theorem complex_number_problem (z₁ z₂ : ℂ) : 
  (z₁ - 2) * (1 + Complex.I) = 1 - Complex.I →
  z₂.im = 2 →
  ∃ (r : ℝ), z₁ * z₂ = r →
  z₂ = 4 + 2 * Complex.I := by
sorry

end complex_number_problem_l1141_114157


namespace rachel_picked_apples_l1141_114134

/-- Given information about Rachel's apple picking -/
structure ApplePicking where
  num_trees : ℕ
  apples_per_tree : ℕ
  apples_left : ℕ

/-- Theorem stating the total number of apples Rachel picked -/
theorem rachel_picked_apples (ap : ApplePicking)
  (h1 : ap.num_trees = 4)
  (h2 : ap.apples_per_tree = 7)
  (h3 : ap.apples_left = 29) :
  ap.num_trees * ap.apples_per_tree = 28 := by
  sorry

#check rachel_picked_apples

end rachel_picked_apples_l1141_114134


namespace tan_210_degrees_l1141_114101

theorem tan_210_degrees : Real.tan (210 * π / 180) = -Real.sqrt 3 / 3 := by
  sorry

end tan_210_degrees_l1141_114101


namespace sequence_convergence_l1141_114132

/-- Given an integer k > 5, this function represents the operation described in the problem.
    It takes a number in base k, calculates the sum of its digits, multiplies it by (k-1)^2,
    and appends this product to the original number. -/
def baseKOperation (k : ℕ) (n : ℕ) : ℕ :=
  sorry

/-- This function represents the sequence generated by repeatedly applying the baseKOperation -/
def generateSequence (k : ℕ) (start : ℕ) : ℕ → ℕ
  | 0 => start
  | n + 1 => baseKOperation k (generateSequence k start n)

/-- The theorem states that for any k > 5, the sequence generated by the described process
    will eventually converge to 2(k-1)^3 -/
theorem sequence_convergence (k : ℕ) (start : ℕ) (h : k > 5) :
  ∃ N : ℕ, ∀ n ≥ N, generateSequence k start n = 2 * (k - 1)^3 :=
sorry

end sequence_convergence_l1141_114132


namespace toilet_paper_squares_per_roll_l1141_114136

theorem toilet_paper_squares_per_roll 
  (daily_visits : ℕ) 
  (squares_per_visit : ℕ) 
  (total_rolls : ℕ) 
  (days_supply_lasts : ℕ) 
  (h1 : daily_visits = 3) 
  (h2 : squares_per_visit = 5) 
  (h3 : total_rolls = 1000) 
  (h4 : days_supply_lasts = 20000) :
  (daily_visits * squares_per_visit * days_supply_lasts) / total_rolls = 300 := by
  sorry

end toilet_paper_squares_per_roll_l1141_114136


namespace library_visitors_average_l1141_114118

/-- Calculates the average number of visitors per day in a 30-day month starting with a Sunday -/
def averageVisitors (sundayVisitors : ℕ) (otherDayVisitors : ℕ) : ℚ :=
  let totalSundays := 5
  let totalOtherDays := 30 - totalSundays
  let totalVisitors := sundayVisitors * totalSundays + otherDayVisitors * totalOtherDays
  totalVisitors / 30

theorem library_visitors_average :
  averageVisitors 1000 700 = 750 := by
  sorry

end library_visitors_average_l1141_114118


namespace derivative_x_minus_sin_l1141_114124

/-- The derivative of x - sin(x) is 1 - cos(x) -/
theorem derivative_x_minus_sin (x : ℝ) : 
  deriv (fun x => x - Real.sin x) x = 1 - Real.cos x := by
  sorry

end derivative_x_minus_sin_l1141_114124


namespace sheila_work_hours_l1141_114190

/-- Sheila's work schedule and earnings -/
structure WorkSchedule where
  mon_wed_fri_hours : ℕ  -- Hours worked on Monday, Wednesday, and Friday combined
  tue_thu_hours : ℕ      -- Hours worked on Tuesday and Thursday combined
  hourly_rate : ℕ        -- Hourly rate in dollars
  weekly_earnings : ℕ    -- Total weekly earnings in dollars

/-- Theorem: Given Sheila's work schedule and earnings, prove she works 24 hours on Mon, Wed, Fri -/
theorem sheila_work_hours (s : WorkSchedule) 
  (h1 : s.tue_thu_hours = 12)     -- 6 hours each on Tuesday and Thursday
  (h2 : s.hourly_rate = 12)       -- $12 per hour
  (h3 : s.weekly_earnings = 432)  -- $432 per week
  : s.mon_wed_fri_hours = 24 := by
  sorry


end sheila_work_hours_l1141_114190


namespace intersecting_circles_sum_l1141_114133

/-- Given two circles intersecting at points A(1,3) and B(m,-1), with their centers lying on the line x-y+c=0, prove that m+c = 3 -/
theorem intersecting_circles_sum (m c : ℝ) : 
  (∃ (C D : ℝ × ℝ), 
    (C.1 - C.2 + c = 0) ∧ 
    (D.1 - D.2 + c = 0) ∧ 
    ((1 - C.1)^2 + (3 - C.2)^2 = (m - C.1)^2 + (-1 - C.2)^2) ∧
    ((1 - D.1)^2 + (3 - D.2)^2 = (m - D.1)^2 + (-1 - D.2)^2)) →
  m + c = 3 := by
  sorry


end intersecting_circles_sum_l1141_114133


namespace alternating_student_arrangements_l1141_114153

def num_male_students : ℕ := 4
def num_female_students : ℕ := 5

theorem alternating_student_arrangements :
  (num_male_students.factorial * num_female_students.factorial : ℕ) = 2880 :=
by sorry

end alternating_student_arrangements_l1141_114153


namespace equal_intercept_line_equation_l1141_114194

/-- A line passing through (2,3) with equal intercepts on both axes -/
structure EqualInterceptLine where
  -- The equation of the line in the form ax + by + c = 0
  a : ℝ
  b : ℝ
  c : ℝ
  -- The line passes through (2,3)
  passes_through : a * 2 + b * 3 + c = 0
  -- The line has equal intercepts on both axes
  equal_intercepts : a ≠ 0 ∧ b ≠ 0 ∧ (c / a = c / b ∨ c = 0)

/-- The equation of an equal intercept line is either x+y-5=0 or 3x-2y=0 -/
theorem equal_intercept_line_equation (l : EqualInterceptLine) :
  (l.a = 1 ∧ l.b = 1 ∧ l.c = -5) ∨ (l.a = 3 ∧ l.b = -2 ∧ l.c = 0) :=
sorry

end equal_intercept_line_equation_l1141_114194


namespace parallel_condition_l1141_114111

/-- Two lines are parallel if and only if they have the same slope -/
def parallel (m1 a1 b1 : ℝ) (m2 a2 b2 : ℝ) : Prop :=
  m1 = m2

/-- The line l1 with equation ax + 2y - 3 = 0 -/
def l1 (a : ℝ) (x y : ℝ) : Prop :=
  a * x + 2 * y - 3 = 0

/-- The line l2 with equation 2x + y - a = 0 -/
def l2 (a : ℝ) (x y : ℝ) : Prop :=
  2 * x + y - a = 0

/-- The statement that a = 4 is a necessary and sufficient condition for l1 to be parallel to l2 -/
theorem parallel_condition (a : ℝ) :
  (∀ x y : ℝ, parallel (-a/2) 0 0 (-2) 0 0) ↔ a = 4 :=
sorry

end parallel_condition_l1141_114111


namespace reciprocal_of_repeating_seven_l1141_114199

/-- The repeating decimal 0.777... as a rational number -/
def repeating_seven : ℚ := 7 / 9

/-- The reciprocal of the repeating decimal 0.777... -/
def reciprocal_repeating_seven : ℚ := 9 / 7

/-- Theorem stating that the reciprocal of 0.777... is 9/7 -/
theorem reciprocal_of_repeating_seven :
  (repeating_seven)⁻¹ = reciprocal_repeating_seven :=
by sorry

end reciprocal_of_repeating_seven_l1141_114199


namespace arithmetic_calculation_l1141_114165

theorem arithmetic_calculation : 1^2 + (2 * 3)^3 - 4^2 + Real.sqrt 9 = 204 := by
  sorry

end arithmetic_calculation_l1141_114165


namespace prob_odd_diagonals_eq_1_126_l1141_114102

/-- Represents a 3x3 grid arrangement of numbers 1 to 9 -/
def Grid := Fin 9 → Fin 9

/-- Checks if a given grid has odd sums on both diagonals -/
def has_odd_diagonal_sums (g : Grid) : Prop :=
  (g 0 + g 4 + g 8).val % 2 = 1 ∧ (g 2 + g 4 + g 6).val % 2 = 1

/-- The set of all valid grid arrangements -/
def all_grids : Finset Grid :=
  sorry

/-- The set of grid arrangements with odd diagonal sums -/
def odd_diagonal_grids : Finset Grid :=
  sorry

/-- The probability of a random grid having odd diagonal sums -/
def prob_odd_diagonals : ℚ :=
  (odd_diagonal_grids.card : ℚ) / (all_grids.card : ℚ)

theorem prob_odd_diagonals_eq_1_126 : prob_odd_diagonals = 1 / 126 :=
  sorry

end prob_odd_diagonals_eq_1_126_l1141_114102


namespace mod_product_equivalence_l1141_114143

theorem mod_product_equivalence (m : ℕ) : 
  (241 * 398 ≡ m [ZMOD 50]) → 
  (0 ≤ m ∧ m < 50) → 
  m = 18 := by
sorry

end mod_product_equivalence_l1141_114143


namespace max_value_abc_l1141_114114

theorem max_value_abc (a b c : ℝ) (h : a ≠ 0 ∨ b ≠ 0 ∨ c ≠ 0) :
  (a * b + 2 * b * c) / (a^2 + b^2 + c^2) ≤ Real.sqrt 5 / 2 ∧
  ∃ a' b' c' : ℝ, (a' ≠ 0 ∨ b' ≠ 0 ∨ c' ≠ 0) ∧
    (a' * b' + 2 * b' * c') / (a'^2 + b'^2 + c'^2) = Real.sqrt 5 / 2 :=
by sorry

end max_value_abc_l1141_114114


namespace quadratic_points_relationship_l1141_114156

/-- The quadratic function f(x) = -(x-1)^2 + 2 -/
def f (x : ℝ) : ℝ := -(x - 1)^2 + 2

/-- Point P1 on the graph of f -/
def P1 : ℝ × ℝ := (-1, f (-1))

/-- Point P2 on the graph of f -/
def P2 : ℝ × ℝ := (3, f 3)

/-- Point P3 on the graph of f -/
def P3 : ℝ × ℝ := (5, f 5)

theorem quadratic_points_relationship : P1.2 = P2.2 ∧ P1.2 > P3.2 := by sorry

end quadratic_points_relationship_l1141_114156


namespace geometric_sequence_property_l1141_114192

/-- Given a geometric sequence {a_n} with positive terms where a_4 * a_10 = 16, prove a_7 = 4 -/
theorem geometric_sequence_property (a : ℕ → ℝ) 
  (h_positive : ∀ n, a n > 0)
  (h_geometric : ∃ r : ℝ, ∀ n, a (n + 1) = r * a n)
  (h_product : a 4 * a 10 = 16) : 
  a 7 = 4 := by
sorry

end geometric_sequence_property_l1141_114192


namespace quadratic_equation_real_root_l1141_114185

theorem quadratic_equation_real_root (k : ℝ) : 
  (∃ x : ℝ, x^2 + (k + Complex.I) * x - 2 - k * Complex.I = 0) → 
  (k = 1 ∨ k = -1) := by
sorry

end quadratic_equation_real_root_l1141_114185


namespace sqrt_negative_one_squared_l1141_114104

theorem sqrt_negative_one_squared (x : ℝ) : Real.sqrt ((-1) * (-1)) = 1 := by
  sorry

end sqrt_negative_one_squared_l1141_114104


namespace max_value_ratio_l1141_114160

/-- An arithmetic sequence with properties S_4 = 10 and S_8 = 36 -/
structure ArithmeticSequence where
  a : ℕ+ → ℚ
  S : ℕ+ → ℚ
  is_arithmetic : ∀ n : ℕ+, a (n + 1) - a n = a 2 - a 1
  sum_def : ∀ n : ℕ+, S n = (n : ℚ) * (a 1 + a n) / 2
  S_4 : S 4 = 10
  S_8 : S 8 = 36

/-- The maximum value of a_n / S_(n+3) for the given arithmetic sequence is 1/7 -/
theorem max_value_ratio (seq : ArithmeticSequence) :
  (∃ n : ℕ+, seq.a n / seq.S (n + 3) = 1 / 7) ∧
  (∀ n : ℕ+, seq.a n / seq.S (n + 3) ≤ 1 / 7) := by
  sorry

end max_value_ratio_l1141_114160


namespace average_playtime_l1141_114138

def wednesday_hours : ℝ := 2
def thursday_hours : ℝ := 2
def friday_additional_hours : ℝ := 3
def total_days : ℕ := 3

theorem average_playtime :
  let total_hours := wednesday_hours + thursday_hours + (wednesday_hours + friday_additional_hours)
  total_hours / total_days = 3 := by
sorry

end average_playtime_l1141_114138


namespace max_trig_product_l1141_114175

theorem max_trig_product (x y z : ℝ) : 
  (Real.sin x + Real.sin (2*y) + Real.sin (3*z)) * 
  (Real.cos x + Real.cos (2*y) + Real.cos (3*z)) ≤ 4.5 := by
sorry

end max_trig_product_l1141_114175


namespace circle_center_coordinates_sum_l1141_114112

theorem circle_center_coordinates_sum (x y : ℝ) : 
  x^2 + y^2 - 12*x + 10*y = 40 → (x - 6)^2 + (y + 5)^2 = 101 ∧ x + y = 1 := by
sorry

end circle_center_coordinates_sum_l1141_114112


namespace loan_payback_calculation_l1141_114197

/-- Calculates the total amount to be paid back for a loan with interest -/
def total_payback (principal : ℝ) (interest_rate : ℝ) : ℝ :=
  principal * (1 + interest_rate)

/-- Theorem: Given a loan of $1200 with a 10% interest rate, the total amount to be paid back is $1320 -/
theorem loan_payback_calculation :
  total_payback 1200 0.1 = 1320 := by
  sorry

end loan_payback_calculation_l1141_114197


namespace books_gotten_rid_of_correct_l1141_114125

/-- Calculates the number of coloring books gotten rid of in a sale -/
def books_gotten_rid_of (initial_stock : ℕ) (num_shelves : ℕ) (books_per_shelf : ℕ) : ℕ :=
  initial_stock - (num_shelves * books_per_shelf)

/-- Proves that the number of coloring books gotten rid of is correct -/
theorem books_gotten_rid_of_correct (initial_stock : ℕ) (num_shelves : ℕ) (books_per_shelf : ℕ) :
  books_gotten_rid_of initial_stock num_shelves books_per_shelf =
  initial_stock - (num_shelves * books_per_shelf) :=
by sorry

#eval books_gotten_rid_of 40 5 4

end books_gotten_rid_of_correct_l1141_114125


namespace composition_constant_term_l1141_114109

/-- Given two functions f and g, and a condition on their composition,
    prove that the constant term in the composed function is 14. -/
theorem composition_constant_term
  (f g : ℝ → ℝ)
  (hf : ∀ x, f x = 5 * x - 1)
  (hg : ∃ c, ∀ x, g x = 2 * c * x + 3)
  (h_comp : ∃ d, ∀ x, f (g x) = 15 * x + d) :
  ∃ d, (∀ x, f (g x) = 15 * x + d) ∧ d = 14 := by sorry

end composition_constant_term_l1141_114109


namespace function_maximum_condition_l1141_114198

open Real

theorem function_maximum_condition (a b : ℝ) :
  let f : ℝ → ℝ := λ x ↦ (1/2) * Real.exp (2*x) + (a - Real.exp 1) * Real.exp x - a * Real.exp 1 + b
  (∀ x, f x ≤ f 1) → a < -Real.exp 1 :=
by
  sorry

end function_maximum_condition_l1141_114198


namespace solve_system_l1141_114135

theorem solve_system (x y : ℝ) 
  (eq1 : 2 * x = 3 * x - 25)
  (eq2 : x + y = 50) : 
  x = 25 ∧ y = 25 := by
  sorry

end solve_system_l1141_114135


namespace function_properties_l1141_114151

noncomputable def f (ω : ℝ) (x : ℝ) : ℝ := 
  (Real.cos (ω * x / 2))^2 + Real.sqrt 3 * Real.sin (ω * x / 2) * Real.cos (ω * x / 2) - 1/2

def is_periodic (f : ℝ → ℝ) (T : ℝ) : Prop :=
  ∀ x, f (x + T) = f x

theorem function_properties (ω : ℝ) (h1 : ω > 0) 
  (h2 : is_periodic (f ω) Real.pi) (h3 : ∀ T, 0 < T → T < Real.pi → ¬ is_periodic (f ω) T) :
  (ω = 2) ∧ 
  (∀ x, f ω x ≤ 1) ∧
  (∀ x, f ω x ≥ -1) ∧
  (∃ x, f ω x = 1) ∧
  (∃ x, f ω x = -1) ∧
  (∀ k : ℤ, ∀ x ∈ Set.Icc (k * Real.pi - Real.pi / 3) (k * Real.pi + Real.pi / 6), 
    ∀ y ∈ Set.Icc (k * Real.pi - Real.pi / 3) (k * Real.pi + Real.pi / 6),
    x ≤ y → f ω x ≤ f ω y) :=
by sorry

end function_properties_l1141_114151


namespace complement_of_union_l1141_114145

def U : Set Int := {x | x^2 - 5*x - 6 ≤ 0}

def A : Set Int := {x | x*(2-x) ≥ 0}

def B : Set Int := {1, 2, 3}

theorem complement_of_union : (U \ (A ∪ B)) = {-1, 4, 5, 6} := by sorry

end complement_of_union_l1141_114145


namespace min_value_product_l1141_114122

theorem min_value_product (x y : ℝ) (hx : x > 0) (hy : y > 0) (hxy : x * y = 1) :
  (x / y + y) * (y / x + x) ≥ 4 ∧
  ((x / y + y) * (y / x + x) = 4 ↔ x = 1 ∧ y = 1) :=
by sorry

end min_value_product_l1141_114122


namespace total_pages_bought_l1141_114168

def total_spent : ℚ := 10
def cost_per_notepad : ℚ := 5/4  -- $1.25 expressed as a rational number
def pages_per_notepad : ℕ := 60

theorem total_pages_bought : ℕ := by
  -- Proof goes here
  sorry

#check total_pages_bought = 480

end total_pages_bought_l1141_114168


namespace triangle_side_length_l1141_114115

noncomputable def f (x : ℝ) := Real.sin (7 * Real.pi / 6 - 2 * x) - 2 * Real.sin x ^ 2 + 1

theorem triangle_side_length 
  (A B C : ℝ) 
  (a b c : ℝ) 
  (h1 : f A = 1/2)
  (h2 : b - a = c - b)  -- arithmetic sequence condition
  (h3 : b * c * Real.cos A = 9) : 
  a = 3 * Real.sqrt 2 := by 
sorry

end triangle_side_length_l1141_114115


namespace min_value_of_E_l1141_114172

theorem min_value_of_E (x : ℝ) :
  let f (E : ℝ) := |x - 4| + |E| + |x - 5|
  (∃ (E : ℝ), f E = 10 ∧ ∀ (E' : ℝ), f E' ≥ 10) →
  (∃ (E_min : ℝ), |E_min| = 9 ∧ ∀ (E : ℝ), |E| ≥ 9) :=
by sorry

end min_value_of_E_l1141_114172


namespace winner_votes_not_unique_l1141_114177

/-- Represents an election result --/
structure ElectionResult where
  totalVotes : ℕ
  winnerVotes : ℕ
  secondPlaceVotes : ℕ

/-- Conditions of the election --/
def electionConditions (result : ElectionResult) : Prop :=
  (result.winnerVotes : ℚ) / result.totalVotes = 58 / 100 ∧
  result.winnerVotes - result.secondPlaceVotes = 1200

/-- Theorem stating that the number of votes for the winning candidate cannot be uniquely determined --/
theorem winner_votes_not_unique :
  ∃ (result1 result2 : ElectionResult),
    result1 ≠ result2 ∧
    electionConditions result1 ∧
    electionConditions result2 :=
sorry

end winner_votes_not_unique_l1141_114177


namespace power_of_two_difference_divisible_by_1987_l1141_114166

theorem power_of_two_difference_divisible_by_1987 :
  ∃ (a b : ℕ), 0 ≤ b ∧ b < a ∧ a ≤ 1987 ∧ (2^a - 2^b) % 1987 = 0 :=
by sorry

end power_of_two_difference_divisible_by_1987_l1141_114166


namespace model_c_net_change_l1141_114182

def apply_discount (price : ℝ) (discount : ℝ) : ℝ :=
  price * (1 - discount)

def apply_increase (price : ℝ) (increase : ℝ) : ℝ :=
  price * (1 + increase)

def model_c_price : ℝ := 2000

def model_c_discount1 : ℝ := 0.20
def model_c_increase : ℝ := 0.20
def model_c_discount2 : ℝ := 0.05

theorem model_c_net_change :
  let price1 := apply_discount model_c_price model_c_discount1
  let price2 := apply_increase price1 model_c_increase
  let price3 := apply_discount price2 model_c_discount2
  price3 - model_c_price = -176 := by
  sorry

end model_c_net_change_l1141_114182


namespace intersection_of_P_and_Q_l1141_114187

def P : Set ℝ := {x | x < 1}
def Q : Set ℝ := {x | x^2 < 4}

theorem intersection_of_P_and_Q : P ∩ Q = {x : ℝ | -2 < x ∧ x < 1} := by
  sorry

end intersection_of_P_and_Q_l1141_114187


namespace find_number_l1141_114129

theorem find_number : ∃ x : ℝ, 0.3 * ((x / 2.5) - 10.5) = 5.85 ∧ x = 75 := by
  sorry

end find_number_l1141_114129


namespace modulus_of_z_l1141_114170

-- Define the complex number z
def z : ℂ := Complex.I * (3 + 2 * Complex.I)

-- State the theorem
theorem modulus_of_z : Complex.abs z = Real.sqrt 13 := by
  sorry

end modulus_of_z_l1141_114170


namespace half_sum_negative_l1141_114107

theorem half_sum_negative (x : ℝ) : 
  (∃ y : ℝ, y = (x + 3) / 2 ∧ y < 0) ↔ (x + 3) / 2 < 0 := by
sorry

end half_sum_negative_l1141_114107


namespace sufficient_condition_not_necessary_condition_sufficient_but_not_necessary_l1141_114163

/-- Two lines are perpendicular if and only if the product of their slopes is -1 -/
def are_perpendicular (m : ℝ) : Prop :=
  3 * m + (2 * m - 1) * m = 0

/-- The condition m = -1 is sufficient for the lines to be perpendicular -/
theorem sufficient_condition (m : ℝ) :
  m = -1 → are_perpendicular m :=
by sorry

/-- The condition m = -1 is not necessary for the lines to be perpendicular -/
theorem not_necessary_condition :
  ∃ m : ℝ, m ≠ -1 ∧ are_perpendicular m :=
by sorry

/-- The condition m = -1 is sufficient but not necessary for the lines to be perpendicular -/
theorem sufficient_but_not_necessary :
  (∀ m : ℝ, m = -1 → are_perpendicular m) ∧
  (∃ m : ℝ, m ≠ -1 ∧ are_perpendicular m) :=
by sorry

end sufficient_condition_not_necessary_condition_sufficient_but_not_necessary_l1141_114163


namespace fishing_problem_l1141_114113

theorem fishing_problem (jordan_catch : ℕ) (perry_catch : ℕ) (total_catch : ℕ) (fish_lost : ℕ) (fish_remaining : ℕ) : 
  jordan_catch = 4 →
  perry_catch = 2 * jordan_catch →
  total_catch = jordan_catch + perry_catch →
  fish_lost = total_catch / 4 →
  fish_remaining = total_catch - fish_lost →
  fish_remaining = 9 := by
sorry

end fishing_problem_l1141_114113


namespace sum_of_squares_equivalence_l1141_114147

theorem sum_of_squares_equivalence (n : ℕ) :
  (∃ (a b : ℤ), (n : ℤ) = a^2 + b^2) ↔ (∃ (c d : ℤ), (2 * n : ℤ) = c^2 + d^2) := by
  sorry

end sum_of_squares_equivalence_l1141_114147


namespace cubic_equations_common_root_implies_three_real_roots_l1141_114127

/-- Given distinct nonzero real numbers a, b, c, if the equations ax³ + bx + c = 0, 
    bx³ + cx + a = 0, and cx³ + ax + b = 0 have a common root, then at least one of 
    these equations has three real roots. -/
theorem cubic_equations_common_root_implies_three_real_roots 
  (a b c : ℝ) (ha : a ≠ 0) (hb : b ≠ 0) (hc : c ≠ 0) 
  (hab : a ≠ b) (hbc : b ≠ c) (hac : a ≠ c)
  (h_common_root : ∃ x : ℝ, a * x^3 + b * x + c = 0 ∧ 
                            b * x^3 + c * x + a = 0 ∧ 
                            c * x^3 + a * x + b = 0) :
  (∃ x y z : ℝ, a * x^3 + b * x + c = 0 ∧ 
               a * y^3 + b * y + c = 0 ∧ 
               a * z^3 + b * z + c = 0) ∨
  (∃ x y z : ℝ, b * x^3 + c * x + a = 0 ∧ 
               b * y^3 + c * y + a = 0 ∧ 
               b * z^3 + c * z + a = 0) ∨
  (∃ x y z : ℝ, c * x^3 + a * x + b = 0 ∧ 
               c * y^3 + a * y + b = 0 ∧ 
               c * z^3 + a * z + b = 0) :=
by sorry

end cubic_equations_common_root_implies_three_real_roots_l1141_114127


namespace zoe_app_cost_l1141_114105

/-- Calculates the total cost of an app and its associated expenses -/
def total_app_cost (initial_cost monthly_cost in_game_cost upgrade_cost months : ℕ) : ℕ :=
  initial_cost + (monthly_cost * months) + in_game_cost + upgrade_cost

/-- Theorem stating the total cost for Zoe's app usage -/
theorem zoe_app_cost : total_app_cost 5 8 10 12 2 = 43 := by
  sorry

end zoe_app_cost_l1141_114105


namespace commutator_power_zero_l1141_114148

open Matrix

theorem commutator_power_zero (n : ℕ) (A B : Matrix (Fin n) (Fin n) ℝ) 
  (h_n : n ≥ 2) 
  (h_x : ∃ x : ℝ, x ≠ 0 ∧ x ≠ 1/2 ∧ x ≠ 1 ∧ x • (A * B) + (1 - x) • (B * A) = 1) :
  (A * B - B * A) ^ n = 0 := by
  sorry

end commutator_power_zero_l1141_114148


namespace g_composition_equals_71_l1141_114123

def g (n : ℤ) : ℤ :=
  if n < 5 then n^2 + 2*n - 1 else 2*n + 5

theorem g_composition_equals_71 : g (g (g 3)) = 71 := by
  sorry

end g_composition_equals_71_l1141_114123


namespace average_of_three_l1141_114155

theorem average_of_three (y : ℝ) : (15 + 25 + y) / 3 = 20 → y = 20 := by
  sorry

end average_of_three_l1141_114155


namespace tylers_age_l1141_114150

theorem tylers_age (tyler_age brother_age : ℕ) : 
  tyler_age + 3 = brother_age →
  tyler_age + brother_age = 11 →
  tyler_age = 4 := by
sorry

end tylers_age_l1141_114150


namespace perpendicular_vectors_collinear_vectors_l1141_114137

def vector_a (x : ℝ) : ℝ × ℝ := (3, x)
def vector_b : ℝ × ℝ := (-2, 2)

theorem perpendicular_vectors (x : ℝ) :
  (vector_a x).1 * vector_b.1 + (vector_a x).2 * vector_b.2 = 0 → x = 3 := by sorry

theorem collinear_vectors (x : ℝ) :
  ∃ (k : ℝ), k ≠ 0 ∧ 
  (vector_b.1 - (vector_a x).1, vector_b.2 - (vector_a x).2) = 
  k • (3 * (vector_a x).1 + 2 * vector_b.1, 3 * (vector_a x).2 + 2 * vector_b.2) 
  → x = -3 := by sorry

end perpendicular_vectors_collinear_vectors_l1141_114137


namespace intersection_of_B_and_complement_of_A_l1141_114167

-- Define the universal set U
def U : Set Int := {-2, -1, 0, 1, 2}

-- Define set A
def A : Set Int := {x ∈ U | x^2 + x - 2 = 0}

-- Define set B
def B : Set Int := {0, -2}

-- Theorem statement
theorem intersection_of_B_and_complement_of_A :
  B ∩ (U \ A) = {0} := by sorry

end intersection_of_B_and_complement_of_A_l1141_114167


namespace volume_of_specific_prism_l1141_114140

/-- Right triangular prism ABC-A₁B₁C₁ -/
structure RightTriangularPrism where
  -- Base triangle
  AB : ℝ
  BC : ℝ
  AC : ℝ
  -- Circumscribed sphere
  sphereSurfaceArea : ℝ

/-- Volume of a right triangular prism -/
def prismVolume (p : RightTriangularPrism) : ℝ := sorry

theorem volume_of_specific_prism :
  let p : RightTriangularPrism := {
    AB := 2,
    BC := 2,
    AC := 2 * Real.sqrt 3,
    sphereSurfaceArea := 32 * Real.pi
  }
  prismVolume p = 4 * Real.sqrt 3 := by sorry

end volume_of_specific_prism_l1141_114140


namespace factorize_x_squared_minus_one_l1141_114139

theorem factorize_x_squared_minus_one (x : ℝ) : x^2 - 1 = (x + 1) * (x - 1) := by
  sorry

end factorize_x_squared_minus_one_l1141_114139


namespace sqrt_200_simplification_l1141_114119

theorem sqrt_200_simplification : Real.sqrt 200 = 10 * Real.sqrt 2 := by
  sorry

end sqrt_200_simplification_l1141_114119


namespace good_number_count_and_gcd_l1141_114183

def is_good_number (n : ℕ) : Prop :=
  n ≤ 2012 ∧ n % 9 = 6

theorem good_number_count_and_gcd :
  (∃ (S : Finset ℕ), (∀ n, n ∈ S ↔ is_good_number n) ∧ S.card = 223) ∧
  (∃ d : ℕ, d > 0 ∧ (∀ n, is_good_number n → d ∣ n) ∧
    ∀ m, m > 0 → (∀ n, is_good_number n → m ∣ n) → m ≤ d) :=
by sorry

end good_number_count_and_gcd_l1141_114183


namespace betty_lipstick_count_l1141_114116

/-- Represents an order with different items -/
structure Order where
  total_items : ℕ
  slipper_count : ℕ
  slipper_price : ℚ
  lipstick_price : ℚ
  hair_color_count : ℕ
  hair_color_price : ℚ
  total_paid : ℚ

/-- Calculates the number of lipstick pieces in an order -/
def lipstick_count (o : Order) : ℕ :=
  let slipper_cost := o.slipper_count * o.slipper_price
  let hair_color_cost := o.hair_color_count * o.hair_color_price
  let lipstick_cost := o.total_paid - slipper_cost - hair_color_cost
  (lipstick_cost / o.lipstick_price).num.toNat

/-- Betty's order satisfies the given conditions -/
def betty_order : Order :=
  { total_items := 18
  , slipper_count := 6
  , slipper_price := 5/2
  , lipstick_price := 5/4
  , hair_color_count := 8
  , hair_color_price := 3
  , total_paid := 44 }

theorem betty_lipstick_count : lipstick_count betty_order = 4 := by
  sorry

end betty_lipstick_count_l1141_114116


namespace garden_trees_l1141_114117

/-- The number of trees in a garden with given specifications -/
def num_trees (yard_length : ℕ) (tree_spacing : ℕ) : ℕ :=
  yard_length / tree_spacing + 1

/-- Theorem stating the number of trees in the garden -/
theorem garden_trees : num_trees 700 28 = 26 := by
  sorry

end garden_trees_l1141_114117


namespace darias_piggy_bank_problem_l1141_114100

/-- The problem of calculating Daria's initial piggy bank balance. -/
theorem darias_piggy_bank_problem
  (vacuum_cost : ℕ)
  (weekly_savings : ℕ)
  (weeks_to_save : ℕ)
  (h1 : vacuum_cost = 120)
  (h2 : weekly_savings = 10)
  (h3 : weeks_to_save = 10)
  (h4 : vacuum_cost = weekly_savings * weeks_to_save + initial_balance) :
  initial_balance = 20 :=
by
  sorry

#check darias_piggy_bank_problem

end darias_piggy_bank_problem_l1141_114100


namespace tangent_problems_l1141_114161

theorem tangent_problems (α : Real) (h : Real.tan α = 2) :
  (Real.tan (α + Real.pi/4) = -3) ∧
  (Real.sin (2*α) / (Real.sin α ^ 2 + Real.sin α * Real.cos α) = 2/3) := by
  sorry

end tangent_problems_l1141_114161


namespace inequality_proof_l1141_114193

theorem inequality_proof (a b : ℝ) (n : ℕ) 
  (h1 : a > 0) (h2 : b > 0) (h3 : a + b = 1) (h4 : n ≥ 2) :
  (3 / 2 : ℝ) < 1 / (a^n + 1) + 1 / (b^n + 1) ∧ 
  1 / (a^n + 1) + 1 / (b^n + 1) ≤ (2^(n+1) : ℝ) / (2^n + 1) := by
  sorry

end inequality_proof_l1141_114193


namespace max_value_of_z_l1141_114178

theorem max_value_of_z (x y : ℝ) (h1 : y ≥ x) (h2 : x + y ≤ 1) (h3 : y ≥ -1) :
  ∃ (z_max : ℝ), z_max = 1/2 ∧ ∀ z, z = 2*x - y → z ≤ z_max :=
by sorry

end max_value_of_z_l1141_114178


namespace zeros_sum_greater_than_2a_l1141_114169

/-- The function f(x) = ln x + a/x - 2 -/
noncomputable def f (a : ℝ) (x : ℝ) : ℝ := Real.log x + a / x - 2

/-- Theorem: If x₁ and x₂ are the two zeros of f(x) with x₁ < x₂, then x₁ + x₂ > 2a -/
theorem zeros_sum_greater_than_2a (a : ℝ) (x₁ x₂ : ℝ) 
  (h₁ : x₁ > 0) (h₂ : x₂ > 0) (h₃ : x₁ < x₂)
  (h₄ : f a x₁ = 0) (h₅ : f a x₂ = 0) :
  x₁ + x₂ > 2 * a := by
  sorry

end zeros_sum_greater_than_2a_l1141_114169


namespace external_tangency_intersection_two_points_l1141_114103

-- Define the circles
def C₁ (x y : ℝ) : Prop := x^2 + y^2 - 2*x - 2*y + 1 = 0
def C₂ (x y r : ℝ) : Prop := (x - 4)^2 + (y - 5)^2 = r^2

-- Define the center and radius of C₁
def center_C₁ : ℝ × ℝ := (1, 1)
def radius_C₁ : ℝ := 1

-- Define the center of C₂
def center_C₂ : ℝ × ℝ := (4, 5)

-- Define the distance between centers
def distance_between_centers : ℝ := 5

-- Theorem for external tangency
theorem external_tangency (r : ℝ) (hr : r > 0) :
  (∀ x y, C₁ x y → C₂ x y r → (x - 1)^2 + (y - 1)^2 = 1 ∧ (x - 4)^2 + (y - 5)^2 = r^2) →
  distance_between_centers = radius_C₁ + r →
  r = 4 :=
sorry

-- Theorem for intersection at two points
theorem intersection_two_points (r : ℝ) (hr : r > 0) :
  (∃ x₁ y₁ x₂ y₂, x₁ ≠ x₂ ∧ y₁ ≠ y₂ ∧ C₁ x₁ y₁ ∧ C₁ x₂ y₂ ∧ C₂ x₁ y₁ r ∧ C₂ x₂ y₂ r) →
  4 < r ∧ r < 6 :=
sorry

end external_tangency_intersection_two_points_l1141_114103


namespace inserted_eights_composite_l1141_114152

theorem inserted_eights_composite (n : ℕ) (h : n ≥ 2) :
  ∃ (a b : ℕ), a > 1 ∧ b > 1 ∧ (1880 * 10^n - 611) / 9 = a * b :=
sorry

end inserted_eights_composite_l1141_114152


namespace internet_cost_comparison_l1141_114159

/-- Cost calculation for dial-up internet access -/
def dialup_cost (hours : ℝ) : ℝ := 4.2 * hours

/-- Cost calculation for monthly subscription -/
def subscription_cost : ℝ := 130 - 25

/-- The number of hours where both methods cost the same -/
def equal_cost_hours : ℝ := 25

theorem internet_cost_comparison :
  /- Part 1: Prove that costs are equal at 25 hours -/
  dialup_cost equal_cost_hours = subscription_cost ∧
  /- Part 2: Prove that subscription is cheaper for 30 hours -/
  dialup_cost 30 > subscription_cost := by
  sorry

#check internet_cost_comparison

end internet_cost_comparison_l1141_114159


namespace bc_is_one_twelfth_of_ad_l1141_114174

/-- Given a line segment AD with points B and C on it, prove that BC is 1/12 of AD -/
theorem bc_is_one_twelfth_of_ad (A B C D : ℝ) : 
  (B ≤ C) →  -- B is before or at C on the line
  (C ≤ D) →  -- C is before or at D on the line
  (A ≤ B) →  -- A is before or at B on the line
  (B - A = 3 * (D - B)) →  -- AB is 3 times BD
  (C - A = 5 * (D - C)) →  -- AC is 5 times CD
  (C - B = (D - A) / 12) := by  -- BC is 1/12 of AD
sorry

end bc_is_one_twelfth_of_ad_l1141_114174


namespace connie_marbles_l1141_114186

/-- Calculates the remaining marbles after giving some away. -/
def remaining_marbles (initial : ℕ) (given_away : ℕ) : ℕ :=
  initial - given_away

/-- Proves that Connie has 3 marbles left after giving away 70 from her initial 73 marbles. -/
theorem connie_marbles : remaining_marbles 73 70 = 3 := by
  sorry

end connie_marbles_l1141_114186


namespace line_through_center_chord_length_l1141_114108

-- Define the circle C
def circle_C (x y : ℝ) : Prop := (x - 1)^2 + y^2 = 11/2

-- Define point P
def point_P : ℝ × ℝ := (2, 2)

-- Define a line passing through P
def line_through_P (k : ℝ) (x y : ℝ) : Prop := y - point_P.2 = k * (x - point_P.1)

-- Theorem 1: Equation of line passing through P and center of circle
theorem line_through_center : 
  ∃ (x y : ℝ), line_through_P 2 x y ∧ 2*x - y - 2 = 0 := by sorry

-- Theorem 2: Length of chord AB when line slope is 1
theorem chord_length : 
  ∃ (A B : ℝ × ℝ), 
    (circle_C A.1 A.2) ∧ 
    (circle_C B.1 B.2) ∧ 
    (line_through_P 1 A.1 A.2) ∧ 
    (line_through_P 1 B.1 B.2) ∧ 
    ((A.1 - B.1)^2 + (A.2 - B.2)^2 = 20) := by sorry

end line_through_center_chord_length_l1141_114108


namespace range_of_expression_l1141_114181

theorem range_of_expression (x y z : ℝ) 
  (non_neg_x : x ≥ 0) (non_neg_y : y ≥ 0) (non_neg_z : z ≥ 0)
  (sum_one : x + y + z = 1) :
  -1/8 ≤ (z - x) * (z - y) ∧ (z - x) * (z - y) ≤ 1 :=
sorry

end range_of_expression_l1141_114181


namespace max_value_theorem_min_value_theorem_l1141_114149

-- Statement 1
theorem max_value_theorem (x : ℝ) (h : x < 1/2) :
  ∃ (max_val : ℝ), max_val = -1 ∧ 
  ∀ y : ℝ, y < 1/2 → 2*y + 1/(2*y - 1) ≤ max_val :=
sorry

-- Statement 2
theorem min_value_theorem (a b : ℝ) (ha : a > 0) (hb : b > 0) 
  (h : 1/a + 2/b = 1) :
  ∃ (min_val : ℝ), min_val = 3 + 2*Real.sqrt 2 ∧
  a*(b - 1) ≥ min_val :=
sorry

end max_value_theorem_min_value_theorem_l1141_114149


namespace doll_production_time_l1141_114126

/-- Represents the production details of dolls and accessories in a factory --/
structure DollProduction where
  total_dolls : ℕ
  accessories_per_doll : ℕ
  accessory_time : ℕ
  total_operation_time : ℕ

/-- Calculates the time required to make each doll --/
def time_per_doll (prod : DollProduction) : ℕ :=
  (prod.total_operation_time - prod.total_dolls * prod.accessories_per_doll * prod.accessory_time) / prod.total_dolls

/-- Theorem stating that the time to make each doll is 45 seconds --/
theorem doll_production_time (prod : DollProduction) 
  (h1 : prod.total_dolls = 12000)
  (h2 : prod.accessories_per_doll = 11)
  (h3 : prod.accessory_time = 10)
  (h4 : prod.total_operation_time = 1860000) :
  time_per_doll prod = 45 := by
  sorry

#eval time_per_doll { total_dolls := 12000, accessories_per_doll := 11, accessory_time := 10, total_operation_time := 1860000 }

end doll_production_time_l1141_114126


namespace greatest_divisor_with_remainders_l1141_114128

theorem greatest_divisor_with_remainders (a b r1 r2 : ℕ) (h1 : a = 60) (h2 : b = 190) (h3 : r1 = 6) (h4 : r2 = 10) :
  Nat.gcd (a - r1) (b - r2) = 18 :=
by sorry

end greatest_divisor_with_remainders_l1141_114128


namespace dave_initial_tickets_l1141_114146

/-- The number of tickets Dave spent on a stuffed tiger -/
def spent_tickets : ℕ := 43

/-- The number of tickets Dave had left after the purchase -/
def remaining_tickets : ℕ := 55

/-- The initial number of tickets Dave had -/
def initial_tickets : ℕ := spent_tickets + remaining_tickets

theorem dave_initial_tickets : initial_tickets = 98 := by
  sorry

end dave_initial_tickets_l1141_114146


namespace min_c_over_d_l1141_114130

theorem min_c_over_d (x C D : ℝ) (hx : x ≠ 0) (hC : C > 0) (hD : D > 0)
  (hxC : x^4 + 1/x^4 = C) (hxD : x^2 - 1/x^2 = D) :
  ∃ (m : ℝ), (∀ x' C' D', x' ≠ 0 → C' > 0 → D' > 0 → 
    x'^4 + 1/x'^4 = C' → x'^2 - 1/x'^2 = D' → C' / D' ≥ m) ∧ 
  (∃ x₀ C₀ D₀, x₀ ≠ 0 ∧ C₀ > 0 ∧ D₀ > 0 ∧ 
    x₀^4 + 1/x₀^4 = C₀ ∧ x₀^2 - 1/x₀^2 = D₀ ∧ C₀ / D₀ = m) ∧
  m = 2 * Real.sqrt 2 :=
sorry

end min_c_over_d_l1141_114130


namespace factorization_a_squared_minus_4a_l1141_114162

theorem factorization_a_squared_minus_4a (a : ℝ) : a^2 - 4*a = a*(a - 4) := by
  sorry

end factorization_a_squared_minus_4a_l1141_114162


namespace imaginary_power_sum_l1141_114142

-- Define the imaginary unit i
def i : ℂ := Complex.I

-- State the theorem
theorem imaginary_power_sum : i^23 + i^75 = -2*i := by sorry

end imaginary_power_sum_l1141_114142


namespace q_satisfies_conditions_l1141_114164

/-- The quadratic polynomial that satisfies the given conditions -/
def q (x : ℚ) : ℚ := (6/5) * x^2 - (4/5) * x + 8/5

/-- Theorem stating that q(x) satisfies the required conditions -/
theorem q_satisfies_conditions :
  q (-2) = 8 ∧ q 1 = 2 ∧ q 3 = 10 := by
  sorry

end q_satisfies_conditions_l1141_114164


namespace tomato_bean_percentage_is_50_l1141_114144

/-- Represents the number of cans of each ingredient in a normal batch of chili -/
structure ChiliBatch where
  chilis : ℕ
  beans : ℕ
  tomatoes : ℕ

/-- Defines a normal batch of chili -/
def normal_batch : ChiliBatch :=
  { chilis := 1, beans := 2, tomatoes := 3 }

/-- Calculates the total number of cans in a batch -/
def total_cans (batch : ChiliBatch) : ℕ :=
  batch.chilis + batch.beans + batch.tomatoes

/-- States that a quadruple batch requires 24 cans -/
axiom quadruple_batch_cans : 4 * (total_cans normal_batch) = 24

/-- Calculates the percentage of more tomatoes than beans -/
def tomato_bean_percentage (batch : ChiliBatch) : ℚ :=
  (batch.tomatoes - batch.beans : ℚ) / batch.beans * 100

/-- Theorem stating that the percentage of more tomatoes than beans is 50% -/
theorem tomato_bean_percentage_is_50 : 
  tomato_bean_percentage normal_batch = 50 := by sorry

end tomato_bean_percentage_is_50_l1141_114144


namespace cylinder_cross_section_area_l1141_114179

/-- The area of the cross-section of a cylinder intersected by a plane -/
theorem cylinder_cross_section_area 
  (r : ℝ) -- radius of the cylinder base
  (α : ℝ) -- angle between the intersecting plane and the base plane
  (h₁ : r > 0) -- radius is positive
  (h₂ : 0 < α ∧ α < π / 2) -- angle is between 0 and π/2 (exclusive)
  : ∃ (A : ℝ), A = π * r^2 / Real.cos α :=
sorry

end cylinder_cross_section_area_l1141_114179


namespace no_real_solutions_l1141_114154

/-- The quadratic equation x^2 + 2x + 3 = 0 has no real solutions -/
theorem no_real_solutions : ¬∃ (x : ℝ), x^2 + 2*x + 3 = 0 := by
  sorry

end no_real_solutions_l1141_114154


namespace bedroom_size_calculation_l1141_114188

theorem bedroom_size_calculation (total_area : ℝ) (difference : ℝ) :
  total_area = 300 →
  difference = 60 →
  ∃ (smaller_room : ℝ),
    smaller_room + (smaller_room + difference) = total_area ∧
    smaller_room = 120 :=
by
  sorry

end bedroom_size_calculation_l1141_114188


namespace abs_sqrt3_minus_2_l1141_114110

theorem abs_sqrt3_minus_2 : |Real.sqrt 3 - 2| = 2 - Real.sqrt 3 := by
  sorry

end abs_sqrt3_minus_2_l1141_114110


namespace movie_attendance_l1141_114131

/-- The number of people that can ride in each car -/
def people_per_car : ℕ := 6

/-- The number of cars needed -/
def cars_needed : ℕ := 18

/-- The total number of people going to the movie -/
def total_people : ℕ := people_per_car * cars_needed

theorem movie_attendance : total_people = 108 := by
  sorry

end movie_attendance_l1141_114131


namespace train_tunnel_time_l1141_114195

/-- Calculates the time taken for a train to pass through a tunnel -/
theorem train_tunnel_time (train_length : ℝ) (pole_passing_time : ℝ) (tunnel_length : ℝ) :
  train_length = 500 →
  pole_passing_time = 20 →
  tunnel_length = 500 →
  (train_length + tunnel_length) / (train_length / pole_passing_time) = 40 := by
  sorry


end train_tunnel_time_l1141_114195


namespace m_range_l1141_114158

-- Define propositions P and Q as functions of m
def P (m : ℝ) : Prop := ∀ x : ℝ, x^2 + (m-3)*x + 1 ≠ 0

def Q (m : ℝ) : Prop := ∃ a b : ℝ, a > b ∧ a^2 + b^2 = m-1 ∧
  ∀ x y : ℝ, x^2 + y^2/(m-1) = 1 ↔ (x/a)^2 + (y/b)^2 = 1

-- Define the theorem
theorem m_range :
  (∀ m : ℝ, (¬(P m) → False) ∧ ((P m ∧ Q m) → False)) →
  {m : ℝ | 1 < m ∧ m ≤ 2} = {m : ℝ | ∃ x : ℝ, m = x ∧ 1 < x ∧ x ≤ 2} :=
by sorry

end m_range_l1141_114158


namespace square_root_equality_l1141_114176

theorem square_root_equality (a b : ℝ) : 
  (a^2 + b^2)^2 = (4*a - 6*b + 13)^2 → (a^2 + b^2)^2 = 169 := by
sorry

end square_root_equality_l1141_114176


namespace complex_fraction_equality_l1141_114191

theorem complex_fraction_equality : 2 + 1 / (2 + 1 / (2 + 1 / 3)) = 41 / 17 := by
  sorry

end complex_fraction_equality_l1141_114191


namespace function_monotonicity_l1141_114173

/-- f is an odd function -/
def IsOdd (f : ℝ → ℝ) : Prop := ∀ x, f (-x) = -f x

/-- g is an even function -/
def IsEven (g : ℝ → ℝ) : Prop := ∀ x, g (-x) = g x

/-- The main theorem -/
theorem function_monotonicity (f g : ℝ → ℝ) 
    (h_odd : IsOdd f) (h_even : IsEven g) 
    (h_sum : ∀ x, f x + g x = 3^x) :
    ∀ a b, a > b → f a > f b := by
  sorry

end function_monotonicity_l1141_114173


namespace sixth_term_is_three_l1141_114121

/-- An arithmetic progression with specific properties -/
structure ArithmeticProgression where
  a : ℕ → ℝ
  is_arithmetic : ∀ n, a (n + 1) - a n = a 1 - a 0
  sum_first_three : a 0 + a 1 + a 2 = 168
  diff_2_5 : a 1 - a 4 = 42

/-- The 6th term of the arithmetic progression is 3 -/
theorem sixth_term_is_three (ap : ArithmeticProgression) : ap.a 5 = 3 := by
  sorry

end sixth_term_is_three_l1141_114121


namespace isosceles_triangle_perimeter_l1141_114171

-- Define the quadratic equation
def quadratic_equation (x : ℝ) : Prop := x^2 - 9*x + 18 = 0

-- Define the roots of the equation
def root1 : ℝ := 3
def root2 : ℝ := 6

-- Define the isosceles triangle formed by the roots
def isosceles_triangle (a b : ℝ) : Prop :=
  (quadratic_equation a ∧ quadratic_equation b) ∧
  ((a = root1 ∧ b = root2) ∨ (a = root2 ∧ b = root1))

-- State the theorem
theorem isosceles_triangle_perimeter :
  ∀ a b : ℝ, isosceles_triangle a b → a + 2*b = 15 :=
by sorry

end isosceles_triangle_perimeter_l1141_114171


namespace complement_of_A_l1141_114106

def U : Set Nat := {2, 4, 6, 8, 10}
def A : Set Nat := {2, 6, 8}

theorem complement_of_A : (Aᶜ : Set Nat) = {4, 10} := by
  sorry

end complement_of_A_l1141_114106
