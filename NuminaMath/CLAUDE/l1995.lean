import Mathlib

namespace NUMINAMATH_CALUDE_monthly_calendar_sum_l1995_199568

theorem monthly_calendar_sum : ∃ (x : ℕ), 
  8 ≤ x ∧ x ≤ 24 ∧ 
  ∃ (k : ℕ), (x - 7) + x + (x + 7) = 3 * k ∧ 
  (x - 7) + x + (x + 7) = 33 := by
  sorry

end NUMINAMATH_CALUDE_monthly_calendar_sum_l1995_199568


namespace NUMINAMATH_CALUDE_seating_theorem_l1995_199523

/-- The number of ways to seat 9 children (5 sons and 4 daughters) in a row
    such that at least two girls are next to each other. -/
def seating_arrangements (total : ℕ) (sons : ℕ) (daughters : ℕ) : ℕ :=
  Nat.factorial total - (Nat.factorial sons * Nat.factorial daughters)

theorem seating_theorem :
  seating_arrangements 9 5 4 = 359400 := by
  sorry

end NUMINAMATH_CALUDE_seating_theorem_l1995_199523


namespace NUMINAMATH_CALUDE_parallelogram_area_theorem_l1995_199580

/-- Given two vectors a and b in a vector space, the area_parallelogram function
    computes the area of the parallelogram generated by these vectors. -/
def area_parallelogram (a b : V) : ℝ := sorry

variable (V : Type) [AddCommGroup V] [Module ℝ V]
variable (a b : V)

/-- The theorem states that if the area of the parallelogram generated by vectors a and b
    is 15, then the area of the parallelogram generated by vectors 3a + 4b and 2a - 6b is 390. -/
theorem parallelogram_area_theorem (h : area_parallelogram a b = 15) :
  area_parallelogram (3 • a + 4 • b) (2 • a - 6 • b) = 390 :=
sorry

end NUMINAMATH_CALUDE_parallelogram_area_theorem_l1995_199580


namespace NUMINAMATH_CALUDE_average_marathons_rounded_l1995_199538

def marathons : List ℕ := [1, 2, 3, 4, 5]
def members : List ℕ := [6, 5, 3, 2, 3]

def total_marathons : ℕ := (List.zip marathons members).map (λ (m, n) => m * n) |>.sum
def total_members : ℕ := members.sum

def average : ℚ := total_marathons / total_members

theorem average_marathons_rounded :
  (average + 1/2).floor = 3 := by
  sorry

end NUMINAMATH_CALUDE_average_marathons_rounded_l1995_199538


namespace NUMINAMATH_CALUDE_movie_theater_seats_l1995_199513

theorem movie_theater_seats (total_seats : ℕ) (num_sections : ℕ) (seats_per_section : ℕ) :
  total_seats = 270 → num_sections = 9 → total_seats = num_sections * seats_per_section →
  seats_per_section = 30 := by
  sorry

end NUMINAMATH_CALUDE_movie_theater_seats_l1995_199513


namespace NUMINAMATH_CALUDE_rectangular_plot_length_difference_l1995_199585

theorem rectangular_plot_length_difference (length breadth : ℝ) : 
  length = 62 →
  length > breadth →
  2 * (length + breadth) * 26.5 = 5300 →
  length - breadth = 24 := by
sorry

end NUMINAMATH_CALUDE_rectangular_plot_length_difference_l1995_199585


namespace NUMINAMATH_CALUDE_inequality_and_minimum_value_l1995_199544

theorem inequality_and_minimum_value (a b m n : ℝ) (x : ℝ) 
  (ha : a > 0) (hb : b > 0) (hm : m > 0) (hn : n > 0) 
  (hx : 0 < x ∧ x < 1/2) : 
  (m^2 / a + n^2 / b ≥ (m + n)^2 / (a + b)) ∧
  (∃ (min_val : ℝ), min_val = 25 ∧ 
    ∀ y, 0 < y ∧ y < 1/2 → 2/y + 9/(1-2*y) ≥ min_val) ∧
  (2/((1:ℝ)/5) + 9/(1-2*((1:ℝ)/5)) = 25) := by
  sorry

end NUMINAMATH_CALUDE_inequality_and_minimum_value_l1995_199544


namespace NUMINAMATH_CALUDE_total_pears_picked_l1995_199558

theorem total_pears_picked (jason_pears keith_pears mike_pears : ℕ)
  (h1 : jason_pears = 46)
  (h2 : keith_pears = 47)
  (h3 : mike_pears = 12) :
  jason_pears + keith_pears + mike_pears = 105 := by
  sorry

end NUMINAMATH_CALUDE_total_pears_picked_l1995_199558


namespace NUMINAMATH_CALUDE_parabola_focus_directrix_distance_l1995_199509

/-- A parabola is defined by its equation y² = 2x -/
def Parabola := {(x, y) : ℝ × ℝ | y^2 = 2*x}

/-- The distance from the focus to the directrix of a parabola y² = 2x is 1 -/
theorem parabola_focus_directrix_distance :
  ∃ (f d : ℝ × ℝ), f ∈ Parabola ∧ (∀ (p : ℝ × ℝ), p ∈ Parabola → dist p d = dist p f) ∧ dist f d = 1 :=
sorry

end NUMINAMATH_CALUDE_parabola_focus_directrix_distance_l1995_199509


namespace NUMINAMATH_CALUDE_possible_values_of_a_l1995_199521

def A (a : ℝ) := {x : ℝ | 0 < x ∧ x < a}
def B := {x : ℝ | 1 < x ∧ x < 2}

theorem possible_values_of_a (a : ℝ) :
  (A a).Nonempty ∧ B ⊆ (Aᶜ a) ↔ 0 < a ∧ a ≤ 1 :=
sorry

end NUMINAMATH_CALUDE_possible_values_of_a_l1995_199521


namespace NUMINAMATH_CALUDE_triangle_sides_from_heights_l1995_199586

theorem triangle_sides_from_heights (h_a h_b h_c A : ℝ) (h_positive : h_a > 0 ∧ h_b > 0 ∧ h_c > 0) (h_area : A > 0) :
  ∃ (a b c : ℝ), a > 0 ∧ b > 0 ∧ c > 0 ∧ 
    A = (1/2) * a * h_a ∧
    A = (1/2) * b * h_b ∧
    A = (1/2) * c * h_c :=
sorry


end NUMINAMATH_CALUDE_triangle_sides_from_heights_l1995_199586


namespace NUMINAMATH_CALUDE_wall_volume_l1995_199563

/-- Proves that the volume of a rectangular wall with given dimensions is 6804 cubic units -/
theorem wall_volume : 
  ∀ (width height length : ℕ),
  width = 3 →
  height = 6 * width →
  length = 7 * height →
  width * height * length = 6804 := by
  sorry

end NUMINAMATH_CALUDE_wall_volume_l1995_199563


namespace NUMINAMATH_CALUDE_points_per_player_l1995_199546

theorem points_per_player (total_points : ℕ) (num_players : ℕ) 
  (h1 : total_points = 18) (h2 : num_players = 9) :
  total_points / num_players = 2 := by
  sorry

end NUMINAMATH_CALUDE_points_per_player_l1995_199546


namespace NUMINAMATH_CALUDE_cubic_roots_problem_l1995_199502

theorem cubic_roots_problem (u v c d : ℝ) : 
  (∃ w, {u, v, w} = {x | x^3 + c*x + d = 0}) ∧
  (∃ w', {u+5, v-4, w'} = {x | x^3 + c*x + (d+300) = 0}) →
  d = -4 ∨ d = 6 := by
sorry

end NUMINAMATH_CALUDE_cubic_roots_problem_l1995_199502


namespace NUMINAMATH_CALUDE_mosquitoes_to_cause_death_l1995_199552

/-- Represents the number of drops of blood sucked by a mosquito of a given species -/
def drops_per_species : Fin 3 → ℕ
  | 0 => 20  -- Species A
  | 1 => 25  -- Species B
  | 2 => 30  -- Species C
  | _ => 0   -- This case is unreachable, but needed for completeness

/-- The number of drops of blood per liter -/
def drops_per_liter : ℕ := 5000

/-- The number of liters of blood loss that causes death -/
def lethal_blood_loss : ℕ := 3

/-- The total number of drops of blood that cause death -/
def lethal_drops : ℕ := lethal_blood_loss * drops_per_liter

/-- The theorem stating the number of mosquitoes of each species required to cause death -/
theorem mosquitoes_to_cause_death :
  ∃ n : ℕ, n > 0 ∧ 
  (n * drops_per_species 0 + n * drops_per_species 1 + n * drops_per_species 2 = lethal_drops) ∧
  n = 200 := by
  sorry

end NUMINAMATH_CALUDE_mosquitoes_to_cause_death_l1995_199552


namespace NUMINAMATH_CALUDE_chicken_rabbit_equations_l1995_199555

/-- Represents the "chicken-rabbit in the same cage" problem --/
def chicken_rabbit_problem (x y : ℕ) : Prop :=
  let total_heads : ℕ := 35
  let total_feet : ℕ := 94
  let chicken_feet : ℕ := 2
  let rabbit_feet : ℕ := 4
  (x + y = total_heads) ∧ (chicken_feet * x + rabbit_feet * y = total_feet)

/-- Proves that the system of equations correctly represents the problem --/
theorem chicken_rabbit_equations : 
  ∀ x y : ℕ, chicken_rabbit_problem x y ↔ (x + y = 35 ∧ 2*x + 4*y = 94) := by
  sorry

end NUMINAMATH_CALUDE_chicken_rabbit_equations_l1995_199555


namespace NUMINAMATH_CALUDE_point_movement_l1995_199572

def Point := ℝ × ℝ

def moveUp (p : Point) (units : ℝ) : Point :=
  (p.1, p.2 + units)

def moveRight (p : Point) (units : ℝ) : Point :=
  (p.1 + units, p.2)

theorem point_movement :
  let original : Point := (-2, 3)
  (moveUp original 2 = (-2, 5)) ∧
  (moveRight original 2 = (0, 3)) := by
  sorry

end NUMINAMATH_CALUDE_point_movement_l1995_199572


namespace NUMINAMATH_CALUDE_prob_at_least_one_black_correct_l1995_199505

/-- The number of white balls in the bag -/
def white_balls : ℕ := 3

/-- The number of black balls in the bag -/
def black_balls : ℕ := 2

/-- The total number of balls in the bag -/
def total_balls : ℕ := white_balls + black_balls

/-- The number of balls drawn from the bag -/
def drawn_balls : ℕ := 2

/-- The probability of drawing at least one black ball -/
def prob_at_least_one_black : ℚ := 7 / 10

theorem prob_at_least_one_black_correct :
  (1 : ℚ) - (Nat.choose white_balls drawn_balls : ℚ) / (Nat.choose total_balls drawn_balls : ℚ) = prob_at_least_one_black :=
by sorry

end NUMINAMATH_CALUDE_prob_at_least_one_black_correct_l1995_199505


namespace NUMINAMATH_CALUDE_sum_of_divisors_prime_power_sum_of_divisors_two_prime_powers_sum_of_divisors_three_prime_powers_l1995_199590

-- Define the sum of divisors function
def sumOfDivisors (n : ℕ) : ℕ := sorry

-- Theorem for p^α
theorem sum_of_divisors_prime_power (p : ℕ) (α : ℕ) (hp : Prime p) :
  sumOfDivisors (p^α) = (p^(α+1) - 1) / (p - 1) := by sorry

-- Theorem for p^α q^β
theorem sum_of_divisors_two_prime_powers (p q : ℕ) (α β : ℕ) (hp : Prime p) (hq : Prime q) (hpq : p ≠ q) :
  sumOfDivisors (p^α * q^β) = ((p^(α+1) - 1) / (p - 1)) * ((q^(β+1) - 1) / (q - 1)) := by sorry

-- Theorem for p^α q^β r^γ
theorem sum_of_divisors_three_prime_powers (p q r : ℕ) (α β γ : ℕ) (hp : Prime p) (hq : Prime q) (hr : Prime r)
  (hpq : p ≠ q) (hpr : p ≠ r) (hqr : q ≠ r) :
  sumOfDivisors (p^α * q^β * r^γ) = ((p^(α+1) - 1) / (p - 1)) * ((q^(β+1) - 1) / (q - 1)) * ((r^(γ+1) - 1) / (r - 1)) := by sorry

end NUMINAMATH_CALUDE_sum_of_divisors_prime_power_sum_of_divisors_two_prime_powers_sum_of_divisors_three_prime_powers_l1995_199590


namespace NUMINAMATH_CALUDE_function_increasing_on_interval_l1995_199539

/-- The function f(x) = 3x - x^3 is monotonically increasing on the interval [-1, 1]. -/
theorem function_increasing_on_interval (x : ℝ) :
  (∀ x₁ x₂ : ℝ, -1 ≤ x₁ ∧ x₁ < x₂ ∧ x₂ ≤ 1 → (3 * x₁ - x₁^3) < (3 * x₂ - x₂^3)) :=
by sorry

end NUMINAMATH_CALUDE_function_increasing_on_interval_l1995_199539


namespace NUMINAMATH_CALUDE_x_range_l1995_199570

theorem x_range (x : ℝ) (h1 : x^2 - 8*x + 12 < 0) (h2 : x > 3) : 3 < x ∧ x < 6 := by
  sorry

end NUMINAMATH_CALUDE_x_range_l1995_199570


namespace NUMINAMATH_CALUDE_range_of_a_range_of_m_l1995_199532

-- Define the function f
def f (x : ℝ) : ℝ := |2*x + 1| + |2*x - 3|

-- Theorem for part I
theorem range_of_a : 
  {a : ℝ | ∃ x, f x < |1 - 2*a|} = {a : ℝ | a < -3/2 ∨ a > 5/2} :=
sorry

-- Theorem for part II
theorem range_of_m :
  {m : ℝ | ∃ t, t^2 - 2*Real.sqrt 6*t + f m = 0} = {m : ℝ | -1 ≤ m ∧ m ≤ 2} :=
sorry

end NUMINAMATH_CALUDE_range_of_a_range_of_m_l1995_199532


namespace NUMINAMATH_CALUDE_total_pencil_length_l1995_199512

/-- The length of Isha's first pencil in cubes -/
def first_pencil_cubes : ℕ := 12

/-- The length of each cube in Isha's first pencil in centimeters -/
def first_pencil_cube_length : ℚ := 3/2

/-- The length of the second pencil in cubes -/
def second_pencil_cubes : ℕ := 13

/-- The length of each cube in the second pencil in centimeters -/
def second_pencil_cube_length : ℚ := 17/10

/-- The total length of both pencils in centimeters -/
def total_length : ℚ := first_pencil_cubes * first_pencil_cube_length + 
                        second_pencil_cubes * second_pencil_cube_length

theorem total_pencil_length : total_length = 401/10 := by
  sorry

end NUMINAMATH_CALUDE_total_pencil_length_l1995_199512


namespace NUMINAMATH_CALUDE_total_third_graders_l1995_199528

/-- The number of third grade girl students -/
def girl_students : ℕ := 57

/-- The number of third grade boy students -/
def boy_students : ℕ := 66

/-- The total number of third grade students -/
def total_students : ℕ := girl_students + boy_students

/-- Theorem stating that the total number of third grade students is 123 -/
theorem total_third_graders : total_students = 123 := by
  sorry

end NUMINAMATH_CALUDE_total_third_graders_l1995_199528


namespace NUMINAMATH_CALUDE_visitor_difference_l1995_199595

/-- The number of paintings in Buckingham Palace -/
def paintings : ℕ := 39

/-- The number of visitors on the current day -/
def visitors_current : ℕ := 661

/-- The number of visitors on the previous day -/
def visitors_previous : ℕ := 600

/-- Theorem: The difference in visitors between the current day and the previous day is 61 -/
theorem visitor_difference : visitors_current - visitors_previous = 61 := by
  sorry

end NUMINAMATH_CALUDE_visitor_difference_l1995_199595


namespace NUMINAMATH_CALUDE_dwarf_attire_comparison_l1995_199516

/-- Represents the problem of comparing dwarf groups based on their attire. -/
theorem dwarf_attire_comparison :
  let total_dwarves : ℕ := 25
  let dwarves_without_hats : ℕ := 12
  let barefoot_dwarves : ℕ := 5
  let dwarves_with_hats := total_dwarves - dwarves_without_hats
  let dwarves_with_shoes := total_dwarves - barefoot_dwarves
  let dwarves_with_shoes_no_hat := dwarves_with_shoes - dwarves_with_hats
  dwarves_with_hats = dwarves_with_shoes_no_hat + 6 :=
by
  sorry


end NUMINAMATH_CALUDE_dwarf_attire_comparison_l1995_199516


namespace NUMINAMATH_CALUDE_convex_polygon_30_sides_diagonals_l1995_199550

/-- The number of diagonals in a convex polygon with n sides -/
def num_diagonals (n : ℕ) : ℕ := n * (n - 3) / 2

/-- Theorem: A convex polygon with 30 sides has 405 diagonals -/
theorem convex_polygon_30_sides_diagonals :
  num_diagonals 30 = 405 := by
  sorry

end NUMINAMATH_CALUDE_convex_polygon_30_sides_diagonals_l1995_199550


namespace NUMINAMATH_CALUDE_right_triangle_leg_sum_l1995_199597

theorem right_triangle_leg_sum (a b c : ℝ) : 
  a > 0 → b > 0 → c > 0 →  -- positive lengths
  b = a + 2 →              -- one leg is 2 units longer
  a^2 + b^2 = c^2 →        -- Pythagorean theorem
  c = 29 →                 -- hypotenuse is 29 units
  a + b = 40 :=            -- sum of legs is 40
by sorry

end NUMINAMATH_CALUDE_right_triangle_leg_sum_l1995_199597


namespace NUMINAMATH_CALUDE_sector_area_l1995_199537

theorem sector_area (circle_area : ℝ) (sector_angle : ℝ) : 
  circle_area = 9 * Real.pi →
  sector_angle = 120 →
  (sector_angle / 360) * circle_area = 3 * Real.pi :=
by sorry

end NUMINAMATH_CALUDE_sector_area_l1995_199537


namespace NUMINAMATH_CALUDE_orange_juice_proportion_l1995_199540

theorem orange_juice_proportion (oranges : ℝ) (quarts : ℝ) :
  oranges / quarts = 36 / 48 →
  quarts = 6 →
  oranges = 4.5 := by
  sorry

end NUMINAMATH_CALUDE_orange_juice_proportion_l1995_199540


namespace NUMINAMATH_CALUDE_average_of_abc_l1995_199577

theorem average_of_abc (A B C : ℚ) 
  (eq1 : 2002 * C + 4004 * A = 8008)
  (eq2 : 3003 * B - 5005 * A = 7007) : 
  (A + B + C) / 3 = 22 / 9 := by sorry

end NUMINAMATH_CALUDE_average_of_abc_l1995_199577


namespace NUMINAMATH_CALUDE_surface_area_cube_with_corners_removed_l1995_199574

/-- Represents the dimensions of a cube in centimeters -/
structure CubeDimensions where
  length : ℝ
  width : ℝ
  height : ℝ

/-- Calculates the surface area of a cube with given dimensions -/
def cubeSurfaceArea (d : CubeDimensions) : ℝ :=
  6 * d.length * d.width

/-- Calculates the surface area of a cube with corners removed -/
def cubeWithCornersRemovedSurfaceArea (originalCube : CubeDimensions) (removedCorner : CubeDimensions) : ℝ :=
  cubeSurfaceArea originalCube

/-- Theorem stating that the surface area of a 4x4x4 cube with 1x1x1 corners removed is 96 cm² -/
theorem surface_area_cube_with_corners_removed :
  let originalCube : CubeDimensions := ⟨4, 4, 4⟩
  let removedCorner : CubeDimensions := ⟨1, 1, 1⟩
  cubeWithCornersRemovedSurfaceArea originalCube removedCorner = 96 := by
  sorry

end NUMINAMATH_CALUDE_surface_area_cube_with_corners_removed_l1995_199574


namespace NUMINAMATH_CALUDE_player_a_winning_strategy_l1995_199547

/-- The game board represented as a 3x3 matrix -/
def GameBoard : Matrix (Fin 3) (Fin 3) ℕ :=
  !![7, 8, 9;
     4, 5, 6;
     1, 2, 3]

/-- Checks if two numbers are in the same row or column on the game board -/
def inSameRowOrCol (a b : ℕ) : Prop :=
  ∃ i j k : Fin 3, (GameBoard i j = a ∧ GameBoard i k = b) ∨
                   (GameBoard j i = a ∧ GameBoard k i = b)

/-- Represents a valid move in the game -/
structure Move where
  number : ℕ
  valid : number ≥ 1 ∧ number ≤ 9

/-- Represents the game state -/
structure GameState where
  moves : List Move
  total : ℕ
  lastMove : Move

/-- Checks if a move is valid given the current game state -/
def isValidMove (state : GameState) (move : Move) : Prop :=
  move.number ≠ state.lastMove.number ∧
  inSameRowOrCol move.number state.lastMove.number ∧
  state.total + move.number ≤ 30

/-- Represents a winning strategy for Player A -/
def WinningStrategy :=
  ∃ (firstMove : Move),
    ∀ (b1 : Move),
      ∃ (a2 : Move),
        ∀ (b2 : Move),
          ∃ (a3 : Move),
            (isValidMove ⟨[firstMove], firstMove.number, firstMove⟩ b1 →
             isValidMove ⟨[b1, firstMove], firstMove.number + b1.number, b1⟩ a2 →
             isValidMove ⟨[a2, b1, firstMove], firstMove.number + b1.number + a2.number, a2⟩ b2 →
             isValidMove ⟨[b2, a2, b1, firstMove], firstMove.number + b1.number + a2.number + b2.number, b2⟩ a3) ∧
            (firstMove.number + b1.number + a2.number + b2.number + a3.number = 30)

theorem player_a_winning_strategy : WinningStrategy := sorry

end NUMINAMATH_CALUDE_player_a_winning_strategy_l1995_199547


namespace NUMINAMATH_CALUDE_min_value_of_roots_squared_difference_l1995_199515

theorem min_value_of_roots_squared_difference (a : ℝ) (m n : ℝ) 
  (h1 : a ≥ 1)
  (h2 : m^2 - 2*a*m + 1 = 0)
  (h3 : n^2 - 2*a*n + 1 = 0) :
  ∃ (k : ℝ), k = (m - 1)^2 + (n - 1)^2 ∧ k ≥ 0 ∧ ∀ (x : ℝ), x = (m - 1)^2 + (n - 1)^2 → x ≥ k :=
by sorry

end NUMINAMATH_CALUDE_min_value_of_roots_squared_difference_l1995_199515


namespace NUMINAMATH_CALUDE_perfect_square_condition_l1995_199554

theorem perfect_square_condition (a b : ℕ+) (h_b_odd : Odd b.val) 
  (h_int : ∃ k : ℤ, ((a.val + b.val)^2 + 4*a.val : ℤ) = k * (a.val * b.val)) :
  ∃ n : ℕ+, a = n^2 := by
sorry

end NUMINAMATH_CALUDE_perfect_square_condition_l1995_199554


namespace NUMINAMATH_CALUDE_pole_length_reduction_l1995_199569

theorem pole_length_reduction (original_length : ℝ) (reduction_percentage : ℝ) (new_length : ℝ) :
  original_length = 20 →
  reduction_percentage = 30 →
  new_length = original_length * (1 - reduction_percentage / 100) →
  new_length = 14 :=
by sorry

end NUMINAMATH_CALUDE_pole_length_reduction_l1995_199569


namespace NUMINAMATH_CALUDE_profit_per_meter_l1995_199575

/-- Given a trader selling cloth, calculate the profit per meter. -/
theorem profit_per_meter (total_profit : ℝ) (total_meters : ℝ) (h1 : total_profit = 1400) (h2 : total_meters = 40) :
  total_profit / total_meters = 35 := by
sorry

end NUMINAMATH_CALUDE_profit_per_meter_l1995_199575


namespace NUMINAMATH_CALUDE_sqrt_product_equality_l1995_199592

theorem sqrt_product_equality : Real.sqrt 2 * Real.sqrt 3 = Real.sqrt 6 := by
  sorry

end NUMINAMATH_CALUDE_sqrt_product_equality_l1995_199592


namespace NUMINAMATH_CALUDE_trays_from_second_table_l1995_199519

theorem trays_from_second_table 
  (trays_per_trip : ℕ) 
  (total_trips : ℕ) 
  (trays_first_table : ℕ) 
  (h1 : trays_per_trip = 4) 
  (h2 : total_trips = 9) 
  (h3 : trays_first_table = 20) : 
  trays_per_trip * total_trips - trays_first_table = 16 := by
  sorry

end NUMINAMATH_CALUDE_trays_from_second_table_l1995_199519


namespace NUMINAMATH_CALUDE_raj_earns_more_by_200_l1995_199588

/-- Represents the dimensions of a rectangular plot of land -/
structure Plot where
  length : ℕ
  width : ℕ

/-- Calculates the area of a rectangular plot -/
def area (p : Plot) : ℕ := p.length * p.width

/-- Calculates the earnings from selling a plot given a price per square foot -/
def earnings (p : Plot) (price_per_sqft : ℕ) : ℕ := area p * price_per_sqft

/-- The difference in earnings between two plots -/
def earnings_difference (p1 p2 : Plot) (price_per_sqft : ℕ) : ℤ :=
  (earnings p1 price_per_sqft : ℤ) - (earnings p2 price_per_sqft : ℤ)

theorem raj_earns_more_by_200 :
  let raj_plot : Plot := ⟨30, 50⟩
  let lena_plot : Plot := ⟨40, 35⟩
  let price_per_sqft : ℕ := 2
  earnings_difference raj_plot lena_plot price_per_sqft = 200 :=
sorry

end NUMINAMATH_CALUDE_raj_earns_more_by_200_l1995_199588


namespace NUMINAMATH_CALUDE_perfect_square_condition_l1995_199531

theorem perfect_square_condition (m : ℤ) : 
  (∀ x : ℤ, ∃ y : ℤ, (x - 1) * (x + 3) * (x - 4) * (x - 8) + m = y^2) → 
  m = 196 := by
  sorry

end NUMINAMATH_CALUDE_perfect_square_condition_l1995_199531


namespace NUMINAMATH_CALUDE_xy_value_l1995_199564

theorem xy_value (x y : ℝ) (h1 : x^2 + y^2 = 15) (h2 : (x - y)^2 = 9) : x * y = 3 := by
  sorry

end NUMINAMATH_CALUDE_xy_value_l1995_199564


namespace NUMINAMATH_CALUDE_original_ratio_l1995_199501

theorem original_ratio (x y : ℕ) (h1 : x = y + 5) (h2 : (x - 5) / (y - 5) = 5 / 4) : x / y = 6 / 5 := by
  sorry

end NUMINAMATH_CALUDE_original_ratio_l1995_199501


namespace NUMINAMATH_CALUDE_fence_posts_count_l1995_199582

theorem fence_posts_count (length width post_distance : ℕ) 
  (h1 : length = 80)
  (h2 : width = 60)
  (h3 : post_distance = 10) : 
  (2 * (length / post_distance + 1) + 2 * (width / post_distance + 1)) - 4 = 28 := by
  sorry

end NUMINAMATH_CALUDE_fence_posts_count_l1995_199582


namespace NUMINAMATH_CALUDE_remainder_problem_l1995_199511

theorem remainder_problem (N : ℕ) (k : ℕ) (h : N = 35 * k + 25) :
  N % 15 = 10 := by
sorry

end NUMINAMATH_CALUDE_remainder_problem_l1995_199511


namespace NUMINAMATH_CALUDE_book_pages_theorem_l1995_199500

/-- Represents a reading pattern of a book -/
structure ReadingPattern where
  first_day : ℕ
  daily_increase : ℕ
  pages_left : ℕ

/-- Calculates the total number of pages in a book based on two reading patterns -/
def calculate_total_pages (r1 r2 : ReadingPattern) : ℕ :=
  sorry

/-- The theorem stating the total number of pages in the book -/
theorem book_pages_theorem (r1 r2 : ReadingPattern) 
  (h1 : r1.first_day = 35 ∧ r1.daily_increase = 5 ∧ r1.pages_left = 35)
  (h2 : r2.first_day = 45 ∧ r2.daily_increase = 5 ∧ r2.pages_left = 40) :
  calculate_total_pages r1 r2 = 385 :=
sorry

end NUMINAMATH_CALUDE_book_pages_theorem_l1995_199500


namespace NUMINAMATH_CALUDE_coin_equality_l1995_199559

/-- The value of a quarter in cents -/
def quarter_value : ℕ := 25

/-- The value of a dime in cents -/
def dime_value : ℕ := 10

/-- The value of a nickel in cents -/
def nickel_value : ℕ := 5

/-- Theorem stating that if 25 quarters and 15 dimes equal 15 quarters and n nickels, then n = 80 -/
theorem coin_equality (n : ℕ) : 
  25 * quarter_value + 15 * dime_value = 15 * quarter_value + n * nickel_value → n = 80 := by
  sorry


end NUMINAMATH_CALUDE_coin_equality_l1995_199559


namespace NUMINAMATH_CALUDE_shoe_price_calculation_shoe_price_proof_l1995_199542

theorem shoe_price_calculation (initial_price : ℝ) 
  (increase_percentage : ℝ) (discount_percentage : ℝ) : ℝ :=
  let price_after_increase := initial_price * (1 + increase_percentage)
  let final_price := price_after_increase * (1 - discount_percentage)
  final_price

theorem shoe_price_proof :
  shoe_price_calculation 50 0.2 0.15 = 51 := by
  sorry

end NUMINAMATH_CALUDE_shoe_price_calculation_shoe_price_proof_l1995_199542


namespace NUMINAMATH_CALUDE_sum_of_digits_up_to_100000_l1995_199556

/-- Sum of digits of a natural number -/
def sumOfDigits (n : ℕ) : ℕ := sorry

/-- Sum of digits of all numbers from 1 to n -/
def sumOfDigitsUpTo (n : ℕ) : ℕ := sorry

/-- The main theorem: sum of digits of all numbers from 1 to 100000 -/
theorem sum_of_digits_up_to_100000 : sumOfDigitsUpTo 100000 = 2443446 := by sorry

end NUMINAMATH_CALUDE_sum_of_digits_up_to_100000_l1995_199556


namespace NUMINAMATH_CALUDE_cone_surface_area_l1995_199508

theorem cone_surface_area (r : ℝ) (h : r = 6) : 
  let sector_radius : ℝ := r
  let base_radius : ℝ := r / 2
  let slant_height : ℝ := sector_radius
  let base_area : ℝ := π * base_radius ^ 2
  let lateral_area : ℝ := π * base_radius * slant_height
  base_area + lateral_area = 27 * π := by sorry

end NUMINAMATH_CALUDE_cone_surface_area_l1995_199508


namespace NUMINAMATH_CALUDE_at_least_two_solved_five_l1995_199529

/-- Represents a participant in the math competition -/
structure Participant where
  solved : Finset (Fin 6)

/-- Represents the math competition -/
structure MathCompetition where
  participants : Finset Participant
  num_problems : Nat
  num_problems_eq : num_problems = 6
  any_two_solved : ∀ i j : Fin 6, i ≠ j →
    (participants.filter (λ p => i ∈ p.solved ∧ j ∈ p.solved)).card >
    (2 / 5 : ℚ) * participants.card
  no_all_solved : ∀ p : Participant, p ∈ participants → p.solved.card < 6

theorem at_least_two_solved_five (mc : MathCompetition) :
  (mc.participants.filter (λ p => p.solved.card = 5)).card ≥ 2 := by
  sorry

end NUMINAMATH_CALUDE_at_least_two_solved_five_l1995_199529


namespace NUMINAMATH_CALUDE_min_values_theorem_l1995_199566

theorem min_values_theorem (a b : ℝ) (ha : 0 < a) (hb : 0 < b) 
  (h : Real.log a + Real.log b = Real.log (a + 9*b)) : 
  (a * b ≥ 36) ∧ ((81 / a^2) + (1 / b^2) ≥ 1/2) ∧ (a + b ≥ 16) := by
  sorry

end NUMINAMATH_CALUDE_min_values_theorem_l1995_199566


namespace NUMINAMATH_CALUDE_concert_total_cost_l1995_199507

/-- Calculate the total cost of a concert for two people -/
theorem concert_total_cost
  (ticket_price : ℚ)
  (num_people : ℕ)
  (processing_fee_rate : ℚ)
  (parking_fee : ℚ)
  (entrance_fee_per_person : ℚ)
  (refreshments_cost : ℚ)
  (tshirts_cost : ℚ)
  (h1 : ticket_price = 75)
  (h2 : num_people = 2)
  (h3 : processing_fee_rate = 0.15)
  (h4 : parking_fee = 10)
  (h5 : entrance_fee_per_person = 5)
  (h6 : refreshments_cost = 20)
  (h7 : tshirts_cost = 40) :
  let total_ticket_cost := ticket_price * num_people
  let processing_fee := total_ticket_cost * processing_fee_rate
  let entrance_fee_total := entrance_fee_per_person * num_people
  ticket_price * num_people +
  total_ticket_cost * processing_fee_rate +
  parking_fee +
  entrance_fee_total +
  refreshments_cost +
  tshirts_cost = 252.5 := by
    sorry


end NUMINAMATH_CALUDE_concert_total_cost_l1995_199507


namespace NUMINAMATH_CALUDE_kot_ycehyj_inequality_l1995_199567

theorem kot_ycehyj_inequality : 
  ∀ (K O T Y C E H J : ℕ),
    K ∈ Finset.range 9 ∧ 
    O ∈ Finset.range 9 ∧ 
    T ∈ Finset.range 9 ∧ 
    Y ∈ Finset.range 9 ∧ 
    C ∈ Finset.range 9 ∧ 
    E ∈ Finset.range 9 ∧ 
    H ∈ Finset.range 9 ∧ 
    J ∈ Finset.range 9 ∧
    K ≠ O ∧ K ≠ T ∧ K ≠ Y ∧ K ≠ C ∧ K ≠ E ∧ K ≠ H ∧ K ≠ J ∧
    O ≠ T ∧ O ≠ Y ∧ O ≠ C ∧ O ≠ E ∧ O ≠ H ∧ O ≠ J ∧
    T ≠ Y ∧ T ≠ C ∧ T ≠ E ∧ T ≠ H ∧ T ≠ J ∧
    Y ≠ C ∧ Y ≠ E ∧ Y ≠ H ∧ Y ≠ J ∧
    C ≠ E ∧ C ≠ H ∧ C ≠ J ∧
    E ≠ H ∧ E ≠ J ∧
    H ≠ J →
    K * O * T < Y * C * E * H * Y * J :=
by sorry

end NUMINAMATH_CALUDE_kot_ycehyj_inequality_l1995_199567


namespace NUMINAMATH_CALUDE_sculpture_exposed_area_l1995_199526

/-- Represents a layer in the sculpture -/
structure Layer where
  cubes : ℕ
  exposed_top : ℕ
  exposed_side : ℕ

/-- The sculpture configuration -/
def sculpture : List Layer := [
  ⟨9, 9, 16⟩,
  ⟨6, 6, 10⟩,
  ⟨4, 4, 8⟩,
  ⟨1, 1, 4⟩
]

/-- The total number of cubes in the sculpture -/
def total_cubes : ℕ := (sculpture.map Layer.cubes).sum

/-- Calculates the exposed surface area of a layer -/
def exposed_area (layer : Layer) : ℕ := layer.exposed_top + layer.exposed_side

/-- Calculates the total exposed surface area of the sculpture -/
def total_exposed_area : ℕ := (sculpture.map exposed_area).sum

/-- Theorem: The total exposed surface area of the sculpture is 58 square meters -/
theorem sculpture_exposed_area :
  total_cubes = 20 ∧ total_exposed_area = 58 := by sorry

end NUMINAMATH_CALUDE_sculpture_exposed_area_l1995_199526


namespace NUMINAMATH_CALUDE_f_derivative_inequality_implies_a_range_existence_of_intersecting_tangents_l1995_199524

/-- The function f(x) = x³ - ax² + 2 -/
def f (a : ℝ) (x : ℝ) : ℝ := x^3 - a*x^2 + 2

/-- The derivative of f(x) -/
def f' (a : ℝ) (x : ℝ) : ℝ := 3*x^2 - 2*a*x

theorem f_derivative_inequality_implies_a_range :
  (∀ x : ℝ, f' 0 x ≥ |x| - 3/4) → -1 ≤ 0 ∧ 0 ≤ 1 := by sorry

theorem existence_of_intersecting_tangents :
  ∃ x₁ x₂ t : ℝ, x₁ ≠ x₂ ∧ 
  (f 0 x₁ + f' 0 x₁ * (2 - x₁) = t) ∧ 
  (f 0 x₂ + f' 0 x₂ * (2 - x₂) = t) ∧
  t ≤ 10 ∧
  (∀ s : ℝ, (∃ y₁ y₂ : ℝ, y₁ ≠ y₂ ∧ 
    (f 0 y₁ + f' 0 y₁ * (2 - y₁) = s) ∧ 
    (f 0 y₂ + f' 0 y₂ * (2 - y₂) = s)) → 
  s ≤ 10) := by sorry

end NUMINAMATH_CALUDE_f_derivative_inequality_implies_a_range_existence_of_intersecting_tangents_l1995_199524


namespace NUMINAMATH_CALUDE_sum_of_squared_coefficients_is_1080_l1995_199573

/-- The polynomial for which we want to calculate the sum of squared coefficients -/
def p (x : ℝ) : ℝ := 6 * (x^3 + 4*x^2 + 2*x + 3)

/-- The sum of the squares of the coefficients of the polynomial p -/
def sum_of_squared_coefficients : ℝ :=
  let coeffs := [6, 24, 12, 18]
  coeffs.map (λ c => c^2) |>.sum

/-- Theorem stating that the sum of the squares of the coefficients of p is 1080 -/
theorem sum_of_squared_coefficients_is_1080 :
  sum_of_squared_coefficients = 1080 := by
  sorry

end NUMINAMATH_CALUDE_sum_of_squared_coefficients_is_1080_l1995_199573


namespace NUMINAMATH_CALUDE_dan_catches_cate_l1995_199514

/-- The time it takes for Dan to catch Cate given their initial distance and speeds -/
theorem dan_catches_cate (initial_distance : ℝ) (dan_speed : ℝ) (cate_speed : ℝ)
  (h1 : initial_distance = 50)
  (h2 : dan_speed = 8)
  (h3 : cate_speed = 6)
  (h4 : dan_speed > cate_speed) :
  (initial_distance / (dan_speed - cate_speed)) = 25 :=
by sorry

end NUMINAMATH_CALUDE_dan_catches_cate_l1995_199514


namespace NUMINAMATH_CALUDE_malcolm_primes_l1995_199578

def is_prime (n : ℕ) : Prop := n > 1 ∧ ∀ d : ℕ, d > 1 → d < n → ¬(d ∣ n)

theorem malcolm_primes (n : ℕ) :
  n > 0 ∧ is_prime n ∧ is_prime (2 * n - 1) ∧ is_prime (4 * n - 1) → n = 2 ∨ n = 3 := by
  sorry

end NUMINAMATH_CALUDE_malcolm_primes_l1995_199578


namespace NUMINAMATH_CALUDE_all_lines_pass_through_point_l1995_199549

/-- A line in 2D space represented by the equation ax + by = c -/
structure Line where
  a : ℝ
  b : ℝ
  c : ℝ

/-- Checks if a point (x, y) lies on a given line -/
def Line.contains (l : Line) (x y : ℝ) : Prop :=
  l.a * x + l.b * y = l.c

/-- Defines a geometric progression for three real numbers -/
def isGeometricProgression (a b c : ℝ) : Prop :=
  ∃ r : ℝ, b = a * r ∧ c = a * r^2

/-- The theorem stating that all lines with a, b, c in geometric progression pass through (0, 1) -/
theorem all_lines_pass_through_point :
  ∀ l : Line, isGeometricProgression l.a l.b l.c → l.contains 0 1 :=
sorry

end NUMINAMATH_CALUDE_all_lines_pass_through_point_l1995_199549


namespace NUMINAMATH_CALUDE_intersection_length_l1995_199584

/-- Given a line y = kx - 2 intersecting a parabola y² = 8x at points A and B,
    if the x-coordinate of the midpoint of AB is 2, then the length of AB is 2√15. -/
theorem intersection_length (k : ℝ) (A B : ℝ × ℝ) :
  (∀ x y, y = k * x - 2 → y^2 = 8 * x → (x, y) = A ∨ (x, y) = B) →
  (A.1 + B.1) / 2 = 2 →
  ‖A - B‖ = 2 * Real.sqrt 15 :=
sorry

end NUMINAMATH_CALUDE_intersection_length_l1995_199584


namespace NUMINAMATH_CALUDE_max_principals_is_four_l1995_199541

/-- Represents the duration of the period in years -/
def period_duration : ℕ := 15

/-- Represents the duration of each principal's term in years -/
def term_duration : ℕ := 4

/-- Calculates the maximum number of principals that can serve during the given period -/
def max_principals : ℕ := (period_duration - 1) / term_duration + 1

/-- Theorem stating that the maximum number of principals is 4 -/
theorem max_principals_is_four : max_principals = 4 := by
  sorry

end NUMINAMATH_CALUDE_max_principals_is_four_l1995_199541


namespace NUMINAMATH_CALUDE_intersection_line_slope_l1995_199553

-- Define the equations of the circles
def circle1 (x y : ℝ) : Prop := x^2 + y^2 - 6*x + 4*y - 20 = 0
def circle2 (x y : ℝ) : Prop := x^2 + y^2 - 16*x + 8*y + 40 = 0

-- Define the intersection points
def intersection_points : Set (ℝ × ℝ) :=
  {p | circle1 p.1 p.2 ∧ circle2 p.1 p.2}

-- Theorem stating that the slope of the line passing through the intersection points is 5/2
theorem intersection_line_slope :
  ∃ (p1 p2 : ℝ × ℝ), p1 ∈ intersection_points ∧ p2 ∈ intersection_points ∧ p1 ≠ p2 ∧
  (p2.2 - p1.2) / (p2.1 - p1.1) = 5/2 :=
sorry

end NUMINAMATH_CALUDE_intersection_line_slope_l1995_199553


namespace NUMINAMATH_CALUDE_linear_equation_condition_l1995_199599

/-- If (a+1)x + 3y^|a| = 1 is a linear equation in x and y, then a = 1 -/
theorem linear_equation_condition (a : ℝ) : 
  (∀ x y : ℝ, ∃ k m : ℝ, (a + 1) * x + 3 * y^(|a|) = k * x + m * y + 1) → a = 1 := by
  sorry

end NUMINAMATH_CALUDE_linear_equation_condition_l1995_199599


namespace NUMINAMATH_CALUDE_orange_stack_sum_l1995_199565

def pyramid_stack (base_width : ℕ) (base_length : ℕ) : ℕ :=
  let layers := min base_width base_length
  List.range layers
    |> List.map (λ i => (base_width - i) * (base_length - i))
    |> List.sum

theorem orange_stack_sum :
  pyramid_stack 6 9 = 155 := by
  sorry

end NUMINAMATH_CALUDE_orange_stack_sum_l1995_199565


namespace NUMINAMATH_CALUDE_coins_after_five_hours_l1995_199576

/-- The number of coins in Tina's jar after five hours -/
def coins_in_jar (initial_deposit : ℕ) (second_third_deposit : ℕ) (fourth_deposit : ℕ) (withdrawal : ℕ) : ℕ :=
  initial_deposit + 2 * second_third_deposit + fourth_deposit - withdrawal

/-- Theorem stating the number of coins in the jar after five hours -/
theorem coins_after_five_hours :
  coins_in_jar 20 30 40 20 = 100 := by
  sorry

#eval coins_in_jar 20 30 40 20

end NUMINAMATH_CALUDE_coins_after_five_hours_l1995_199576


namespace NUMINAMATH_CALUDE_mobile_phone_price_mobile_phone_price_is_8000_l1995_199583

theorem mobile_phone_price (refrigerator_price : ℝ) (refrigerator_loss_percent : ℝ) 
  (phone_profit_percent : ℝ) (total_profit : ℝ) : ℝ :=
  let refrigerator_sale_price := refrigerator_price * (1 - refrigerator_loss_percent)
  let phone_price := (total_profit + refrigerator_price - refrigerator_sale_price) / 
    (phone_profit_percent - refrigerator_loss_percent)
  phone_price

-- Proof that the mobile phone price is 8000
theorem mobile_phone_price_is_8000 : 
  mobile_phone_price 15000 0.04 0.11 280 = 8000 := by
  sorry

end NUMINAMATH_CALUDE_mobile_phone_price_mobile_phone_price_is_8000_l1995_199583


namespace NUMINAMATH_CALUDE_math_problem_solutions_l1995_199579

theorem math_problem_solutions :
  (∃ (x : ℝ), x = Real.sqrt 48 / Real.sqrt 3 - Real.sqrt (1/2) * Real.sqrt 12 + Real.sqrt 24 ∧ x = 4 + Real.sqrt 6) ∧
  (∃ (y : ℝ), y = (Real.sqrt 27 - Real.sqrt 12) / Real.sqrt 3 ∧ y = 1) :=
by sorry

end NUMINAMATH_CALUDE_math_problem_solutions_l1995_199579


namespace NUMINAMATH_CALUDE_min_dot_product_on_hyperbola_l1995_199557

/-- The minimum dot product of two points on the hyperbola x² - y² = 2 -/
theorem min_dot_product_on_hyperbola :
  ∀ (x₁ y₁ x₂ y₂ : ℝ),
  x₁ > 0 → x₂ > 0 →
  x₁^2 - y₁^2 = 2 →
  x₂^2 - y₂^2 = 2 →
  x₁ * x₂ + y₁ * y₂ ≥ 2 ∧
  ∃ (x₁' y₁' x₂' y₂' : ℝ),
    x₁' > 0 ∧ x₂' > 0 ∧
    x₁'^2 - y₁'^2 = 2 ∧
    x₂'^2 - y₂'^2 = 2 ∧
    x₁' * x₂' + y₁' * y₂' = 2 :=
by sorry

end NUMINAMATH_CALUDE_min_dot_product_on_hyperbola_l1995_199557


namespace NUMINAMATH_CALUDE_subset_relation_l1995_199543

theorem subset_relation (x y : ℝ) :
  (abs x + abs y < 1) →
  (Real.sqrt ((x - 1/2)^2 + (y + 1/2)^2) + Real.sqrt ((x + 1/2)^2 + (y - 1/2)^2) < 2 * Real.sqrt 2) :=
by sorry

end NUMINAMATH_CALUDE_subset_relation_l1995_199543


namespace NUMINAMATH_CALUDE_regular_octagon_exterior_angle_regular_octagon_exterior_angle_is_45_l1995_199518

/-- The measure of an exterior angle of a regular octagon is 45 degrees. -/
theorem regular_octagon_exterior_angle : ℝ :=
  let n : ℕ := 8  -- number of sides in an octagon
  let interior_angle_sum : ℝ := (n - 2) * 180
  let interior_angle : ℝ := interior_angle_sum / n
  let exterior_angle : ℝ := 180 - interior_angle
  exterior_angle

/-- The measure of an exterior angle of a regular octagon is 45 degrees. -/
theorem regular_octagon_exterior_angle_is_45 : regular_octagon_exterior_angle = 45 := by
  sorry

end NUMINAMATH_CALUDE_regular_octagon_exterior_angle_regular_octagon_exterior_angle_is_45_l1995_199518


namespace NUMINAMATH_CALUDE_joan_football_games_l1995_199545

/-- The number of football games Joan went to this year -/
def games_this_year : ℕ := 4

/-- The total number of football games Joan went to this year and last year -/
def total_games : ℕ := 9

/-- The number of football games Joan went to last year -/
def games_last_year : ℕ := total_games - games_this_year

theorem joan_football_games : games_last_year = 5 := by
  sorry

end NUMINAMATH_CALUDE_joan_football_games_l1995_199545


namespace NUMINAMATH_CALUDE_car_tractor_distance_theorem_l1995_199587

theorem car_tractor_distance_theorem (total_distance : ℝ) 
  (first_meeting_time : ℝ) (car_wait_time : ℝ) (car_catch_up_time : ℝ) :
  total_distance = 160 ∧ 
  first_meeting_time = 4/3 ∧ 
  car_wait_time = 1 ∧ 
  car_catch_up_time = 1/2 →
  ∃ (car_speed tractor_speed : ℝ),
    car_speed > 0 ∧ tractor_speed > 0 ∧
    car_speed + tractor_speed = total_distance / first_meeting_time ∧
    car_speed * (first_meeting_time + car_catch_up_time) = 165 ∧
    tractor_speed * (first_meeting_time + car_wait_time + car_catch_up_time) = 85 :=
by sorry

end NUMINAMATH_CALUDE_car_tractor_distance_theorem_l1995_199587


namespace NUMINAMATH_CALUDE_class_composition_l1995_199525

theorem class_composition (n : ℕ) (m : ℕ) : 
  n > 0 ∧ m > 0 ∧ m ≤ n ∧ 
  (⌊(m : ℚ) / n * 100 + 0.5⌋ : ℚ) = 51 →
  Odd n ∧ n ≥ 35 :=
by sorry

end NUMINAMATH_CALUDE_class_composition_l1995_199525


namespace NUMINAMATH_CALUDE_first_digit_base_5_of_627_l1995_199520

theorem first_digit_base_5_of_627 :
  ∃ (d : ℕ) (r : ℕ), 627 = d * 5^4 + r ∧ d = 1 ∧ r < 5^4 := by
  sorry

end NUMINAMATH_CALUDE_first_digit_base_5_of_627_l1995_199520


namespace NUMINAMATH_CALUDE_max_operation_result_l1995_199551

def operation (n : ℕ) : ℚ :=
  2 * (2/3 * (300 - n))

theorem max_operation_result :
  (∀ n : ℕ, 10 ≤ n ∧ n ≤ 99 → operation n ≤ 1160/3) ∧
  (∃ n : ℕ, 10 ≤ n ∧ n ≤ 99 ∧ operation n = 1160/3) :=
sorry

end NUMINAMATH_CALUDE_max_operation_result_l1995_199551


namespace NUMINAMATH_CALUDE_sum_remainder_mod_9_l1995_199591

theorem sum_remainder_mod_9 : (7150 + 7152 + 7154 + 7156 + 7158) % 9 = 2 := by
  sorry

end NUMINAMATH_CALUDE_sum_remainder_mod_9_l1995_199591


namespace NUMINAMATH_CALUDE_bob_journey_distance_l1995_199581

/-- Calculates the total distance traveled given two journey segments -/
def totalDistance (speed1 speed2 time1 time2 : ℝ) : ℝ :=
  speed1 * time1 + speed2 * time2

/-- Proves that Bob's journey results in a total distance of 180 miles -/
theorem bob_journey_distance :
  let speed1 : ℝ := 60
  let speed2 : ℝ := 45
  let time1 : ℝ := 1.5
  let time2 : ℝ := 2
  totalDistance speed1 speed2 time1 time2 = 180 := by
  sorry

#eval totalDistance 60 45 1.5 2

end NUMINAMATH_CALUDE_bob_journey_distance_l1995_199581


namespace NUMINAMATH_CALUDE_divided_isosceles_triangle_theorem_l1995_199562

/-- An isosceles triangle with a parallel line dividing it -/
structure DividedIsoscelesTriangle where
  /-- The length of the base of the isosceles triangle -/
  base : ℝ
  /-- The length of the parallel line dividing the triangle -/
  parallel_line : ℝ
  /-- The ratio of the area of the smaller region to the whole triangle -/
  area_ratio : ℝ
  /-- The base is positive -/
  base_pos : 0 < base
  /-- The parallel line is positive and not longer than the base -/
  parallel_line_bounds : 0 < parallel_line ∧ parallel_line ≤ base
  /-- The area ratio is between 0 and 1 -/
  area_ratio_bounds : 0 < area_ratio ∧ area_ratio < 1
  /-- The parallel line divides the triangle according to the area ratio -/
  division_property : (parallel_line / base) ^ 2 = area_ratio

/-- The theorem stating the properties of the divided isosceles triangle -/
theorem divided_isosceles_triangle_theorem (t : DividedIsoscelesTriangle) 
  (h_base : t.base = 24)
  (h_ratio : t.area_ratio = 1/4) : 
  t.parallel_line = 12 := by
  sorry

end NUMINAMATH_CALUDE_divided_isosceles_triangle_theorem_l1995_199562


namespace NUMINAMATH_CALUDE_tan_x_value_l1995_199506

theorem tan_x_value (x : Real) (h : Real.tan (x + π/4) = 2) : Real.tan x = 1/3 := by
  sorry

end NUMINAMATH_CALUDE_tan_x_value_l1995_199506


namespace NUMINAMATH_CALUDE_club_membership_l1995_199571

theorem club_membership (total_members : ℕ) (attendance : ℕ) (men : ℕ) (women : ℕ) : 
  total_members = 30 →
  attendance = 18 →
  total_members = men + women →
  attendance = men + (women / 3) →
  men = 12 := by
sorry

end NUMINAMATH_CALUDE_club_membership_l1995_199571


namespace NUMINAMATH_CALUDE_triangle_properties_l1995_199589

/-- Given a triangle ABC with sides a, b, c opposite to angles A, B, C, 
    prove the following properties based on given conditions. -/
theorem triangle_properties (a b c A B C : ℝ) (h1 : a * Real.cos B = 4) 
    (h2 : b * Real.sin A = 3) (h3 : (1/2) * a * c * Real.sin B = 9) :
    Real.tan B = 3/4 ∧ a = 5 ∧ a + b + c = 11 + Real.sqrt 13 := by
  sorry

end NUMINAMATH_CALUDE_triangle_properties_l1995_199589


namespace NUMINAMATH_CALUDE_sum_g_one_neg_one_l1995_199561

/-- Given two functions f and g defined on real numbers satisfying certain conditions,
    prove that g(1) + g(-1) = -1. -/
theorem sum_g_one_neg_one (f g : ℝ → ℝ) 
    (h1 : ∀ x y, f (x - y) = f x * g y - g x * f y)
    (h2 : f (-2) = f 1)
    (h3 : f 1 ≠ 0) : 
  g 1 + g (-1) = -1 := by sorry

end NUMINAMATH_CALUDE_sum_g_one_neg_one_l1995_199561


namespace NUMINAMATH_CALUDE_smaller_cube_edge_length_l1995_199536

/-- Given a cube with edge length 7 cm that is cut into smaller cubes, 
    if the total surface area increases by 600%, 
    then the edge length of the smaller cubes is 1 cm. -/
theorem smaller_cube_edge_length 
  (original_edge : ℝ) 
  (surface_area_increase : ℝ) 
  (smaller_edge : ℝ) : 
  original_edge = 7 →
  surface_area_increase = 6 →
  (6 * smaller_edge^2) * ((original_edge^3) / smaller_edge^3) = 
    (1 + surface_area_increase) * (6 * original_edge^2) →
  smaller_edge = 1 := by
sorry

end NUMINAMATH_CALUDE_smaller_cube_edge_length_l1995_199536


namespace NUMINAMATH_CALUDE_sum_of_odd_and_five_times_odd_is_even_l1995_199527

theorem sum_of_odd_and_five_times_odd_is_even (m n : ℕ) 
  (hm : m % 2 = 1) (hn : n % 2 = 1) (hm_pos : 0 < m) (hn_pos : 0 < n) : 
  ∃ k : ℕ, m + 5 * n = 2 * k := by
sorry

end NUMINAMATH_CALUDE_sum_of_odd_and_five_times_odd_is_even_l1995_199527


namespace NUMINAMATH_CALUDE_unique_solution_exists_l1995_199522

/-- Predicate to check if exactly one of three numbers is negative -/
def exactlyOneNegative (a b c : ℝ) : Prop :=
  (a < 0 ∧ b > 0 ∧ c > 0) ∨ (a > 0 ∧ b < 0 ∧ c > 0) ∨ (a > 0 ∧ b > 0 ∧ c < 0)

/-- The main theorem stating that there exists exactly one solution -/
theorem unique_solution_exists :
  ∃! (a b c : ℝ), a ≠ 0 ∧ b ≠ 0 ∧ c ≠ 0 ∧
    a = Real.sqrt (b * c) ∧
    b = Real.sqrt (c * a) ∧
    c = Real.sqrt (a * b) ∧
    exactlyOneNegative a b c :=
by
  sorry

end NUMINAMATH_CALUDE_unique_solution_exists_l1995_199522


namespace NUMINAMATH_CALUDE_tan_45_degrees_l1995_199503

theorem tan_45_degrees : Real.tan (π / 4) = 1 := by
  sorry

end NUMINAMATH_CALUDE_tan_45_degrees_l1995_199503


namespace NUMINAMATH_CALUDE_angle_bisector_slope_l1995_199530

theorem angle_bisector_slope :
  let line1 : ℝ → ℝ := λ x => 2 * x
  let line2 : ℝ → ℝ := λ x => -2 * x
  let slope1 : ℝ := 2
  let slope2 : ℝ := -2
  let angle_bisector_slope : ℝ := (slope1 + slope2 + Real.sqrt (1 + slope1^2 + slope2^2)) / (1 - slope1 * slope2)
  angle_bisector_slope = 3/5 := by
  sorry

end NUMINAMATH_CALUDE_angle_bisector_slope_l1995_199530


namespace NUMINAMATH_CALUDE_gcd_299_667_l1995_199596

theorem gcd_299_667 : Nat.gcd 299 667 = 23 := by
  sorry

end NUMINAMATH_CALUDE_gcd_299_667_l1995_199596


namespace NUMINAMATH_CALUDE_distance_to_origin_of_complex_number_l1995_199548

theorem distance_to_origin_of_complex_number : 
  let i : ℂ := Complex.I
  let z : ℂ := i / (i + 1)
  Complex.abs z = Real.sqrt 2 / 2 := by
sorry

end NUMINAMATH_CALUDE_distance_to_origin_of_complex_number_l1995_199548


namespace NUMINAMATH_CALUDE_equal_real_imag_parts_l1995_199535

theorem equal_real_imag_parts (b : ℝ) : 
  let z : ℂ := (1 + I) / (1 - I) + (1 / 2 : ℂ) * b
  (z.re = z.im) ↔ b = 2 := by sorry

end NUMINAMATH_CALUDE_equal_real_imag_parts_l1995_199535


namespace NUMINAMATH_CALUDE_function_properties_l1995_199598

-- Define the function f(x)
def f (a b : ℝ) (x : ℝ) : ℝ := a * x^2 + a * x^2 * x + 2 * b - a^3

-- State the theorem
theorem function_properties (a b : ℝ) :
  (∀ x ∈ Set.Ioo (-2 : ℝ) 6, f a b x > 0) →
  (∀ x ∈ Set.Iic (-2 : ℝ) ∪ Set.Ici 6, f a b x < 0) →
  f a b (-2) = 0 →
  f a b 6 = 0 →
  (∃ c d : ℝ, c = -4 ∧ d = -48 ∧ ∀ x, f a b x = c * x^2 + 2 * c * x + d) ∧
  (∀ x ∈ Set.Icc 1 10, f a b x ≤ -20) ∧
  (∀ x ∈ Set.Icc 1 10, f a b x ≥ -192) ∧
  (∃ x ∈ Set.Icc 1 10, f a b x = -20) ∧
  (∃ x ∈ Set.Icc 1 10, f a b x = -192) :=
by
  sorry

end NUMINAMATH_CALUDE_function_properties_l1995_199598


namespace NUMINAMATH_CALUDE_cubic_equation_roots_l1995_199504

theorem cubic_equation_roots (p q : ℝ) : 
  (∃ a b c : ℕ+, a ≠ b ∧ b ≠ c ∧ a ≠ c ∧ 
    (∀ x : ℝ, x^3 - 9*x^2 + p*x - q = 0 ↔ (x = a ∨ x = b ∨ x = c))) →
  p + q = 38 := by
sorry

end NUMINAMATH_CALUDE_cubic_equation_roots_l1995_199504


namespace NUMINAMATH_CALUDE_cos_equality_implies_77_l1995_199594

theorem cos_equality_implies_77 (n : ℤ) (h1 : 0 ≤ n) (h2 : n ≤ 180) 
  (h3 : Real.cos (n * π / 180) = Real.cos (283 * π / 180)) : n = 77 := by
  sorry

end NUMINAMATH_CALUDE_cos_equality_implies_77_l1995_199594


namespace NUMINAMATH_CALUDE_pastries_sold_equals_initial_l1995_199534

/-- Represents the number of pastries and cakes made and sold by a baker -/
structure BakerInventory where
  initialPastries : ℕ
  initialCakes : ℕ
  cakesSold : ℕ
  cakesRemaining : ℕ

/-- Theorem stating that the number of pastries sold is equal to the initial number of pastries made -/
theorem pastries_sold_equals_initial (inventory : BakerInventory)
  (h1 : inventory.initialPastries = 61)
  (h2 : inventory.initialCakes = 167)
  (h3 : inventory.cakesSold = 108)
  (h4 : inventory.cakesRemaining = 59)
  : inventory.initialPastries = inventory.initialPastries := by
  sorry

end NUMINAMATH_CALUDE_pastries_sold_equals_initial_l1995_199534


namespace NUMINAMATH_CALUDE_zoe_correct_percentage_l1995_199510

theorem zoe_correct_percentage
  (total : ℝ)
  (chloe_alone : ℝ)
  (zoe_alone : ℝ)
  (amy_alone : ℝ)
  (together : ℝ)
  (chloe_correct_alone : ℝ)
  (chloe_correct_overall : ℝ)
  (zoe_correct_alone : ℝ)
  (trio_correct_together : ℝ)
  (h1 : chloe_alone = 0.4 * total)
  (h2 : zoe_alone = 0.3 * total)
  (h3 : amy_alone = 0.3 * total)
  (h4 : together = total - (chloe_alone + zoe_alone + amy_alone))
  (h5 : chloe_correct_alone = 0.8 * chloe_alone)
  (h6 : chloe_correct_overall = 0.88 * (chloe_alone + together))
  (h7 : zoe_correct_alone = 0.75 * zoe_alone)
  (h8 : trio_correct_together = 0.85 * together)
  : (zoe_correct_alone + trio_correct_together) / (zoe_alone + together) = 0.85 := by
  sorry

end NUMINAMATH_CALUDE_zoe_correct_percentage_l1995_199510


namespace NUMINAMATH_CALUDE_box_bottle_count_l1995_199593

def dozen : ℕ := 12

def water_bottles : ℕ := 2 * dozen

def apple_bottles : ℕ := water_bottles + (dozen / 2)

def total_bottles : ℕ := water_bottles + apple_bottles

theorem box_bottle_count : total_bottles = 54 := by
  sorry

end NUMINAMATH_CALUDE_box_bottle_count_l1995_199593


namespace NUMINAMATH_CALUDE_intersection_implies_p_value_l1995_199533

-- Define the ellipse equation
def ellipse (x y : ℝ) : Prop := x^2 / 8 + y^2 / 2 = 1

-- Define the parabola equation
def parabola (p x y : ℝ) : Prop := y^2 = 2 * p * x

-- State the theorem
theorem intersection_implies_p_value 
  (p : ℝ) 
  (h_p_pos : p > 0) 
  (A B : ℝ × ℝ) 
  (h_A_ellipse : ellipse A.1 A.2)
  (h_A_parabola : parabola p A.1 A.2)
  (h_B_ellipse : ellipse B.1 B.2)
  (h_B_parabola : parabola p B.1 B.2)
  (h_distance : (A.1 - B.1)^2 + (A.2 - B.2)^2 = 4) :
  p = 1/4 := by
  sorry

end NUMINAMATH_CALUDE_intersection_implies_p_value_l1995_199533


namespace NUMINAMATH_CALUDE_antonio_winning_strategy_l1995_199560

/-- Represents the game state with two piles of chips -/
structure GameState where
  m : ℕ
  n : ℕ

/-- Defines the possible moves in the game -/
inductive Move
  | TakeOne : Bool → Move  -- True for first pile, False for second
  | TakeBoth : Move
  | Transfer : Bool → Move  -- True for first to second, False for second to first

/-- Applies a move to a game state -/
def applyMove (state : GameState) (move : Move) : GameState :=
  match move with
  | Move.TakeOne first => 
      if first then ⟨state.m - 1, state.n⟩ else ⟨state.m, state.n - 1⟩
  | Move.TakeBoth => ⟨state.m - 1, state.n - 1⟩
  | Move.Transfer first => 
      if first then ⟨state.m - 1, state.n + 1⟩ else ⟨state.m + 1, state.n - 1⟩

/-- Determines if a move is valid for a given state -/
def isValidMove (state : GameState) (move : Move) : Bool :=
  match move with
  | Move.TakeOne first => if first then state.m > 0 else state.n > 0
  | Move.TakeBoth => state.m > 0 ∧ state.n > 0
  | Move.Transfer first => if first then state.m > 0 else state.n > 0

/-- Determines if the game is over (no valid moves) -/
def isGameOver (state : GameState) : Bool :=
  state.m = 0 ∧ state.n = 0

/-- Theorem: The first player (Antonio) has a winning strategy if and only if at least one of m or n is odd -/
theorem antonio_winning_strategy (initialState : GameState) :
  (initialState.m % 2 = 1 ∨ initialState.n % 2 = 1) ↔ 
  ∃ (strategy : GameState → Move), 
    (∀ (state : GameState), 
      ¬isGameOver state → 
      isValidMove state (strategy state) ∧ 
      ¬∃ (counterStrategy : GameState → Move), 
        (∀ (state : GameState), 
          ¬isGameOver state → 
          isValidMove state (counterStrategy state) ∧ 
          isGameOver (applyMove (applyMove state (strategy state)) (counterStrategy (applyMove state (strategy state)))))) :=
sorry

end NUMINAMATH_CALUDE_antonio_winning_strategy_l1995_199560


namespace NUMINAMATH_CALUDE_rectangle_triangle_count_l1995_199517

-- Define the structure of our rectangle
structure DividedRectangle where
  horizontal_sections : Nat
  vertical_sections : Nat
  (h_pos : horizontal_sections > 0)
  (v_pos : vertical_sections > 0)

-- Function to calculate the number of triangles
def count_triangles (rect : DividedRectangle) : Nat :=
  sorry

-- Theorem statement
theorem rectangle_triangle_count :
  ∃ (rect : DividedRectangle),
    rect.horizontal_sections = 3 ∧
    rect.vertical_sections = 4 ∧
    count_triangles rect = 148 :=
  sorry

end NUMINAMATH_CALUDE_rectangle_triangle_count_l1995_199517
