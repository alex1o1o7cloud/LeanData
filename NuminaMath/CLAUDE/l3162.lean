import Mathlib

namespace NUMINAMATH_CALUDE_triangle_area_is_50_l3162_316219

/-- A square with side length 10 and lower left vertex at (0, 10) -/
structure Square where
  side : ℝ
  lower_left : ℝ × ℝ
  h_side : side = 10
  h_lower_left : lower_left = (0, 10)

/-- An isosceles triangle with base 10 on y-axis and lower right vertex at (0, 10) -/
structure IsoscelesTriangle where
  base : ℝ
  lower_right : ℝ × ℝ
  h_base : base = 10
  h_lower_right : lower_right = (0, 10)

/-- The area of the triangle formed by connecting the top vertex of the isosceles triangle
    to the top left vertex of the square -/
def triangle_area (s : Square) (t : IsoscelesTriangle) : ℝ :=
  sorry

/-- Theorem stating that the area of the formed triangle is 50 square units -/
theorem triangle_area_is_50 (s : Square) (t : IsoscelesTriangle) :
  triangle_area s t = 50 := by
  sorry

end NUMINAMATH_CALUDE_triangle_area_is_50_l3162_316219


namespace NUMINAMATH_CALUDE_pauls_books_l3162_316253

theorem pauls_books (sold : ℕ) (left : ℕ) (h1 : sold = 137) (h2 : left = 105) :
  sold + left = 242 := by
  sorry

end NUMINAMATH_CALUDE_pauls_books_l3162_316253


namespace NUMINAMATH_CALUDE_gcd_18_30_l3162_316255

theorem gcd_18_30 : Nat.gcd 18 30 = 6 := by
  sorry

end NUMINAMATH_CALUDE_gcd_18_30_l3162_316255


namespace NUMINAMATH_CALUDE_isosceles_when_root_is_one_right_angled_when_equal_roots_l3162_316264

/-- Triangle with sides a, b, and c -/
structure Triangle where
  a : ℝ
  b : ℝ
  c : ℝ

/-- Quadratic equation associated with the triangle -/
def quadratic_equation (t : Triangle) (x : ℝ) : ℝ :=
  (t.a + t.c) * x^2 - 2 * t.b * x - t.a + t.c

theorem isosceles_when_root_is_one (t : Triangle) :
  quadratic_equation t 1 = 0 → t.b = t.c :=
sorry

theorem right_angled_when_equal_roots (t : Triangle) :
  (∃ x : ℝ, ∀ y : ℝ, quadratic_equation t y = 0 ↔ y = x) →
  t.a^2 + t.b^2 = t.c^2 :=
sorry

end NUMINAMATH_CALUDE_isosceles_when_root_is_one_right_angled_when_equal_roots_l3162_316264


namespace NUMINAMATH_CALUDE_total_eggs_supplied_in_week_l3162_316229

/-- Represents the number of eggs in a dozen --/
def dozen : ℕ := 12

/-- Represents the number of days in a week --/
def daysInWeek : ℕ := 7

/-- Represents the number of weekdays in a week --/
def weekdaysInWeek : ℕ := 5

/-- Represents the number of odd days in a week --/
def oddDaysInWeek : ℕ := 3

/-- Represents the number of even days in a week --/
def evenDaysInWeek : ℕ := 4

/-- Represents the daily egg supply to the first store --/
def firstStoreSupply : ℕ := 5 * dozen

/-- Represents the daily egg supply to the second store on weekdays --/
def secondStoreSupply : ℕ := 30

/-- Represents the egg supply to the third store on odd days --/
def thirdStoreOddSupply : ℕ := 25 * dozen

/-- Represents the egg supply to the third store on even days --/
def thirdStoreEvenSupply : ℕ := 15 * dozen

/-- Theorem stating the total number of eggs supplied in a week --/
theorem total_eggs_supplied_in_week :
  firstStoreSupply * daysInWeek +
  secondStoreSupply * weekdaysInWeek +
  thirdStoreOddSupply * oddDaysInWeek +
  thirdStoreEvenSupply * evenDaysInWeek = 2190 := by
  sorry

end NUMINAMATH_CALUDE_total_eggs_supplied_in_week_l3162_316229


namespace NUMINAMATH_CALUDE_casas_alvero_prime_l3162_316282

/-- A polynomial with rational coefficients -/
def RationalPolynomial : Type := ℚ → ℚ

/-- The degree of a polynomial -/
def degree (p : RationalPolynomial) : ℕ := sorry

/-- The kth derivative of a polynomial -/
def derivative (p : RationalPolynomial) (k : ℕ) : RationalPolynomial := sorry

/-- Checks if a rational number is a root of a polynomial -/
def is_root (p : RationalPolynomial) (r : ℚ) : Prop := p r = 0

theorem casas_alvero_prime (p : RationalPolynomial) (d : ℕ) :
  degree p = d →
  Nat.Prime d →
  (∀ k : ℕ, 1 ≤ k → k ≤ d - 1 →
    ∃ r : ℚ, is_root p r ∧ is_root (derivative p k) r) →
  ∃ a b c : ℚ, ∀ x : ℚ, p x = c * (a * x + b) ^ d :=
sorry

end NUMINAMATH_CALUDE_casas_alvero_prime_l3162_316282


namespace NUMINAMATH_CALUDE_min_colors_for_distribution_centers_l3162_316211

theorem min_colors_for_distribution_centers : ∃ (n : ℕ),
  (n ≥ 5) ∧
  (n + n.choose 2 ≥ 12) ∧
  (∀ m : ℕ, m < n → m + m.choose 2 < 12) := by
  sorry

end NUMINAMATH_CALUDE_min_colors_for_distribution_centers_l3162_316211


namespace NUMINAMATH_CALUDE_tangent_line_quadratic_l3162_316213

theorem tangent_line_quadratic (a b : ℝ) : 
  (∀ x y : ℝ, y = x^2 + a*x + b) →
  (∀ x : ℝ, x + 1 = (0^2 + a*0 + b) + (2*0 + a)*x) →
  a = 1 ∧ b = 1 := by
sorry

end NUMINAMATH_CALUDE_tangent_line_quadratic_l3162_316213


namespace NUMINAMATH_CALUDE_fortran_program_141_l3162_316275

/-- Calculates the product of digits of a natural number -/
def digitProduct (n : ℕ) : ℕ := sorry

/-- Generates the next number in the sequence -/
def nextNumber (n : ℕ) : ℕ := sorry

/-- Represents the sequence of numbers generated by the process -/
def numberSequence (start : ℕ) : ℕ → ℕ := sorry

theorem fortran_program_141 :
  ∀ k : ℕ, k > 0 → numberSequence 141 k ≠ 141 := by sorry

end NUMINAMATH_CALUDE_fortran_program_141_l3162_316275


namespace NUMINAMATH_CALUDE_total_frogs_in_lakes_l3162_316232

theorem total_frogs_in_lakes (lassie_frogs : ℕ) (crystal_percentage : ℚ) : 
  lassie_frogs = 45 →
  crystal_percentage = 80/100 →
  lassie_frogs + (crystal_percentage * lassie_frogs).floor = 81 :=
by
  sorry

end NUMINAMATH_CALUDE_total_frogs_in_lakes_l3162_316232


namespace NUMINAMATH_CALUDE_tetrahedron_volume_l3162_316260

/-- The volume of a tetrahedron with an inscribed sphere -/
theorem tetrahedron_volume (S₁ S₂ S₃ S₄ r : ℝ) (h₁ : 0 < S₁) (h₂ : 0 < S₂) (h₃ : 0 < S₃) (h₄ : 0 < S₄) (hr : 0 < r) :
  ∃ V : ℝ, V = (1 / 3) * (S₁ + S₂ + S₃ + S₄) * r ∧ V > 0 :=
by sorry

end NUMINAMATH_CALUDE_tetrahedron_volume_l3162_316260


namespace NUMINAMATH_CALUDE_greatest_prime_factor_of_5_pow_7_plus_10_pow_6_l3162_316246

theorem greatest_prime_factor_of_5_pow_7_plus_10_pow_6 :
  ∃ (p : ℕ), Nat.Prime p ∧ p ∣ (5^7 + 10^6) ∧ ∀ (q : ℕ), Nat.Prime q → q ∣ (5^7 + 10^6) → q ≤ p :=
by sorry

end NUMINAMATH_CALUDE_greatest_prime_factor_of_5_pow_7_plus_10_pow_6_l3162_316246


namespace NUMINAMATH_CALUDE_ellipse_major_axis_length_l3162_316261

/-- The length of the major axis of an ellipse formed by the intersection of a plane and a right circular cylinder -/
def major_axis_length (cylinder_radius : ℝ) (major_minor_ratio : ℝ) : ℝ :=
  2 * cylinder_radius * (1 + major_minor_ratio)

/-- Theorem: The major axis length of the ellipse is 7.2 -/
theorem ellipse_major_axis_length :
  major_axis_length 2 0.8 = 7.2 := by sorry

end NUMINAMATH_CALUDE_ellipse_major_axis_length_l3162_316261


namespace NUMINAMATH_CALUDE_smallest_largest_a_sum_l3162_316269

theorem smallest_largest_a_sum (a b c : ℝ) (sum_eq : a + b + c = 5) (sum_sq_eq : a^2 + b^2 + c^2 = 8) :
  (∃ (a_min a_max : ℝ), 
    (∀ x : ℝ, (∃ y z : ℝ, x + y + z = 5 ∧ x^2 + y^2 + z^2 = 8) → a_min ≤ x ∧ x ≤ a_max) ∧
    a_min = 1 ∧ 
    a_max = 3 ∧ 
    a_min + a_max = 4) :=
by sorry

end NUMINAMATH_CALUDE_smallest_largest_a_sum_l3162_316269


namespace NUMINAMATH_CALUDE_final_distance_is_35_l3162_316263

/-- Represents the movements of the first car -/
structure FirstCarMovement where
  initial_run : ℝ
  right_turn : ℝ
  left_turn : ℝ

/-- Represents the movement of the second car -/
def SecondCarMovement : ℝ := 35

/-- Calculates the final distance between two cars given their movements -/
def finalDistance (initial_distance : ℝ) (first_car : FirstCarMovement) (second_car : ℝ) : ℝ :=
  initial_distance - (first_car.initial_run + 2 * first_car.right_turn + first_car.left_turn) - second_car

/-- Theorem stating that the final distance between the cars is 35 km -/
theorem final_distance_is_35 :
  let first_car : FirstCarMovement := ⟨25, 15, 25⟩
  let second_car : ℝ := SecondCarMovement
  finalDistance 150 first_car second_car = 35 := by
  sorry


end NUMINAMATH_CALUDE_final_distance_is_35_l3162_316263


namespace NUMINAMATH_CALUDE_truck_journey_distance_l3162_316208

/-- A problem about a semi truck's journey on paved and dirt roads. -/
theorem truck_journey_distance :
  let time_paved : ℝ := 2 -- Time spent on paved road in hours
  let time_dirt : ℝ := 3 -- Time spent on dirt road in hours
  let speed_dirt : ℝ := 32 -- Speed on dirt road in mph
  let speed_paved : ℝ := speed_dirt + 20 -- Speed on paved road in mph
  let distance_dirt : ℝ := speed_dirt * time_dirt -- Distance on dirt road
  let distance_paved : ℝ := speed_paved * time_paved -- Distance on paved road
  let total_distance : ℝ := distance_dirt + distance_paved -- Total distance of the trip
  total_distance = 200 := by sorry

end NUMINAMATH_CALUDE_truck_journey_distance_l3162_316208


namespace NUMINAMATH_CALUDE_bridge_arch_ratio_l3162_316258

-- Define the variables for the original design
variable (r₁ : ℝ) -- radius of the original design
variable (v₁ : ℝ) -- height of the arch in the original design

-- Define the variables for the built bridge
variable (r₂ : ℝ) -- radius of the built bridge
variable (v₂ : ℝ) -- height of the arch in the built bridge

-- Define the length of the bridge
variable (l : ℝ)

-- State the theorem
theorem bridge_arch_ratio :
  (v₁ = 3 * v₂) → -- Condition 1
  (r₂ = 2 * r₁) → -- Condition 2
  (2 * r₁ * v₁ - v₁^2 = 2 * r₂ * v₂ - v₂^2) → -- Condition 3 (constant bridge length)
  (v₁ / r₁ = 3 / 4) ∧ (v₂ / r₂ = 1 / 8) := by
  sorry


end NUMINAMATH_CALUDE_bridge_arch_ratio_l3162_316258


namespace NUMINAMATH_CALUDE_least_n_with_gcd_conditions_l3162_316294

theorem least_n_with_gcd_conditions : ∃ (n : ℕ), 
  (n > 500) ∧ 
  (Nat.gcd 70 (n + 150) = 35) ∧ 
  (Nat.gcd (n + 70) 150 = 50) ∧ 
  (∀ m : ℕ, m > 500 → Nat.gcd 70 (m + 150) = 35 → Nat.gcd (m + 70) 150 = 50 → m ≥ n) ∧
  n = 1015 := by
sorry

end NUMINAMATH_CALUDE_least_n_with_gcd_conditions_l3162_316294


namespace NUMINAMATH_CALUDE_regular_21gon_symmetry_sum_l3162_316223

theorem regular_21gon_symmetry_sum : 
  let n : ℕ := 21
  let L' : ℕ := n  -- number of lines of symmetry
  let R' : ℚ := 360 / n  -- smallest positive angle of rotational symmetry in degrees
  L' + R' = 38.142857 := by sorry

end NUMINAMATH_CALUDE_regular_21gon_symmetry_sum_l3162_316223


namespace NUMINAMATH_CALUDE_largest_three_digit_divisible_by_5_8_2_l3162_316241

theorem largest_three_digit_divisible_by_5_8_2 :
  ∀ n : ℕ, 100 ≤ n ∧ n ≤ 999 ∧ n % 5 = 0 ∧ n % 8 = 0 → n ≤ 960 :=
by sorry

end NUMINAMATH_CALUDE_largest_three_digit_divisible_by_5_8_2_l3162_316241


namespace NUMINAMATH_CALUDE_range_of_a_for_inequality_l3162_316286

theorem range_of_a_for_inequality : 
  {a : ℝ | ∃ x : ℝ, |x + 2| + |x - a| < 5} = Set.Ioo (-7 : ℝ) 3 := by
  sorry

end NUMINAMATH_CALUDE_range_of_a_for_inequality_l3162_316286


namespace NUMINAMATH_CALUDE_parking_lot_spaces_l3162_316272

/-- Represents a parking lot with full-sized and compact car spaces. -/
structure ParkingLot where
  full_sized : ℕ
  compact : ℕ

/-- Calculates the total number of spaces in a parking lot. -/
def total_spaces (lot : ParkingLot) : ℕ :=
  lot.full_sized + lot.compact

/-- Represents the ratio of full-sized to compact car spaces. -/
structure SpaceRatio where
  full_sized : ℕ
  compact : ℕ

/-- Theorem: Given a parking lot with 330 full-sized car spaces and a ratio of 11:4
    for full-sized to compact car spaces, the total number of spaces is 450. -/
theorem parking_lot_spaces (ratio : SpaceRatio) 
    (h1 : ratio.full_sized = 11)
    (h2 : ratio.compact = 4)
    (lot : ParkingLot)
    (h3 : lot.full_sized = 330)
    (h4 : lot.full_sized * ratio.compact = lot.compact * ratio.full_sized) :
    total_spaces lot = 450 := by
  sorry

#check parking_lot_spaces

end NUMINAMATH_CALUDE_parking_lot_spaces_l3162_316272


namespace NUMINAMATH_CALUDE_line_x_coordinate_indeterminate_l3162_316256

/-- A line in a 2D plane --/
structure Line where
  slope : ℝ
  y_intercept : ℝ

/-- Given a line passing through (4, 0), (x₁, 3), and (-12, y₂), 
    prove that x₁ cannot be uniquely determined --/
theorem line_x_coordinate_indeterminate 
  (line : Line)
  (h1 : line.slope * 4 + line.y_intercept = 0)
  (h2 : ∃ x₁, line.slope * x₁ + line.y_intercept = 3)
  (h3 : ∃ y₂, line.slope * (-12) + line.y_intercept = y₂) :
  ¬(∃! x₁, line.slope * x₁ + line.y_intercept = 3) :=
sorry

end NUMINAMATH_CALUDE_line_x_coordinate_indeterminate_l3162_316256


namespace NUMINAMATH_CALUDE_positive_real_inequality_l3162_316244

theorem positive_real_inequality (x y z : ℝ) 
  (hx : x > 0) (hy : y > 0) (hz : z > 0) 
  (h_sum : x + y + z = 1) : 
  (x^2011 + y^2011) / (x^2009 + y^2009) + 
  (y^2011 + z^2011) / (y^2009 + z^2009) + 
  (z^2011 + x^2011) / (z^2009 + x^2009) ≥ 1/3 := by
  sorry

end NUMINAMATH_CALUDE_positive_real_inequality_l3162_316244


namespace NUMINAMATH_CALUDE_franks_age_to_tys_age_ratio_l3162_316288

/-- Proves that the ratio of Frank's age in 5 years to Ty's current age is 3:1 -/
theorem franks_age_to_tys_age_ratio : 
  let karen_age : ℕ := 2
  let carla_age : ℕ := karen_age + 2
  let ty_age : ℕ := 2 * carla_age + 4
  let frank_future_age : ℕ := 36
  (frank_future_age : ℚ) / ty_age = 3 / 1 := by sorry

end NUMINAMATH_CALUDE_franks_age_to_tys_age_ratio_l3162_316288


namespace NUMINAMATH_CALUDE_sum_of_q_p_x_values_l3162_316217

def p (x : ℝ) : ℝ := |x| + 1

def q (x : ℝ) : ℝ := -x^2

def x_values : List ℝ := [-3, -2, -1, 0, 1, 2, 3]

theorem sum_of_q_p_x_values :
  (x_values.map (λ x => q (p x))).sum = -59 := by sorry

end NUMINAMATH_CALUDE_sum_of_q_p_x_values_l3162_316217


namespace NUMINAMATH_CALUDE_max_c_value_max_c_attainable_l3162_316271

theorem max_c_value (c a b : ℕ+) (h1 : c ≤ 2017) 
  (h2 : 2^(a:ℕ) * 5^(b:ℕ) = (a^3 + a^2 + a + 1) * c) : c ≤ 1000 := by
  sorry

theorem max_c_attainable : ∃ (c a b : ℕ+), c = 1000 ∧ c ≤ 2017 ∧ 
  2^(a:ℕ) * 5^(b:ℕ) = (a^3 + a^2 + a + 1) * c := by
  sorry

end NUMINAMATH_CALUDE_max_c_value_max_c_attainable_l3162_316271


namespace NUMINAMATH_CALUDE_mary_shirts_left_l3162_316252

def blue_shirts : ℕ := 30
def brown_shirts : ℕ := 40
def red_shirts : ℕ := 20
def yellow_shirts : ℕ := 25

def blue_fraction : ℚ := 3/5
def brown_fraction : ℚ := 1/4
def red_fraction : ℚ := 2/3
def yellow_fraction : ℚ := 1/5

def shirts_left : ℕ := 69

theorem mary_shirts_left : 
  blue_shirts - Int.floor (blue_fraction * blue_shirts) +
  brown_shirts - Int.floor (brown_fraction * brown_shirts) +
  red_shirts - Int.floor (red_fraction * red_shirts) +
  yellow_shirts - Int.floor (yellow_fraction * yellow_shirts) = shirts_left := by
  sorry

end NUMINAMATH_CALUDE_mary_shirts_left_l3162_316252


namespace NUMINAMATH_CALUDE_line_passes_through_fixed_point_l3162_316279

theorem line_passes_through_fixed_point (m n : ℝ) (h : m + n - 1 = 0) :
  ∃ (x y : ℝ), x = 1 ∧ y = -1 ∧ m * x + y + n = 0 :=
by
  sorry

end NUMINAMATH_CALUDE_line_passes_through_fixed_point_l3162_316279


namespace NUMINAMATH_CALUDE_transformation_result_l3162_316295

def initial_point : ℝ × ℝ × ℝ := (2, 2, 2)

def rotate_y_180 (p : ℝ × ℝ × ℝ) : ℝ × ℝ × ℝ :=
  let (x, y, z) := p
  (-x, y, -z)

def reflect_yz (p : ℝ × ℝ × ℝ) : ℝ × ℝ × ℝ :=
  let (x, y, z) := p
  (-x, y, z)

def reflect_xz (p : ℝ × ℝ × ℝ) : ℝ × ℝ × ℝ :=
  let (x, y, z) := p
  (x, -y, z)

def rotate_x_180 (p : ℝ × ℝ × ℝ) : ℝ × ℝ × ℝ :=
  let (x, y, z) := p
  (x, -y, -z)

def transform (p : ℝ × ℝ × ℝ) : ℝ × ℝ × ℝ :=
  p |> rotate_y_180
    |> reflect_yz
    |> reflect_xz
    |> rotate_x_180
    |> reflect_yz

theorem transformation_result :
  transform initial_point = (-2, 2, 2) := by
  sorry

end NUMINAMATH_CALUDE_transformation_result_l3162_316295


namespace NUMINAMATH_CALUDE_x_intercept_ratio_l3162_316298

/-- Two lines with the same non-zero y-intercept -/
structure TwoLines where
  y_intercept : ℝ
  slope1 : ℝ
  slope2 : ℝ
  x_intercept1 : ℝ
  x_intercept2 : ℝ
  y_intercept_nonzero : y_intercept ≠ 0
  slope1_is_8 : slope1 = 8
  slope2_is_4 : slope2 = 4

/-- The ratio of x-intercepts is 1/2 -/
theorem x_intercept_ratio (l : TwoLines) : l.x_intercept1 / l.x_intercept2 = 1 / 2 := by
  sorry

end NUMINAMATH_CALUDE_x_intercept_ratio_l3162_316298


namespace NUMINAMATH_CALUDE_imaginary_unit_power_fraction_l3162_316238

theorem imaginary_unit_power_fraction (i : ℂ) (h : i^2 = -1) : 
  i^2015 / (1 + i) = (-1 - i) / 2 := by sorry

end NUMINAMATH_CALUDE_imaginary_unit_power_fraction_l3162_316238


namespace NUMINAMATH_CALUDE_chord_length_perpendicular_bisector_l3162_316242

theorem chord_length_perpendicular_bisector (r : ℝ) (h : r = 10) : 
  let chord_length := 2 * (r^2 - (r/2)^2).sqrt
  chord_length = 10 * Real.sqrt 3 := by
  sorry

end NUMINAMATH_CALUDE_chord_length_perpendicular_bisector_l3162_316242


namespace NUMINAMATH_CALUDE_karen_donald_children_count_l3162_316273

/-- Represents the number of children Karen and Donald have -/
def karen_donald_children : ℕ := sorry

/-- Represents the number of children Tom and Eva have -/
def tom_eva_children : ℕ := 4

/-- Represents the total number of legs in the pool -/
def legs_in_pool : ℕ := 16

/-- Represents the number of people not in the pool -/
def people_not_in_pool : ℕ := 6

/-- Proves that Karen and Donald have 6 children given the conditions -/
theorem karen_donald_children_count :
  karen_donald_children = 6 := by sorry

end NUMINAMATH_CALUDE_karen_donald_children_count_l3162_316273


namespace NUMINAMATH_CALUDE_word_problem_points_word_problem_points_correct_l3162_316216

theorem word_problem_points (total_problems : ℕ) (computation_problems : ℕ) 
  (computation_points : ℕ) (total_points : ℕ) : ℕ :=
  let word_problems := total_problems - computation_problems
  let computation_total := computation_problems * computation_points
  let word_total := total_points - computation_total
  word_total / word_problems

#check word_problem_points 30 20 3 110 = 5

theorem word_problem_points_correct : 
  word_problem_points 30 20 3 110 = 5 := by sorry

end NUMINAMATH_CALUDE_word_problem_points_word_problem_points_correct_l3162_316216


namespace NUMINAMATH_CALUDE_loan_time_period_l3162_316299

/-- Calculates the time period of a loan using simple interest -/
theorem loan_time_period (principal : ℝ) (interest : ℝ) (rate : ℝ) : 
  principal = 900 → 
  interest = 729 → 
  rate = 9 → 
  (principal * rate * 9) / 100 = interest :=
by
  sorry

end NUMINAMATH_CALUDE_loan_time_period_l3162_316299


namespace NUMINAMATH_CALUDE_valid_number_is_composite_l3162_316250

def is_valid_pair (a b : ℕ) : Prop :=
  (a * 10 + b) % 17 = 0 ∨ (a * 10 + b) % 23 = 0

def contains_digits (n : ℕ) (digits : List ℕ) : Prop :=
  ∀ d ∈ digits, ∃ k, n / (10^k) % 10 = d

def is_valid_number (n : ℕ) : Prop :=
  (n ≥ 10^1999 ∧ n < 10^2000) ∧
  (∀ i < 1999, is_valid_pair ((n / 10^i) % 10) ((n / 10^(i+1)) % 10)) ∧
  contains_digits n [1, 9, 8, 7]

theorem valid_number_is_composite (n : ℕ) (h : is_valid_number n) : 
  ¬(Nat.Prime n) := by
  sorry

end NUMINAMATH_CALUDE_valid_number_is_composite_l3162_316250


namespace NUMINAMATH_CALUDE_floor_of_7_8_l3162_316234

theorem floor_of_7_8 : ⌊(7.8 : ℝ)⌋ = 7 := by sorry

end NUMINAMATH_CALUDE_floor_of_7_8_l3162_316234


namespace NUMINAMATH_CALUDE_exactly_two_valid_numbers_l3162_316259

def is_valid_number (n : Nat) : Prop :=
  let digits := n.digits 10
  digits.length = 6 ∧
  digits.toFinset = {1, 2, 3, 4, 5, 6} ∧
  (n / 10000) % 2 = 0 ∧
  (n / 1000) % 3 = 0 ∧
  (n / 100) % 4 = 0 ∧
  (n / 10) % 5 = 0 ∧
  n % 6 = 0

theorem exactly_two_valid_numbers : 
  ∃! (s : Finset Nat), s.card = 2 ∧ ∀ n ∈ s, is_valid_number n :=
sorry

end NUMINAMATH_CALUDE_exactly_two_valid_numbers_l3162_316259


namespace NUMINAMATH_CALUDE_muffin_fundraiser_l3162_316235

/-- Proves the number of muffin cases needed to raise $120 --/
theorem muffin_fundraiser (muffins_per_pack : ℕ) (packs_per_case : ℕ) 
  (price_per_muffin : ℚ) (fundraising_goal : ℚ) :
  muffins_per_pack = 4 →
  packs_per_case = 3 →
  price_per_muffin = 2 →
  fundraising_goal = 120 →
  (fundraising_goal / (muffins_per_pack * packs_per_case * price_per_muffin) : ℚ) = 5 := by
  sorry

end NUMINAMATH_CALUDE_muffin_fundraiser_l3162_316235


namespace NUMINAMATH_CALUDE_average_weight_abc_l3162_316247

/-- Given the average weight of a and b is 40 kg, the average weight of b and c is 44 kg,
    and the weight of b is 33 kg, prove that the average weight of a, b, and c is 45 kg. -/
theorem average_weight_abc (a b c : ℝ) 
  (h1 : (a + b) / 2 = 40)
  (h2 : (b + c) / 2 = 44)
  (h3 : b = 33) :
  (a + b + c) / 3 = 45 := by
  sorry


end NUMINAMATH_CALUDE_average_weight_abc_l3162_316247


namespace NUMINAMATH_CALUDE_expression_evaluation_l3162_316293

theorem expression_evaluation :
  let x : ℤ := -1
  let y : ℤ := 2
  let expr := -2 * (-x^2*y + x*y^2) - (-3*x^2*y^2 + 3*x^2*y + (3*x^2*y^2 - 3*x*y^2))
  expr = -6 := by
  sorry

end NUMINAMATH_CALUDE_expression_evaluation_l3162_316293


namespace NUMINAMATH_CALUDE_polar_to_cartesian_equivalence_polar_equation_is_line_l3162_316200

-- Define the polar equation
def polar_equation (r θ : ℝ) : Prop := r = 1 / (Real.sin θ + Real.cos θ)

-- Define the Cartesian equation of a line
def line_equation (x y : ℝ) : Prop := y + x = 1

-- Theorem statement
theorem polar_to_cartesian_equivalence :
  ∀ (r θ x y : ℝ), 
    polar_equation r θ → 
    x = r * Real.cos θ → 
    y = r * Real.sin θ → 
    line_equation x y := by
  sorry

-- The main theorem stating that the polar equation represents a line
theorem polar_equation_is_line :
  ∃ (a b c : ℝ), ∀ (r θ : ℝ), 
    polar_equation r θ → 
    ∃ (x y : ℝ), x = r * Real.cos θ ∧ y = r * Real.sin θ ∧ a*x + b*y = c := by
  sorry

end NUMINAMATH_CALUDE_polar_to_cartesian_equivalence_polar_equation_is_line_l3162_316200


namespace NUMINAMATH_CALUDE_largest_n_unique_k_l3162_316222

theorem largest_n_unique_k : ∃ (n : ℕ), n > 0 ∧ n = 63 ∧
  (∃! (k : ℤ), (9 : ℚ)/17 < (n : ℚ)/(n + k) ∧ (n : ℚ)/(n + k) < 8/15) ∧
  (∀ (m : ℕ), m > n → ¬(∃! (k : ℤ), (9 : ℚ)/17 < (m : ℚ)/(m + k) ∧ (m : ℚ)/(m + k) < 8/15)) :=
by sorry

end NUMINAMATH_CALUDE_largest_n_unique_k_l3162_316222


namespace NUMINAMATH_CALUDE_winnie_balloon_distribution_l3162_316274

theorem winnie_balloon_distribution (total_balloons : ℕ) (num_friends : ℕ) 
  (h1 : total_balloons = 220) (h2 : num_friends = 9) :
  total_balloons % num_friends = 4 := by sorry

end NUMINAMATH_CALUDE_winnie_balloon_distribution_l3162_316274


namespace NUMINAMATH_CALUDE_mass_of_third_metal_l3162_316276

/-- Given an alloy of four metals with specific mass ratios, prove the mass of the third metal -/
theorem mass_of_third_metal (m₁ m₂ m₃ m₄ : ℝ) 
  (h_total : m₁ + m₂ + m₃ + m₄ = 25)
  (h_ratio1 : m₁ = 1.5 * m₂)
  (h_ratio2 : m₂ / m₃ = 3 / 4)
  (h_ratio3 : m₃ / m₄ = 5 / 6) :
  m₃ = 375 / 78 := by
  sorry

#check mass_of_third_metal

end NUMINAMATH_CALUDE_mass_of_third_metal_l3162_316276


namespace NUMINAMATH_CALUDE_a_5_value_l3162_316290

def arithmetic_sequence (a : ℕ → ℝ) := 
  ∀ n m : ℕ, a (n + 1) - a n = a (m + 1) - a m

theorem a_5_value (a : ℕ → ℝ) (h_arith : arithmetic_sequence a) 
  (h_3 : a 3 = 7) (h_9 : a 9 = 19) : a 5 = 11 := by
  sorry

end NUMINAMATH_CALUDE_a_5_value_l3162_316290


namespace NUMINAMATH_CALUDE_papayas_theorem_l3162_316214

def remaining_green_papayas (initial : ℕ) (friday_yellow : ℕ) : ℕ :=
  initial - friday_yellow - (2 * friday_yellow)

theorem papayas_theorem :
  remaining_green_papayas 14 2 = 8 := by
  sorry

end NUMINAMATH_CALUDE_papayas_theorem_l3162_316214


namespace NUMINAMATH_CALUDE_coefficient_of_x_is_50_l3162_316280

def expression (x : ℝ) : ℝ := 5 * (x - 6) + 6 * (8 - 3 * x^2 + 3 * x) - 9 * (3 * x - 2)

theorem coefficient_of_x_is_50 : 
  ∃ (a b c : ℝ), ∀ x, expression x = a * x^2 + 50 * x + c :=
by sorry

end NUMINAMATH_CALUDE_coefficient_of_x_is_50_l3162_316280


namespace NUMINAMATH_CALUDE_chocolate_bars_bought_l3162_316289

theorem chocolate_bars_bought (bar_cost : ℝ) (paid : ℝ) (max_change : ℝ) :
  bar_cost = 1.35 →
  paid = 10 →
  max_change = 1 →
  ∃ n : ℕ, n * bar_cost ≤ paid ∧
           paid - n * bar_cost < max_change ∧
           ∀ m : ℕ, m > n → m * bar_cost > paid :=
by
  sorry

#check chocolate_bars_bought

end NUMINAMATH_CALUDE_chocolate_bars_bought_l3162_316289


namespace NUMINAMATH_CALUDE_lacson_unsold_sweet_potatoes_l3162_316243

/-- The number of sweet potatoes Mrs. Lacson has not yet sold -/
def sweet_potatoes_not_sold (total : ℕ) (sold_to_adams : ℕ) (sold_to_lenon : ℕ) : ℕ :=
  total - (sold_to_adams + sold_to_lenon)

/-- Theorem stating that Mrs. Lacson has 45 sweet potatoes not yet sold -/
theorem lacson_unsold_sweet_potatoes : 
  sweet_potatoes_not_sold 80 20 15 = 45 := by
  sorry

end NUMINAMATH_CALUDE_lacson_unsold_sweet_potatoes_l3162_316243


namespace NUMINAMATH_CALUDE_age_ratio_proof_l3162_316251

/-- Given that Jacob is 24 years old now and Tony will be 18 years old in 6 years,
    prove that the ratio of Tony's current age to Jacob's current age is 1:2. -/
theorem age_ratio_proof (jacob_age : ℕ) (tony_future_age : ℕ) (years_until_future : ℕ) :
  jacob_age = 24 →
  tony_future_age = 18 →
  years_until_future = 6 →
  (tony_future_age - years_until_future) * 2 = jacob_age := by
sorry

end NUMINAMATH_CALUDE_age_ratio_proof_l3162_316251


namespace NUMINAMATH_CALUDE_julie_school_year_hours_l3162_316215

/-- Given Julie's summer work details and school year earnings goal, calculate her required weekly hours during the school year. -/
theorem julie_school_year_hours 
  (summer_weeks : ℕ) 
  (summer_hours_per_week : ℕ) 
  (summer_earnings : ℕ) 
  (school_year_weeks : ℕ) 
  (school_year_earnings : ℕ) 
  (h1 : summer_weeks = 12)
  (h2 : summer_hours_per_week = 40)
  (h3 : summer_earnings = 6000)
  (h4 : school_year_weeks = 36)
  (h5 : school_year_earnings = 9000) :
  (school_year_earnings * summer_weeks * summer_hours_per_week) / 
  (summer_earnings * school_year_weeks) = 20 := by
sorry

end NUMINAMATH_CALUDE_julie_school_year_hours_l3162_316215


namespace NUMINAMATH_CALUDE_six_digit_number_divisibility_l3162_316245

/-- Represents a six-digit number with the given pattern -/
def SixDigitNumber (a b c : Nat) : Nat :=
  100000 * a + 10000 * b + 1000 * c + 100 * a + 10 * b + c

theorem six_digit_number_divisibility 
  (a b c : Nat) 
  (ha : a < 10) 
  (hb : b < 10) 
  (hc : c < 10) : 
  ∃ (k₁ k₂ k₃ : Nat), 
    SixDigitNumber a b c = 7 * k₁ ∧ 
    SixDigitNumber a b c = 13 * k₂ ∧ 
    SixDigitNumber a b c = 11 * k₃ := by
  sorry

#check six_digit_number_divisibility

end NUMINAMATH_CALUDE_six_digit_number_divisibility_l3162_316245


namespace NUMINAMATH_CALUDE_cube_root_unity_sum_l3162_316240

theorem cube_root_unity_sum (z : ℂ) (h : z^2 + z + 1 = 0) :
  z^2005 + z^2006 + z^2008 + z^2009 = -2 := by sorry

end NUMINAMATH_CALUDE_cube_root_unity_sum_l3162_316240


namespace NUMINAMATH_CALUDE_point_on_line_l3162_316277

/-- A point represented by its x and y coordinates -/
structure Point where
  x : ℝ
  y : ℝ

/-- Check if three points are collinear -/
def collinear (p1 p2 p3 : Point) : Prop :=
  (p2.y - p1.y) * (p3.x - p1.x) = (p3.y - p1.y) * (p2.x - p1.x)

theorem point_on_line : 
  let p1 : Point := ⟨0, 4⟩
  let p2 : Point := ⟨-6, 1⟩
  let p3 : Point := ⟨6, 7⟩
  collinear p1 p2 p3 := by
  sorry

end NUMINAMATH_CALUDE_point_on_line_l3162_316277


namespace NUMINAMATH_CALUDE_max_sum_squares_fibonacci_l3162_316203

theorem max_sum_squares_fibonacci (m n : ℕ) : 
  m ∈ Finset.range 1982 → 
  n ∈ Finset.range 1982 → 
  (n^2 - m*n - m^2)^2 = 1 → 
  m^2 + n^2 ≤ 3524578 := by
sorry

end NUMINAMATH_CALUDE_max_sum_squares_fibonacci_l3162_316203


namespace NUMINAMATH_CALUDE_free_all_friends_time_l3162_316287

/-- Time to pick a cheap handcuff lock in minutes -/
def cheap_time : ℕ := 10

/-- Time to pick an expensive handcuff lock in minutes -/
def expensive_time : ℕ := 15

/-- Represents the handcuffs on a person -/
structure Handcuffs :=
  (left_hand right_hand left_ankle right_ankle : Bool)

/-- True if the handcuff is expensive, False if it's cheap -/
def friend1 : Handcuffs := ⟨true, true, false, false⟩
def friend2 : Handcuffs := ⟨false, false, true, true⟩
def friend3 : Handcuffs := ⟨true, false, false, false⟩
def friend4 : Handcuffs := ⟨true, true, true, true⟩
def friend5 : Handcuffs := ⟨false, true, true, true⟩
def friend6 : Handcuffs := ⟨false, false, false, false⟩

/-- Calculate the time needed to free a friend -/
def free_time (h : Handcuffs) : ℕ :=
  (if h.left_hand then expensive_time else cheap_time) +
  (if h.right_hand then expensive_time else cheap_time) +
  (if h.left_ankle then expensive_time else cheap_time) +
  (if h.right_ankle then expensive_time else cheap_time)

/-- The total time to free all friends -/
def total_time : ℕ :=
  free_time friend1 + free_time friend2 + free_time friend3 +
  free_time friend4 + free_time friend5 + free_time friend6

theorem free_all_friends_time :
  total_time = 300 := by sorry

end NUMINAMATH_CALUDE_free_all_friends_time_l3162_316287


namespace NUMINAMATH_CALUDE_decreased_amount_l3162_316281

theorem decreased_amount (N : ℝ) (A : ℝ) (h1 : N = 50) (h2 : 0.20 * N - A = 6) : A = 4 := by
  sorry

end NUMINAMATH_CALUDE_decreased_amount_l3162_316281


namespace NUMINAMATH_CALUDE_ant_position_100_l3162_316249

-- Define the ant's position after n steps
def ant_position (n : ℕ) : ℕ × ℕ :=
  (n * (n + 1) / 2, n * (n + 1) / 2)

-- Theorem statement
theorem ant_position_100 : ant_position 100 = (5050, 5050) := by
  sorry

end NUMINAMATH_CALUDE_ant_position_100_l3162_316249


namespace NUMINAMATH_CALUDE_percentage_calculation_l3162_316262

theorem percentage_calculation (N : ℝ) (P : ℝ) : 
  N = 150 → 
  (3 / 5) * N = 90 → 
  (P / 100) * 90 = 36 → 
  P = 40 := by
sorry

end NUMINAMATH_CALUDE_percentage_calculation_l3162_316262


namespace NUMINAMATH_CALUDE_expand_expression_solve_inequality_system_l3162_316220

-- Problem 1
theorem expand_expression (x : ℝ) : (2*x + 1)^2 + x*(x - 4) = 5*x^2 + 1 := by
  sorry

-- Problem 2
theorem solve_inequality_system (x : ℝ) :
  (3*x - 6 > 0 ∧ (5 - x)/2 < 1) ↔ x > 3 := by
  sorry

end NUMINAMATH_CALUDE_expand_expression_solve_inequality_system_l3162_316220


namespace NUMINAMATH_CALUDE_quadratic_function_properties_l3162_316209

theorem quadratic_function_properties (a b c : ℝ) :
  let f := fun x => a * x^2 + b * x + c
  (f 0 = f 4 ∧ f 0 > f 1) → (a > 0 ∧ 4 * a + b = 0) := by
  sorry

end NUMINAMATH_CALUDE_quadratic_function_properties_l3162_316209


namespace NUMINAMATH_CALUDE_auditorium_sampling_is_systematic_l3162_316239

structure Auditorium where
  rows : Nat
  seats_per_row : Nat

def systematic_sampling (a : Auditorium) (seat_number : Nat) : Prop :=
  seat_number > 0 ∧ 
  seat_number ≤ a.seats_per_row ∧
  ∀ (row : Nat), row > 0 → row ≤ a.rows → 
    ∃ (student : Nat), student = (row - 1) * a.seats_per_row + seat_number

theorem auditorium_sampling_is_systematic (a : Auditorium) (h1 : a.rows = 30) (h2 : a.seats_per_row = 20) : 
  systematic_sampling a 15 :=
sorry

end NUMINAMATH_CALUDE_auditorium_sampling_is_systematic_l3162_316239


namespace NUMINAMATH_CALUDE_hyperbola_eccentricity_l3162_316228

/-- A hyperbola with foci on the x-axis and asymptotes y = ±√3x has eccentricity 2 -/
theorem hyperbola_eccentricity (a b : ℝ) (h : b / a = Real.sqrt 3) :
  let e := Real.sqrt (1 + (b^2 / a^2))
  e = 2 := by sorry

end NUMINAMATH_CALUDE_hyperbola_eccentricity_l3162_316228


namespace NUMINAMATH_CALUDE_smallest_prime_factor_in_C_l3162_316248

def C : Set Nat := {51, 53, 54, 55, 57}

theorem smallest_prime_factor_in_C :
  ∃ (n : Nat), n ∈ C ∧ 
    (∀ (m : Nat), m ∈ C → 
      (∃ (p : Nat), Nat.Prime p ∧ p ∣ n) → 
      (∃ (q : Nat), Nat.Prime q ∧ q ∣ m ∧ p ≤ q)) ∧
    n = 54 := by
  sorry

end NUMINAMATH_CALUDE_smallest_prime_factor_in_C_l3162_316248


namespace NUMINAMATH_CALUDE_escalator_steps_l3162_316221

theorem escalator_steps :
  ∀ (n : ℕ) (k : ℚ),
    k > 0 →
    (18 / k) * (k + 1) = n →
    (27 / (2 * k)) * (2 * k + 1) = n →
    n = 54 := by
  sorry

end NUMINAMATH_CALUDE_escalator_steps_l3162_316221


namespace NUMINAMATH_CALUDE_complex_fraction_simplification_l3162_316231

theorem complex_fraction_simplification :
  let numerator := (11/4) / ((11/10) + (10/3))
  let denominator := 5/2 - 4/3
  let left_fraction := numerator / denominator
  let right_fraction := 5/7 - ((13/6 + 9/2) * 3/8) / (11/4 - 3/2)
  left_fraction / right_fraction = -35/9 := by sorry

end NUMINAMATH_CALUDE_complex_fraction_simplification_l3162_316231


namespace NUMINAMATH_CALUDE_second_largest_prime_factor_of_sum_of_divisors_450_l3162_316257

def sum_of_divisors (n : ℕ) : ℕ := sorry

def second_largest_prime_factor (n : ℕ) : ℕ := sorry

theorem second_largest_prime_factor_of_sum_of_divisors_450 :
  second_largest_prime_factor (sum_of_divisors 450) = 13 := by sorry

end NUMINAMATH_CALUDE_second_largest_prime_factor_of_sum_of_divisors_450_l3162_316257


namespace NUMINAMATH_CALUDE_mel_weight_is_70_l3162_316218

/-- Mel's weight in pounds -/
def mel_weight : ℝ := 70

/-- Brenda's weight in pounds -/
def brenda_weight : ℝ := 220

/-- Theorem stating that Mel's weight is 70 pounds, given the problem conditions -/
theorem mel_weight_is_70 : 
  mel_weight = 70 ∧ 
  brenda_weight = 3 * mel_weight + 10 ∧ 
  brenda_weight = 220 := by
  sorry

end NUMINAMATH_CALUDE_mel_weight_is_70_l3162_316218


namespace NUMINAMATH_CALUDE_prob_at_least_six_heads_in_eight_flips_l3162_316284

/-- The probability of getting at least 6 heads in 8 fair coin flips -/
theorem prob_at_least_six_heads_in_eight_flips :
  let n : ℕ := 8  -- number of coin flips
  let k : ℕ := 6  -- minimum number of heads
  let p : ℚ := 1/2  -- probability of heads for a fair coin
  Finset.sum (Finset.range (n - k + 1)) (λ i => (n.choose (k + i)) * p^(k + i) * (1 - p)^(n - (k + i))) = 37/256 :=
by sorry

end NUMINAMATH_CALUDE_prob_at_least_six_heads_in_eight_flips_l3162_316284


namespace NUMINAMATH_CALUDE_smallest_angle_in_4_5_7_ratio_triangle_l3162_316266

theorem smallest_angle_in_4_5_7_ratio_triangle (a b c : ℝ) : 
  a > 0 ∧ b > 0 ∧ c > 0 →
  a + b + c = 180 →
  b = (5/4) * a →
  c = (7/4) * a →
  a = 45 := by
sorry

end NUMINAMATH_CALUDE_smallest_angle_in_4_5_7_ratio_triangle_l3162_316266


namespace NUMINAMATH_CALUDE_complement_intersection_real_l3162_316227

open Set

theorem complement_intersection_real (A B : Set ℝ) 
  (hA : A = {x : ℝ | 3 ≤ x ∧ x < 7})
  (hB : B = {x : ℝ | 2 < x ∧ x < 10}) :
  (A ∩ B)ᶜ = {x : ℝ | x < 3 ∨ 7 ≤ x} := by sorry

end NUMINAMATH_CALUDE_complement_intersection_real_l3162_316227


namespace NUMINAMATH_CALUDE_deborah_oranges_l3162_316212

theorem deborah_oranges (initial_oranges final_oranges susan_oranges : ℝ) 
  (h1 : initial_oranges = 55.0)
  (h2 : susan_oranges = 35.0)
  (h3 : final_oranges = 90)
  (h4 : final_oranges = initial_oranges + susan_oranges) :
  initial_oranges + susan_oranges - final_oranges = 0 :=
by sorry

end NUMINAMATH_CALUDE_deborah_oranges_l3162_316212


namespace NUMINAMATH_CALUDE_initial_men_correct_l3162_316210

/-- Represents the initial number of men employed by Nhai -/
def initial_men : ℕ := 100

/-- Represents the total length of the highway in kilometers -/
def highway_length : ℕ := 2

/-- Represents the initial number of days allocated for the project -/
def total_days : ℕ := 50

/-- Represents the initial number of work hours per day -/
def initial_hours_per_day : ℕ := 8

/-- Represents the number of days after which 1/3 of the work is completed -/
def days_for_one_third : ℕ := 25

/-- Represents the fraction of work completed after 25 days -/
def work_completed_fraction : ℚ := 1/3

/-- Represents the number of additional men hired -/
def additional_men : ℕ := 60

/-- Represents the new number of work hours per day after hiring additional men -/
def new_hours_per_day : ℕ := 10

theorem initial_men_correct :
  initial_men * total_days * initial_hours_per_day =
  (initial_men + additional_men) * (total_days - days_for_one_third) * new_hours_per_day :=
by sorry

end NUMINAMATH_CALUDE_initial_men_correct_l3162_316210


namespace NUMINAMATH_CALUDE_insurance_covers_80_percent_l3162_316296

/-- Represents the medication and insurance scenario for Tom --/
structure MedicationScenario where
  pills_per_day : ℕ
  doctor_visits_per_year : ℕ
  cost_per_visit : ℕ
  cost_per_pill : ℕ
  total_annual_payment : ℕ

/-- Calculates the percentage of medication cost covered by insurance --/
def insurance_coverage_percentage (scenario : MedicationScenario) : ℚ :=
  let total_pills := scenario.pills_per_day * 365
  let medication_cost := total_pills * scenario.cost_per_pill
  let doctor_cost := scenario.doctor_visits_per_year * scenario.cost_per_visit
  let total_cost := medication_cost + doctor_cost
  let insurance_coverage := total_cost - scenario.total_annual_payment
  (insurance_coverage : ℚ) / (medication_cost : ℚ) * 100

/-- Tom's specific medication scenario --/
def tom_scenario : MedicationScenario :=
  { pills_per_day := 2
  , doctor_visits_per_year := 2
  , cost_per_visit := 400
  , cost_per_pill := 5
  , total_annual_payment := 1530 }

/-- Theorem stating that the insurance covers 80% of Tom's medication cost --/
theorem insurance_covers_80_percent :
  insurance_coverage_percentage tom_scenario = 80 := by
  sorry

end NUMINAMATH_CALUDE_insurance_covers_80_percent_l3162_316296


namespace NUMINAMATH_CALUDE_intersection_perimeter_constant_l3162_316207

/-- A regular tetrahedron -/
structure RegularTetrahedron where
  edge_length : ℝ
  edge_length_pos : edge_length > 0

/-- A plane parallel to two opposite edges of a regular tetrahedron -/
structure ParallelPlane (t : RegularTetrahedron) where
  -- We don't need to define the plane explicitly, just its existence

/-- The figure obtained from intersecting a regular tetrahedron with a parallel plane -/
def IntersectionFigure (t : RegularTetrahedron) (p : ParallelPlane t) : Type :=
  -- We don't need to define the figure explicitly, just its existence
  Unit

/-- The perimeter of an intersection figure -/
noncomputable def perimeter (t : RegularTetrahedron) (p : ParallelPlane t) (f : IntersectionFigure t p) : ℝ :=
  2 * t.edge_length

/-- Theorem: The perimeter of any intersection figure is equal to 2a -/
theorem intersection_perimeter_constant (t : RegularTetrahedron) 
  (p : ParallelPlane t) (f : IntersectionFigure t p) :
  perimeter t p f = 2 * t.edge_length :=
by
  sorry

end NUMINAMATH_CALUDE_intersection_perimeter_constant_l3162_316207


namespace NUMINAMATH_CALUDE_altitude_sum_less_than_side_sum_l3162_316292

/-- Triangle structure with sides and altitudes -/
structure Triangle where
  a : ℝ
  b : ℝ
  c : ℝ
  h_a : ℝ
  h_b : ℝ
  h_c : ℝ
  side_positive : 0 < a ∧ 0 < b ∧ 0 < c
  altitude_positive : 0 < h_a ∧ 0 < h_b ∧ 0 < h_c
  triangle_inequality : a < b + c ∧ b < a + c ∧ c < a + b

/-- The sum of altitudes is less than the sum of sides in any triangle -/
theorem altitude_sum_less_than_side_sum (t : Triangle) :
  t.h_a + t.h_b + t.h_c < t.a + t.b + t.c := by
  sorry

end NUMINAMATH_CALUDE_altitude_sum_less_than_side_sum_l3162_316292


namespace NUMINAMATH_CALUDE_kg_conversion_hour_conversion_l3162_316265

-- Define conversion factors
def grams_per_kg : ℝ := 1000
def minutes_per_hour : ℝ := 60

-- Theorem 1: Convert 70 kg 50 g to kg
theorem kg_conversion (mass_kg : ℝ) (mass_g : ℝ) :
  mass_kg + mass_g / grams_per_kg = 70.05 :=
by sorry

-- Theorem 2: Convert 3.7 hours to hours and minutes
theorem hour_conversion (hours : ℝ) :
  ∃ (whole_hours : ℕ) (minutes : ℕ),
    hours = whole_hours + minutes / minutes_per_hour ∧
    whole_hours = 3 ∧
    minutes = 42 :=
by sorry

end NUMINAMATH_CALUDE_kg_conversion_hour_conversion_l3162_316265


namespace NUMINAMATH_CALUDE_valid_sequences_count_l3162_316205

/-- Represents the colors of the houses -/
inductive Color
  | Orange
  | Red
  | Blue
  | Yellow
  | Green
  | Purple

/-- A sequence of colored houses -/
def HouseSequence := List Color

/-- Checks if a color appears before another in a sequence -/
def appearsBefore (c1 c2 : Color) (seq : HouseSequence) : Prop :=
  ∃ i j, i < j ∧ seq.getD i c1 = c1 ∧ seq.getD j c2 = c2

/-- Checks if two colors are adjacent in a sequence -/
def areAdjacent (c1 c2 : Color) (seq : HouseSequence) : Prop :=
  ∃ i, (seq.getD i c1 = c1 ∧ seq.getD (i+1) c2 = c2) ∨ 
       (seq.getD i c2 = c2 ∧ seq.getD (i+1) c1 = c1)

/-- Checks if a sequence is valid according to the given conditions -/
def isValidSequence (seq : HouseSequence) : Prop :=
  seq.length = 6 ∧ 
  seq.Nodup ∧
  appearsBefore Color.Orange Color.Red seq ∧
  appearsBefore Color.Blue Color.Yellow seq ∧
  areAdjacent Color.Red Color.Green seq ∧
  ¬(areAdjacent Color.Blue Color.Yellow seq) ∧
  ¬(areAdjacent Color.Blue Color.Red seq)

/-- The main theorem to be proved -/
theorem valid_sequences_count :
  ∃! (validSeqs : List HouseSequence), 
    (∀ seq, seq ∈ validSeqs ↔ isValidSequence seq) ∧ 
    validSeqs.length = 3 := by sorry

end NUMINAMATH_CALUDE_valid_sequences_count_l3162_316205


namespace NUMINAMATH_CALUDE_organization_growth_l3162_316206

/-- Represents the number of people in the organization after a given number of years. -/
def people_count (initial_total : ℕ) (leaders : ℕ) (years : ℕ) : ℕ :=
  leaders + (initial_total - leaders) * (3^years)

/-- Theorem stating the number of people in the organization after 5 years. -/
theorem organization_growth :
  people_count 15 5 5 = 2435 := by
  sorry

#eval people_count 15 5 5

end NUMINAMATH_CALUDE_organization_growth_l3162_316206


namespace NUMINAMATH_CALUDE_union_equals_reals_l3162_316224

def M : Set ℝ := {x : ℝ | |x| > 2}
def N : Set ℝ := {x : ℝ | x < 3}

theorem union_equals_reals : M ∪ N = Set.univ := by sorry

end NUMINAMATH_CALUDE_union_equals_reals_l3162_316224


namespace NUMINAMATH_CALUDE_tree_distance_l3162_316270

/-- Given a yard of length 250 meters with 51 trees planted at equal distances,
    including one at each end, the distance between consecutive trees is 5 meters. -/
theorem tree_distance (yard_length : ℝ) (num_trees : ℕ) :
  yard_length = 250 →
  num_trees = 51 →
  yard_length / (num_trees - 1) = 5 :=
by sorry

end NUMINAMATH_CALUDE_tree_distance_l3162_316270


namespace NUMINAMATH_CALUDE_fruit_basket_count_l3162_316233

/-- The number of ways to choose items from a set of n identical items -/
def chooseOptions (n : ℕ) : ℕ := n + 1

/-- The number of different fruit baskets that can be created -/
def fruitBaskets (apples oranges : ℕ) : ℕ :=
  chooseOptions apples * chooseOptions oranges - 1

theorem fruit_basket_count :
  fruitBaskets 6 8 = 62 := by
  sorry

end NUMINAMATH_CALUDE_fruit_basket_count_l3162_316233


namespace NUMINAMATH_CALUDE_remainder_98_102_div_11_l3162_316226

theorem remainder_98_102_div_11 : (98 * 102) % 11 = 7 := by
  sorry

end NUMINAMATH_CALUDE_remainder_98_102_div_11_l3162_316226


namespace NUMINAMATH_CALUDE_tiling_count_is_27_l3162_316225

/-- Represents a 2 × 24 grid divided into three 3 × 8 subrectangles -/
structure Grid :=
  (subrectangles : Fin 3 → Unit)

/-- Represents the number of ways to tile a single 3 × 8 subrectangle -/
def subrectangle_tiling_count : ℕ := 3

/-- Calculates the total number of ways to tile the entire 2 × 24 grid -/
def total_tiling_count (g : Grid) : ℕ :=
  subrectangle_tiling_count ^ 3

/-- Theorem stating that the total number of tiling ways is 27 -/
theorem tiling_count_is_27 (g : Grid) : total_tiling_count g = 27 := by
  sorry

end NUMINAMATH_CALUDE_tiling_count_is_27_l3162_316225


namespace NUMINAMATH_CALUDE_dynaco_price_is_44_l3162_316201

/-- Calculates the price per share of Dynaco stock given the total number of shares sold,
    number of Dynaco shares sold, price per share of Microtron stock, and average price
    per share of all stocks sold. -/
def dynaco_price_per_share (total_shares : ℕ) (dynaco_shares : ℕ) 
    (microtron_price : ℚ) (average_price : ℚ) : ℚ :=
  let microtron_shares := total_shares - dynaco_shares
  let total_revenue := (total_shares : ℚ) * average_price
  let microtron_revenue := (microtron_shares : ℚ) * microtron_price
  (total_revenue - microtron_revenue) / (dynaco_shares : ℚ)

/-- Theorem stating that given the specific conditions from the problem,
    the price per share of Dynaco stock is $44. -/
theorem dynaco_price_is_44 :
  dynaco_price_per_share 300 150 36 40 = 44 := by
  sorry

end NUMINAMATH_CALUDE_dynaco_price_is_44_l3162_316201


namespace NUMINAMATH_CALUDE_det_problem_l3162_316237

def det (a b d c : ℕ) : ℤ := a * c - b * d

theorem det_problem (b d : ℕ) (h : det 2 b d 4 = 2) : b + d = 5 ∨ b + d = 7 := by
  sorry

end NUMINAMATH_CALUDE_det_problem_l3162_316237


namespace NUMINAMATH_CALUDE_stationery_cost_l3162_316202

/-- Given the cost of stationery items, prove the total cost of a specific combination. -/
theorem stationery_cost (E P M : ℕ) : 
  (E + 3 * P + 2 * M = 240) →
  (2 * E + 5 * P + 4 * M = 440) →
  (3 * E + 4 * P + 6 * M = 520) :=
by sorry

end NUMINAMATH_CALUDE_stationery_cost_l3162_316202


namespace NUMINAMATH_CALUDE_chestnut_collection_l3162_316285

/-- The chestnut collection problem -/
theorem chestnut_collection
  (a b c : ℝ)
  (mean_ab_c : (a + b) / 2 = c + 10)
  (mean_ac_b : (a + c) / 2 = b - 3) :
  (b + c) / 2 - a = -7 := by
  sorry

end NUMINAMATH_CALUDE_chestnut_collection_l3162_316285


namespace NUMINAMATH_CALUDE_min_value_expression_min_value_attained_l3162_316267

theorem min_value_expression (p q r : ℝ) (hp : p > 0) (hq : q > 0) (hr : r > 0) :
  4 * p^3 + 6 * q^3 + 24 * r^3 + 8 / (3 * p * q * r) ≥ 16 := by
  sorry

theorem min_value_attained (p q r : ℝ) (hp : p > 0) (hq : q > 0) (hr : r > 0) :
  ∃ p q r, 4 * p^3 + 6 * q^3 + 24 * r^3 + 8 / (3 * p * q * r) = 16 := by
  sorry

end NUMINAMATH_CALUDE_min_value_expression_min_value_attained_l3162_316267


namespace NUMINAMATH_CALUDE_triangle_yz_length_l3162_316278

/-- Given a triangle XYZ where cos(2X-Z) + sin(X+Y) = 2 and XY = 6, prove that YZ = 6√2 -/
theorem triangle_yz_length (X Y Z : Real) (h1 : Real.cos (2*X - Z) + Real.sin (X + Y) = 2) 
  (h2 : 0 < X ∧ X < π) (h3 : 0 < Y ∧ Y < π) (h4 : 0 < Z ∧ Z < π) 
  (h5 : X + Y + Z = π) (h6 : XY = 6) : 
  let YZ := Real.sqrt ((XY^2) * 2)
  YZ = 6 * Real.sqrt 2 := by
  sorry

end NUMINAMATH_CALUDE_triangle_yz_length_l3162_316278


namespace NUMINAMATH_CALUDE_intersection_of_complex_circles_l3162_316268

theorem intersection_of_complex_circles (k : ℝ) :
  (∃! z : ℂ, Complex.abs (z - 3) = 2 * Complex.abs (z + 3) ∧ Complex.abs z = k) →
  k = 1 ∨ k = 9 :=
sorry

end NUMINAMATH_CALUDE_intersection_of_complex_circles_l3162_316268


namespace NUMINAMATH_CALUDE_quadratic_roots_opposite_l3162_316204

theorem quadratic_roots_opposite (a : ℝ) : 
  (∃ x y : ℝ, x^2 + (a^2 - 2*a)*x + (a - 1) = 0 ∧ 
               y^2 + (a^2 - 2*a)*y + (a - 1) = 0 ∧ 
               x = -y) → 
  a = 0 := by
sorry

end NUMINAMATH_CALUDE_quadratic_roots_opposite_l3162_316204


namespace NUMINAMATH_CALUDE_line_y_intercept_l3162_316230

/-- A straight line in the xy-plane with slope 4 passing through (50, 300) has y-intercept 100 -/
theorem line_y_intercept (m : ℝ) (x y b : ℝ) : 
  m = 4 → x = 50 → y = 300 → y = m * x + b → b = 100 := by sorry

end NUMINAMATH_CALUDE_line_y_intercept_l3162_316230


namespace NUMINAMATH_CALUDE_base_score_per_round_l3162_316236

theorem base_score_per_round 
  (total_rounds : ℕ) 
  (total_points : ℕ) 
  (bonus_points : ℕ) 
  (penalty_points : ℕ) 
  (h1 : total_rounds = 5)
  (h2 : total_points = 370)
  (h3 : bonus_points = 50)
  (h4 : penalty_points = 30) :
  (total_points - bonus_points + penalty_points) / total_rounds = 70 := by
sorry

end NUMINAMATH_CALUDE_base_score_per_round_l3162_316236


namespace NUMINAMATH_CALUDE_min_value_expression_l3162_316291

theorem min_value_expression (x y z : ℝ) (h1 : 2 ≤ x) (h2 : x ≤ y) (h3 : y ≤ z) (h4 : z ≤ 5) :
  (x - 2)^2 + (y/x - 2)^2 + (z/y - 2)^2 + (5/z - 2)^2 ≥ 4 * (Real.rpow 5 (1/4) - 2)^2 := by
  sorry

end NUMINAMATH_CALUDE_min_value_expression_l3162_316291


namespace NUMINAMATH_CALUDE_correct_change_marys_change_l3162_316283

def change_calculation (cost_berries : ℚ) (cost_peaches : ℚ) (amount_paid : ℚ) : ℚ :=
  amount_paid - (cost_berries + cost_peaches)

theorem correct_change (cost_berries cost_peaches amount_paid : ℚ) :
  change_calculation cost_berries cost_peaches amount_paid =
  amount_paid - (cost_berries + cost_peaches) :=
by
  sorry

-- Example with Mary's specific values
theorem marys_change :
  change_calculation 7.19 6.83 20 = 5.98 :=
by
  sorry

end NUMINAMATH_CALUDE_correct_change_marys_change_l3162_316283


namespace NUMINAMATH_CALUDE_smallest_x_value_l3162_316254

theorem smallest_x_value : ∃ x : ℝ, 
  (∀ y : ℝ, 3 * y^2 + 36 * y - 135 = 2 * y * (y + 16) → x ≤ y) ∧
  (3 * x^2 + 36 * x - 135 = 2 * x * (x + 16)) ∧
  x = -15 := by
  sorry

end NUMINAMATH_CALUDE_smallest_x_value_l3162_316254


namespace NUMINAMATH_CALUDE_ratio_problem_l3162_316297

theorem ratio_problem (x y z : ℚ) 
  (h1 : x / y = 4 / 7) 
  (h2 : z / x = 3 / 5) : 
  (x + y) / (z + x) = 55 / 32 := by
  sorry

end NUMINAMATH_CALUDE_ratio_problem_l3162_316297
