import Mathlib

namespace exists_dihedral_equal_edge_not_equal_exists_edge_equal_dihedral_not_equal_dihedral_angles_neither_necessary_nor_sufficient_l3477_347782

/-- A quadrilateral pyramid with vertex V and base ABCD. -/
structure QuadrilateralPyramid where
  V : Point
  A : Point
  B : Point
  C : Point
  D : Point

/-- The property that all dihedral angles between adjacent faces are equal. -/
def all_dihedral_angles_equal (pyramid : QuadrilateralPyramid) : Prop :=
  sorry

/-- The property that all angles between adjacent edges are equal. -/
def all_edge_angles_equal (pyramid : QuadrilateralPyramid) : Prop :=
  sorry

/-- There exists a pyramid where all dihedral angles are equal but not all edge angles are equal. -/
theorem exists_dihedral_equal_edge_not_equal :
  ∃ (pyramid : QuadrilateralPyramid),
    all_dihedral_angles_equal pyramid ∧ ¬all_edge_angles_equal pyramid :=
  sorry

/-- There exists a pyramid where all edge angles are equal but not all dihedral angles are equal. -/
theorem exists_edge_equal_dihedral_not_equal :
  ∃ (pyramid : QuadrilateralPyramid),
    all_edge_angles_equal pyramid ∧ ¬all_dihedral_angles_equal pyramid :=
  sorry

/-- The main theorem stating that the equality of dihedral angles is neither necessary nor sufficient for the equality of edge angles. -/
theorem dihedral_angles_neither_necessary_nor_sufficient :
  (∃ (pyramid : QuadrilateralPyramid), all_dihedral_angles_equal pyramid ∧ ¬all_edge_angles_equal pyramid) ∧
  (∃ (pyramid : QuadrilateralPyramid), all_edge_angles_equal pyramid ∧ ¬all_dihedral_angles_equal pyramid) :=
  sorry

end exists_dihedral_equal_edge_not_equal_exists_edge_equal_dihedral_not_equal_dihedral_angles_neither_necessary_nor_sufficient_l3477_347782


namespace rectangular_prism_width_l3477_347785

theorem rectangular_prism_width 
  (length : ℝ) 
  (height : ℝ) 
  (diagonal : ℝ) 
  (width : ℝ) 
  (h1 : length = 5) 
  (h2 : height = 8) 
  (h3 : diagonal = 10) 
  (h4 : diagonal ^ 2 = length ^ 2 + width ^ 2 + height ^ 2) : 
  width = Real.sqrt 11 := by
sorry

end rectangular_prism_width_l3477_347785


namespace negative_two_squared_l3477_347762

theorem negative_two_squared : -2^2 = -4 := by
  sorry

end negative_two_squared_l3477_347762


namespace line_sequence_stabilizes_l3477_347790

/-- Represents a line of 2018 natural numbers -/
def Line := Fin 2018 → ℕ

/-- Creates the next line based on the current line -/
def nextLine (l : Line) : Line := sorry

/-- Checks if two lines are identical -/
def linesEqual (l1 l2 : Line) : Prop := ∀ i, l1 i = l2 i

/-- The sequence of lines generated by repeatedly applying nextLine -/
def lineSequence (initial : Line) : ℕ → Line
  | 0 => initial
  | n + 1 => nextLine (lineSequence initial n)

/-- The main theorem: the sequence of lines eventually stabilizes -/
theorem line_sequence_stabilizes (initial : Line) : 
  ∃ N : ℕ, ∀ n ≥ N, linesEqual (lineSequence initial n) (lineSequence initial (n + 1)) := by
  sorry

end line_sequence_stabilizes_l3477_347790


namespace two_digit_number_representation_l3477_347751

/-- Represents a two-digit number with specific properties -/
def two_digit_number (x : ℕ) : ℕ :=
  10 * (2 * x^2) + x

/-- The theorem stating the correct representation of the two-digit number -/
theorem two_digit_number_representation (x : ℕ) : 
  two_digit_number x = 20 * x^2 + x :=
by sorry

end two_digit_number_representation_l3477_347751


namespace freshman_psych_majors_percentage_l3477_347733

theorem freshman_psych_majors_percentage
  (total_students : ℕ)
  (freshman_ratio : ℚ)
  (liberal_arts_ratio : ℚ)
  (psych_major_ratio : ℚ)
  (h1 : freshman_ratio = 2/5)
  (h2 : liberal_arts_ratio = 1/2)
  (h3 : psych_major_ratio = 1/2)
  : (freshman_ratio * liberal_arts_ratio * psych_major_ratio : ℚ) = 1/10 := by
  sorry

#check freshman_psych_majors_percentage

end freshman_psych_majors_percentage_l3477_347733


namespace no_perfect_square_212_b_l3477_347793

theorem no_perfect_square_212_b : ¬ ∃ (b : ℕ), b > 2 ∧ ∃ (n : ℕ), 2 * b^2 + b + 2 = n^2 := by
  sorry

end no_perfect_square_212_b_l3477_347793


namespace geometric_series_ratio_l3477_347722

theorem geometric_series_ratio (a : ℝ) (r : ℝ) (hr : r ≠ 1) :
  (a / (1 - r)) = 64 * (a * r^4 / (1 - r)) → r = 1/2 := by
  sorry

end geometric_series_ratio_l3477_347722


namespace students_per_class_l3477_347744

theorem students_per_class 
  (total_students : ℕ) 
  (num_classrooms : ℕ) 
  (h1 : total_students = 120) 
  (h2 : num_classrooms = 24) 
  (h3 : total_students % num_classrooms = 0) -- Ensures equal distribution
  : total_students / num_classrooms = 5 := by
sorry

end students_per_class_l3477_347744


namespace beads_per_necklace_l3477_347727

def total_beads : ℕ := 52
def necklaces_made : ℕ := 26

theorem beads_per_necklace : 
  total_beads / necklaces_made = 2 := by sorry

end beads_per_necklace_l3477_347727


namespace tangent_line_equation_l3477_347780

/-- The slope of the line perpendicular to 2x - 6y + 1 = 0 -/
def perpendicular_slope : ℝ := -3

/-- The equation of the curve -/
def curve (x : ℝ) : ℝ := x^3 + 3*x^2 - 1

/-- The derivative of the curve -/
def curve_derivative (x : ℝ) : ℝ := 3*x^2 + 6*x

theorem tangent_line_equation :
  ∃ (x₀ y₀ : ℝ),
    curve x₀ = y₀ ∧
    curve_derivative x₀ = perpendicular_slope ∧
    ∀ (x y : ℝ), y - y₀ = perpendicular_slope * (x - x₀) ↔ 3*x + y + 2 = 0 :=
sorry

end tangent_line_equation_l3477_347780


namespace right_triangle_consecutive_odd_sides_l3477_347746

theorem right_triangle_consecutive_odd_sides (k : ℤ) :
  let a : ℤ := 2 * k + 1
  let c : ℤ := 2 * k + 3
  let b : ℤ := (c^2 - a^2).sqrt
  (a^2 + b^2 = c^2) → (b^2 = 8 * k + 8) :=
by sorry

end right_triangle_consecutive_odd_sides_l3477_347746


namespace quadratic_always_positive_l3477_347786

theorem quadratic_always_positive : ∀ x : ℝ, x^2 + 2*x + 2 > 0 := by
  sorry

end quadratic_always_positive_l3477_347786


namespace jake_bitcoin_factor_l3477_347728

theorem jake_bitcoin_factor (initial_fortune : ℕ) (first_donation : ℕ) (second_donation : ℕ) (final_amount : ℕ) :
  initial_fortune = 80 ∧
  first_donation = 20 ∧
  second_donation = 10 ∧
  final_amount = 80 →
  ∃ (factor : ℚ), 
    factor = 3 ∧
    final_amount = (((initial_fortune - first_donation) / 2) * factor).floor - second_donation :=
by sorry

end jake_bitcoin_factor_l3477_347728


namespace tangent_line_equation_l3477_347787

/-- The equation of the tangent line to y = (3x - 2x^3) / 3 at x = 1 is y = -x + 4/3 -/
theorem tangent_line_equation (x y : ℝ) :
  let f : ℝ → ℝ := λ x => (3*x - 2*x^3) / 3
  let x₀ : ℝ := 1
  let y₀ : ℝ := f x₀
  let f' : ℝ → ℝ := λ x => 1 - 2*x^2
  y = -x + 4/3 ↔ y - y₀ = f' x₀ * (x - x₀) :=
by sorry

end tangent_line_equation_l3477_347787


namespace wolf_does_not_catch_hare_l3477_347776

/-- Represents the step length of the hare -/
def hare_step : ℝ := 1

/-- Represents the step length of the wolf -/
def wolf_step : ℝ := 2 * hare_step

/-- Represents the number of steps the hare takes in a time unit -/
def hare_frequency : ℕ := 3

/-- Represents the number of steps the wolf takes in a time unit -/
def wolf_frequency : ℕ := 1

/-- Theorem stating that the wolf will not catch the hare -/
theorem wolf_does_not_catch_hare : 
  (hare_step * hare_frequency) > (wolf_step * wolf_frequency) := by
  sorry


end wolf_does_not_catch_hare_l3477_347776


namespace robotics_team_combinations_l3477_347788

def girls : ℕ := 4
def boys : ℕ := 7
def team_size : ℕ := 5
def min_girls : ℕ := 2

theorem robotics_team_combinations : 
  (Finset.sum (Finset.range (girls - min_girls + 1))
    (λ k => Nat.choose girls (k + min_girls) * Nat.choose boys (team_size - (k + min_girls)))) = 301 := by
  sorry

end robotics_team_combinations_l3477_347788


namespace probability_two_red_balls_l3477_347770

theorem probability_two_red_balls (total_balls : ℕ) (red_balls : ℕ) (white_balls : ℕ) 
  (h1 : total_balls = 5)
  (h2 : red_balls = 3)
  (h3 : white_balls = 2)
  (h4 : total_balls = red_balls + white_balls) :
  (red_balls / total_balls) * ((red_balls - 1) / (total_balls - 1)) = 3 / 10 ∧ 
  (red_balls / total_balls) * ((red_balls - 1) / (total_balls - 1)) ≠ 1 / 5 :=
by sorry

end probability_two_red_balls_l3477_347770


namespace subset_implies_m_equals_one_l3477_347775

theorem subset_implies_m_equals_one (m : ℝ) : 
  let A : Set ℝ := {3, m^2}
  let B : Set ℝ := {-1, 3, 2*m - 1}
  A ⊆ B → m = 1 := by
  sorry

end subset_implies_m_equals_one_l3477_347775


namespace expression_simplification_l3477_347766

theorem expression_simplification (a : ℚ) (h : a = -1/2) :
  (a + 2)^2 + (a + 2) * (2 - a) - 6 * a = 9 := by
  sorry

end expression_simplification_l3477_347766


namespace triangular_array_count_l3477_347752

def triangular_array (bottom_row : Fin 12 → Fin 2) : ℕ :=
  let top_value := (bottom_row 0) + (bottom_row 1) + (bottom_row 10) + (bottom_row 11)
  if top_value % 5 = 0 then 1 else 0

theorem triangular_array_count :
  (Finset.univ.filter (λ f : Fin 12 → Fin 2 => triangular_array f = 1)).card = 1280 :=
sorry

end triangular_array_count_l3477_347752


namespace power_function_value_l3477_347760

-- Define a power function that passes through (2, 8)
def f : ℝ → ℝ := fun x ↦ x^3

-- Theorem statement
theorem power_function_value : f 2 = 8 ∧ f (-3) = -27 := by
  sorry


end power_function_value_l3477_347760


namespace points_order_l3477_347724

-- Define the line equation
def line_equation (x y b : ℝ) : Prop := y = 3 * x - b

-- Define the points
def point1 (y₁ b : ℝ) : Prop := line_equation (-3) y₁ b
def point2 (y₂ b : ℝ) : Prop := line_equation 1 y₂ b
def point3 (y₃ b : ℝ) : Prop := line_equation (-1) y₃ b

theorem points_order (y₁ y₂ y₃ b : ℝ) 
  (h1 : point1 y₁ b) (h2 : point2 y₂ b) (h3 : point3 y₃ b) : 
  y₁ < y₃ ∧ y₃ < y₂ := by
  sorry

end points_order_l3477_347724


namespace missing_digit_divisible_by_six_l3477_347729

theorem missing_digit_divisible_by_six (n : ℕ) (h1 : n ≥ 100 ∧ n < 1000) 
  (h2 : ∃ d : ℕ, d < 10 ∧ n = 500 + 10 * d + 2) (h3 : n % 6 = 0) : 
  ∃ d : ℕ, d = 2 ∧ n = 500 + 10 * d + 2 := by
sorry

end missing_digit_divisible_by_six_l3477_347729


namespace prime_arithmetic_sequence_common_difference_l3477_347761

theorem prime_arithmetic_sequence_common_difference (p : ℕ) (a : ℕ → ℕ) (d : ℕ) :
  Prime p →
  (∀ i, i ∈ Finset.range p → Prime (a i)) →
  (∀ i j, i < j → j < p → a i < a j) →
  (∀ i, i < p - 1 → a (i + 1) - a i = d) →
  a 0 > p →
  p ∣ d :=
sorry

end prime_arithmetic_sequence_common_difference_l3477_347761


namespace max_value_of_expression_l3477_347700

theorem max_value_of_expression (a b c : ℝ) (h : a^2 + b^2 + c^2 = 9) :
  (∃ (x y z : ℝ), x^2 + y^2 + z^2 = 9 ∧ (x - y)^2 + (y - z)^2 + (z - x)^2 > (a - b)^2 + (b - c)^2 + (c - a)^2) →
  (a - b)^2 + (b - c)^2 + (c - a)^2 ≤ 27 :=
by sorry

end max_value_of_expression_l3477_347700


namespace expression_evaluation_l3477_347736

theorem expression_evaluation (a b : ℤ) (ha : a = 1) (hb : b = -1) :
  5 * a * b^2 - (3 * a * b + 2 * (-2 * a * b^2 + a * b)) = 14 := by sorry

end expression_evaluation_l3477_347736


namespace probability_theorem_l3477_347738

/-- Represents a unit cube with a certain number of painted faces -/
structure UnitCube where
  painted_faces : Nat

/-- Represents the large cube composed of unit cubes -/
def LargeCube : Type := List UnitCube

/-- Creates a large cube with the given specifications -/
def create_large_cube : LargeCube :=
  -- 8 cubes with 3 painted faces
  (List.replicate 8 ⟨3⟩) ++
  -- 18 cubes with 2 painted faces
  (List.replicate 18 ⟨2⟩) ++
  -- 27 cubes with 1 painted face
  (List.replicate 27 ⟨1⟩) ++
  -- Remaining cubes with 0 painted faces
  (List.replicate 72 ⟨0⟩)

/-- Calculates the probability of selecting one cube with 3 painted faces
    and one cube with 1 painted face when choosing 2 cubes at random -/
def probability_3_and_1 (cube : LargeCube) : Rat :=
  let total_combinations := (List.length cube).choose 2
  let favorable_outcomes := (cube.filter (λ c => c.painted_faces = 3)).length *
                            (cube.filter (λ c => c.painted_faces = 1)).length
  favorable_outcomes / total_combinations

/-- The main theorem to prove -/
theorem probability_theorem :
  probability_3_and_1 create_large_cube = 216 / 7750 := by
  sorry

end probability_theorem_l3477_347738


namespace arthur_reading_challenge_l3477_347720

/-- Arthur's summer reading challenge -/
theorem arthur_reading_challenge
  (total_goal : ℕ)
  (book1_pages : ℕ)
  (book2_pages : ℕ)
  (book1_read_percent : ℚ)
  (book2_read_fraction : ℚ)
  (h1 : total_goal = 800)
  (h2 : book1_pages = 500)
  (h3 : book2_pages = 1000)
  (h4 : book1_read_percent = 80 / 100)
  (h5 : book2_read_fraction = 1 / 5)
  : total_goal - (↑book1_pages * book1_read_percent + ↑book2_pages * book2_read_fraction) = 200 := by
  sorry

#check arthur_reading_challenge

end arthur_reading_challenge_l3477_347720


namespace even_weeks_count_l3477_347798

/-- Represents a day in a month --/
structure Day where
  number : ℕ
  month : ℕ
  deriving Repr

/-- Represents a week in a calendar --/
structure Week where
  days : List Day
  deriving Repr

/-- Determines if a week is even based on the sum of its day numbers --/
def isEvenWeek (w : Week) : Bool :=
  (w.days.map (λ d => d.number)).sum % 2 == 0

/-- Generates the 52 weeks starting from the first Monday of January --/
def generateWeeks : List Week :=
  sorry

/-- Counts the number of even weeks in a list of weeks --/
def countEvenWeeks (weeks : List Week) : ℕ :=
  (weeks.filter isEvenWeek).length

/-- Theorem stating that the number of even weeks in the 52-week period is 30 --/
theorem even_weeks_count :
  countEvenWeeks generateWeeks = 30 := by
  sorry

end even_weeks_count_l3477_347798


namespace point_transformation_l3477_347718

/-- A point in 2D space -/
structure Point where
  x : ℝ
  y : ℝ

/-- Definition of the second quadrant -/
def SecondQuadrant (p : Point) : Prop :=
  p.x < 0 ∧ p.y > 0

/-- Definition of the third quadrant -/
def ThirdQuadrant (p : Point) : Prop :=
  p.x < 0 ∧ p.y < 0

/-- The theorem stating that if P is in the second quadrant, then P' is in the third quadrant -/
theorem point_transformation (m n : ℝ) :
  let P : Point := ⟨m, n⟩
  let P' : Point := ⟨-m^2, -n⟩
  SecondQuadrant P → ThirdQuadrant P' := by
  sorry


end point_transformation_l3477_347718


namespace t_shirt_cost_is_8_l3477_347759

/-- The cost of a t-shirt in dollars -/
def t_shirt_cost : ℝ := sorry

/-- The total amount Timothy has to spend in dollars -/
def total_budget : ℝ := 50

/-- The cost of a bag in dollars -/
def bag_cost : ℝ := 10

/-- The number of t-shirts Timothy buys -/
def num_t_shirts : ℕ := 2

/-- The number of bags Timothy buys -/
def num_bags : ℕ := 2

/-- The number of key chains Timothy buys -/
def num_key_chains : ℕ := 21

/-- The cost of 3 key chains in dollars -/
def cost_3_key_chains : ℝ := 2

theorem t_shirt_cost_is_8 :
  t_shirt_cost = 8 ∧
  total_budget = num_t_shirts * t_shirt_cost + num_bags * bag_cost +
    (num_key_chains / 3 : ℝ) * cost_3_key_chains :=
by sorry

end t_shirt_cost_is_8_l3477_347759


namespace product_of_largest_and_smallest_l3477_347709

/-- The set of digits allowed to form the numbers -/
def allowed_digits : Finset Nat := {0, 2, 4, 6}

/-- Predicate to check if a number is a valid three-digit number using allowed digits -/
def is_valid_number (n : Nat) : Prop :=
  100 ≤ n ∧ n < 1000 ∧ 
  (∃ a b c, n = 100 * a + 10 * b + c ∧ 
            a ∈ allowed_digits ∧ b ∈ allowed_digits ∧ c ∈ allowed_digits ∧
            a ≠ b ∧ b ≠ c ∧ a ≠ c)

/-- The largest valid number -/
def largest_number : Nat := 642

/-- The smallest valid number -/
def smallest_number : Nat := 204

theorem product_of_largest_and_smallest :
  is_valid_number largest_number ∧
  is_valid_number smallest_number ∧
  (∀ n : Nat, is_valid_number n → n ≤ largest_number) ∧
  (∀ n : Nat, is_valid_number n → n ≥ smallest_number) ∧
  largest_number * smallest_number = 130968 := by
  sorry

#check product_of_largest_and_smallest

end product_of_largest_and_smallest_l3477_347709


namespace system_solution_l3477_347725

theorem system_solution (x y m n : ℝ) 
  (eq1 : x + y = m)
  (eq2 : x - y = n + 1)
  (sol_x : x = 3)
  (sol_y : y = 2) :
  m + n = 5 := by
sorry

end system_solution_l3477_347725


namespace right_triangle_special_property_l3477_347797

theorem right_triangle_special_property :
  ∀ (a b c : ℝ),
  (a > 0 ∧ b > 0 ∧ c > 0) →  -- positive sides
  (a^2 + b^2 = c^2) →        -- right triangle (Pythagorean theorem)
  ((1/2) * a * b = 24) →     -- area is 24
  (a^2 + b^2 = 2 * 24) →     -- sum of squares of legs equals twice the area
  (a = 2 * Real.sqrt 6 ∧ b = 2 * Real.sqrt 6 ∧ c = 4 * Real.sqrt 3) :=
by sorry

end right_triangle_special_property_l3477_347797


namespace max_non_managers_l3477_347794

/-- Represents the number of managers in the department -/
def managers : ℕ := 8

/-- Represents the maximum total number of employees allowed in the department -/
def max_total : ℕ := 130

/-- Represents the company-wide ratio of managers to non-managers -/
def company_ratio : ℚ := 5 / 24

/-- Represents the department-specific ratio of managers to non-managers -/
def dept_ratio : ℚ := 3 / 5

/-- Theorem stating the maximum number of non-managers in the department -/
theorem max_non_managers :
  ∃ (n : ℕ), n = 13 ∧ 
  (managers : ℚ) / n > company_ratio ∧
  (managers : ℚ) / n ≤ dept_ratio ∧
  managers + n ≤ max_total ∧
  ∀ (m : ℕ), m > n → 
    ((managers : ℚ) / m ≤ company_ratio ∨
     (managers : ℚ) / m > dept_ratio ∨
     managers + m > max_total) :=
by sorry

end max_non_managers_l3477_347794


namespace bowls_lost_l3477_347743

/-- Proves that the number of lost bowls is 26 given the problem conditions --/
theorem bowls_lost (total_bowls : ℕ) (fee : ℕ) (safe_payment : ℕ) (penalty : ℕ) 
  (broken_bowls : ℕ) (total_payment : ℕ) :
  total_bowls = 638 →
  fee = 100 →
  safe_payment = 3 →
  penalty = 4 →
  broken_bowls = 15 →
  total_payment = 1825 →
  ∃ (lost_bowls : ℕ), 
    fee + safe_payment * (total_bowls - lost_bowls - broken_bowls) - 
    penalty * (lost_bowls + broken_bowls) = total_payment ∧
    lost_bowls = 26 :=
by sorry

end bowls_lost_l3477_347743


namespace x_value_proof_l3477_347754

theorem x_value_proof (x y z a b c : ℝ) 
  (ha : xy / (x - y) = a)
  (hb : xz / (x - z) = b)
  (hc : yz / (y - z) = c)
  (ha_nonzero : a ≠ 0)
  (hb_nonzero : b ≠ 0)
  (hc_nonzero : c ≠ 0) :
  x = 2 * a * b * c / (a * b + b * c + a * c) :=
sorry

end x_value_proof_l3477_347754


namespace negative_expression_l3477_347768

theorem negative_expression : 
  -(-2) > 0 ∧ (-1)^2023 < 0 ∧ |-1^2| > 0 ∧ (-5)^2 > 0 := by
  sorry

end negative_expression_l3477_347768


namespace hall_volume_l3477_347735

theorem hall_volume (length width height : ℝ) : 
  length = 15 ∧ 
  width = 12 ∧ 
  2 * (length * width) = 2 * (length * height) + 2 * (width * height) → 
  length * width * height = 8004 :=
by sorry

end hall_volume_l3477_347735


namespace students_not_reading_l3477_347714

theorem students_not_reading (total_students : ℕ) (girls : ℕ) (boys : ℕ) 
  (girls_reading_fraction : ℚ) (boys_reading_fraction : ℚ) :
  total_students = girls + boys →
  girls = 12 →
  boys = 10 →
  girls_reading_fraction = 5/6 →
  boys_reading_fraction = 4/5 →
  total_students - (↑girls * girls_reading_fraction).floor - (↑boys * boys_reading_fraction).floor = 4 := by
  sorry

end students_not_reading_l3477_347714


namespace circle_center_and_radius_l3477_347737

-- Define the circle C
def C (x y : ℝ) : Prop := (x - 2)^2 + (y + 1)^2 = 4

-- Theorem stating the center and radius of the circle
theorem circle_center_and_radius :
  (∃ (x₀ y₀ r : ℝ), (∀ x y : ℝ, C x y ↔ (x - x₀)^2 + (y - y₀)^2 = r^2) ∧ x₀ = 2 ∧ y₀ = -1 ∧ r = 2) :=
by sorry

end circle_center_and_radius_l3477_347737


namespace reynas_lamps_l3477_347730

/-- The number of light bulbs in each lamp -/
def bulbs_per_lamp : ℕ := 7

/-- The fraction of lamps with burnt-out bulbs -/
def fraction_with_burnt_bulbs : ℚ := 1 / 4

/-- The number of burnt-out bulbs in lamps with burnt-out bulbs -/
def burnt_bulbs_per_lamp : ℕ := 2

/-- The total number of working light bulbs -/
def total_working_bulbs : ℕ := 130

/-- The number of lamps Reyna has -/
def num_lamps : ℕ := 20

theorem reynas_lamps :
  (bulbs_per_lamp * num_lamps : ℚ) * (1 - fraction_with_burnt_bulbs) +
  (bulbs_per_lamp - burnt_bulbs_per_lamp : ℚ) * num_lamps * fraction_with_burnt_bulbs =
  total_working_bulbs := by sorry

end reynas_lamps_l3477_347730


namespace difference_c_minus_a_l3477_347713

theorem difference_c_minus_a (a b c : ℝ) : 
  (a + b) / 2 = 30 → c - a = 60 → c - a = 60 := by
  sorry

end difference_c_minus_a_l3477_347713


namespace five_person_circle_greetings_l3477_347777

/-- Represents a circular arrangement of people --/
structure CircularArrangement (n : ℕ) where
  people : Fin n

/-- Number of greetings in a circular arrangement --/
def greetings (c : CircularArrangement 5) : ℕ := sorry

theorem five_person_circle_greetings :
  ∀ c : CircularArrangement 5, greetings c = 5 := by sorry

end five_person_circle_greetings_l3477_347777


namespace division_problem_l3477_347717

theorem division_problem (dividend : ℕ) (divisor : ℕ) (remainder : ℕ) (quotient : ℕ) 
  (h1 : dividend = 181)
  (h2 : divisor = 20)
  (h3 : remainder = 1)
  (h4 : dividend = divisor * quotient + remainder) :
  quotient = 9 := by
sorry

end division_problem_l3477_347717


namespace a_is_perfect_square_l3477_347765

theorem a_is_perfect_square (a b : ℤ) (h : a = a^2 + b^2 - 8*b - 2*a*b + 16) :
  ∃ k : ℤ, a = k^2 := by sorry

end a_is_perfect_square_l3477_347765


namespace distance_between_points_l3477_347716

theorem distance_between_points : 
  let point1 : ℝ × ℝ := (0, 6)
  let point2 : ℝ × ℝ := (4, 0)
  Real.sqrt ((point2.1 - point1.1)^2 + (point2.2 - point1.2)^2) = 2 * Real.sqrt 13 := by
  sorry

end distance_between_points_l3477_347716


namespace two_numbers_ratio_problem_l3477_347740

theorem two_numbers_ratio_problem (x y : ℝ) (hx : x > 0) (hy : y > 0) :
  x / y = 3 →
  (x^2 + y^2) / (x + y) = 5 →
  x = 6 ∧ y = 2 := by
sorry

end two_numbers_ratio_problem_l3477_347740


namespace tourism_revenue_scientific_notation_l3477_347741

theorem tourism_revenue_scientific_notation :
  let revenue_billion : ℝ := 1480.56
  let scientific_notation : ℝ := 1.48056 * (10 ^ 11)
  revenue_billion * (10 ^ 9) = scientific_notation :=
by sorry

end tourism_revenue_scientific_notation_l3477_347741


namespace not_in_A_negative_eleven_in_A_three_k_squared_minus_one_in_A_negative_thirty_four_l3477_347779

-- Define the set A
def A : Set ℤ := {x | ∃ k : ℤ, x = 3 * k - 1}

-- Theorem 1: -11 is not an element of A
theorem not_in_A_negative_eleven : -11 ∉ A := by sorry

-- Theorem 2: For any integer k, 3k² - 1 is an element of A
theorem in_A_three_k_squared_minus_one (k : ℤ) : 3 * k^2 - 1 ∈ A := by sorry

-- Theorem 3: -34 is an element of A
theorem in_A_negative_thirty_four : -34 ∈ A := by sorry

end not_in_A_negative_eleven_in_A_three_k_squared_minus_one_in_A_negative_thirty_four_l3477_347779


namespace quadratic_coefficient_l3477_347769

theorem quadratic_coefficient (b : ℝ) (p : ℝ) : 
  (∀ x, x^2 + b*x + 64 = (x + p)^2 + 16) → b = 8 * Real.sqrt 3 := by
  sorry

end quadratic_coefficient_l3477_347769


namespace divisibility_criterion_l3477_347732

theorem divisibility_criterion (x : ℕ) : 
  (x ≥ 10 ∧ x ≤ 99) →
  (1207 % x = 0 ↔ (x / 10)^3 + (x % 10)^3 = 344) :=
sorry

end divisibility_criterion_l3477_347732


namespace distinct_roots_root_one_k_values_l3477_347756

-- Define the quadratic equation
def quadratic (k x : ℝ) : ℝ := x^2 - (2*k + 1)*x + k^2 + k

-- Theorem 1: The equation has two distinct real roots for all k
theorem distinct_roots (k : ℝ) : 
  ∃ x₁ x₂ : ℝ, x₁ ≠ x₂ ∧ quadratic k x₁ = 0 ∧ quadratic k x₂ = 0 :=
sorry

-- Theorem 2: When one root is 1, k is either 0 or 1
theorem root_one_k_values : 
  ∀ k : ℝ, quadratic k 1 = 0 → k = 0 ∨ k = 1 :=
sorry

end distinct_roots_root_one_k_values_l3477_347756


namespace min_reciprocal_sum_l3477_347707

theorem min_reciprocal_sum (a b : ℝ) (h1 : a * b > 0) (h2 : a + 4 * b = 1) :
  (∀ x y : ℝ, x * y > 0 ∧ x + 4 * y = 1 → 1 / a + 1 / b ≤ 1 / x + 1 / y) ∧
  (∃ x y : ℝ, x * y > 0 ∧ x + 4 * y = 1 ∧ 1 / x + 1 / y = 9) :=
sorry

end min_reciprocal_sum_l3477_347707


namespace reciprocal_and_opposite_l3477_347719

-- Define the reciprocal function
def reciprocal (x : ℚ) : ℚ := 1 / x

-- Define the opposite function
def opposite (x : ℝ) : ℝ := -x

-- Theorem statement
theorem reciprocal_and_opposite :
  (reciprocal (2 / 3) = 3 / 2) ∧ (opposite (-2.5) = 2.5) := by
  sorry

end reciprocal_and_opposite_l3477_347719


namespace function_value_at_ten_l3477_347742

/-- Given a function f satisfying the recursive relation
    f(x+1) = f(x) / (1 + f(x)) for all x, and f(1) = 1,
    prove that f(10) = 1/10 -/
theorem function_value_at_ten
  (f : ℝ → ℝ)
  (h1 : ∀ x, f (x + 1) = f x / (1 + f x))
  (h2 : f 1 = 1) :
  f 10 = 1 / 10 := by
  sorry

end function_value_at_ten_l3477_347742


namespace correct_calculation_l3477_347772

theorem correct_calculation (x : ℝ) : 3 * x - 12 = 60 → (x / 3) + 12 = 20 := by
  sorry

end correct_calculation_l3477_347772


namespace coefficient_of_y_is_one_l3477_347795

/-- A line passing through two points with a given equation -/
structure Line where
  m : ℝ
  n : ℝ
  p : ℝ
  equation : ℝ → ℝ → Prop

/-- The line satisfies the given conditions -/
def line_satisfies_conditions (L : Line) : Prop :=
  L.p = 0.6666666666666666 ∧
  ∀ x y, L.equation x y ↔ x = y + 5

/-- The coefficient of y in the line equation is 1 -/
theorem coefficient_of_y_is_one (L : Line) 
  (h : line_satisfies_conditions L) : 
  ∃ b : ℝ, ∀ x y, L.equation x y ↔ y = x + b :=
sorry

end coefficient_of_y_is_one_l3477_347795


namespace unique_solution_condition_l3477_347774

theorem unique_solution_condition (a b : ℝ) :
  (∃! x : ℝ, 4 * x - 3 + a = b * x + 2) ↔ b ≠ 4 := by sorry

end unique_solution_condition_l3477_347774


namespace inequality_proof_l3477_347796

theorem inequality_proof (x : ℝ) : (3 * x - 5) / 2 > 2 * x → x < -5 := by
  sorry

end inequality_proof_l3477_347796


namespace product_ABC_l3477_347705

def A : ℂ := 6 + 3 * Complex.I
def B : ℂ := 2 * Complex.I
def C : ℂ := 6 - 3 * Complex.I

theorem product_ABC : A * B * C = 90 * Complex.I := by
  sorry

end product_ABC_l3477_347705


namespace line_y_coordinate_l3477_347791

/-- Given a line passing through points (10, y₁) and (x₂, -8), with an x-intercept at (4, 0), prove that y₁ = -8 -/
theorem line_y_coordinate (y₁ x₂ : ℝ) : 
  (∃ m b : ℝ, 
    (y₁ = m * 10 + b) ∧ 
    (-8 = m * x₂ + b) ∧ 
    (0 = m * 4 + b)) → 
  y₁ = -8 :=
by sorry

end line_y_coordinate_l3477_347791


namespace intersection_with_complement_l3477_347773

-- Define the universal set I
def I : Set Nat := {1, 2, 3, 4, 5}

-- Define set M
def M : Set Nat := {1, 2}

-- Define set N
def N : Set Nat := {1, 3, 5}

-- Theorem statement
theorem intersection_with_complement : M ∩ (I \ N) = {2} := by
  sorry

end intersection_with_complement_l3477_347773


namespace log_cutting_theorem_l3477_347778

/-- The number of cuts required to divide a log into a given number of pieces -/
def num_cuts (num_pieces : ℕ) : ℕ :=
  num_pieces - 1

/-- Theorem: For a log cut into 12 pieces (including fixed ends), 11 cuts are required -/
theorem log_cutting_theorem :
  let total_pieces := 12
  num_cuts total_pieces = 11 := by
  sorry

end log_cutting_theorem_l3477_347778


namespace ellipse_foci_distance_l3477_347702

/-- Given an ellipse with equation 25x^2 - 100x + 4y^2 + 8y + 4 = 0, 
    the distance between its foci is 2√21. -/
theorem ellipse_foci_distance (x y : ℝ) : 
  25 * x^2 - 100 * x + 4 * y^2 + 8 * y + 4 = 0 → 
  ∃ (c : ℝ), c = 2 * Real.sqrt 21 ∧ 
  c = (distance_between_foci : ℝ → ℝ) (25 * x^2 - 100 * x + 4 * y^2 + 8 * y + 4) :=
by sorry


end ellipse_foci_distance_l3477_347702


namespace isosceles_triangle_perimeter_isosceles_triangle_perimeter_proof_l3477_347703

/-- An isosceles triangle with sides of 5 and 10 has a perimeter of 25. -/
theorem isosceles_triangle_perimeter : ℝ → ℝ → ℝ → Prop :=
  fun a b c =>
    (a = 5 ∧ b = 10 ∧ c = 10) →  -- Isosceles triangle with sides 5 and 10
    (a + b + c = 25)             -- Perimeter is 25

-- The proof is omitted
theorem isosceles_triangle_perimeter_proof : isosceles_triangle_perimeter 5 10 10 := by
  sorry

end isosceles_triangle_perimeter_isosceles_triangle_perimeter_proof_l3477_347703


namespace gcd_n_cube_plus_eight_and_n_plus_three_l3477_347723

theorem gcd_n_cube_plus_eight_and_n_plus_three (n : ℕ) (h : n > 27) : 
  Nat.gcd (n^3 + 8) (n + 3) = 1 := by
sorry

end gcd_n_cube_plus_eight_and_n_plus_three_l3477_347723


namespace proportion_fourth_term_l3477_347704

theorem proportion_fourth_term (x y : ℝ) : 
  (0.75 : ℝ) / 0.6 = 10 / y → y = 8 := by
  sorry

end proportion_fourth_term_l3477_347704


namespace binomial_variance_10_2_5_l3477_347758

/-- The variance of a binomial distribution B(n, p) -/
def binomial_variance (n : ℕ) (p : ℝ) : ℝ := n * p * (1 - p)

/-- Theorem: The variance of a binomial distribution B(10, 2/5) is 12/5 -/
theorem binomial_variance_10_2_5 :
  binomial_variance 10 (2/5) = 12/5 := by
  sorry

end binomial_variance_10_2_5_l3477_347758


namespace line_equation_equivalence_l3477_347767

/-- Given a line defined by (2, -1) · ((x, y) - (4, -3)) = 0, 
    prove that it's equivalent to y = 2x - 11 -/
theorem line_equation_equivalence :
  ∀ (x y : ℝ), 
  (2 * (x - 4) + (-1) * (y - (-3)) = 0) ↔ (y = 2 * x - 11) := by
sorry

end line_equation_equivalence_l3477_347767


namespace soccer_most_popular_l3477_347784

-- Define the list of sports
inductive Sport
  | Hockey
  | Basketball
  | Soccer
  | Volleyball
  | Badminton

-- Function to get the number of students for each sport
def students_playing (s : Sport) : ℕ :=
  match s with
  | Sport.Hockey => 30
  | Sport.Basketball => 40
  | Sport.Soccer => 50
  | Sport.Volleyball => 35
  | Sport.Badminton => 25

-- Theorem: Soccer has the highest number of students
theorem soccer_most_popular (s : Sport) : 
  students_playing Sport.Soccer ≥ students_playing s :=
sorry

end soccer_most_popular_l3477_347784


namespace f_composition_pi_12_l3477_347748

noncomputable def f (x : ℝ) : ℝ :=
  if x ≤ 0 then 4 * x^2 - 1 else Real.sin x^2 - Real.cos x^2

theorem f_composition_pi_12 : f (f (π / 12)) = 2 := by
  sorry

end f_composition_pi_12_l3477_347748


namespace fraction_simplification_l3477_347750

theorem fraction_simplification (x : ℝ) :
  (2 * x^2 + 3) / 4 - (5 - 4 * x^2) / 6 = (14 * x^2 - 1) / 12 := by
  sorry

end fraction_simplification_l3477_347750


namespace quadratic_ratio_l3477_347731

theorem quadratic_ratio (x : ℝ) : 
  ∃ (d e : ℝ), 
    (∀ x, x^2 + 900*x + 1800 = (x + d)^2 + e) ∧ 
    (e / d = -446) := by
  sorry

end quadratic_ratio_l3477_347731


namespace num_perfect_square_factors_of_2940_l3477_347745

/-- The number of positive integer factors of 2940 that are perfect squares -/
def num_perfect_square_factors : ℕ := 4

/-- The prime factorization of 2940 -/
def prime_factorization_2940 : List (ℕ × ℕ) := [(2, 2), (3, 2), (5, 1), (7, 1)]

/-- A function to check if a list represents a valid prime factorization -/
def is_valid_prime_factorization (l : List (ℕ × ℕ)) : Prop :=
  l.all (fun (p, e) => Nat.Prime p ∧ e > 0)

/-- A function to compute the product of a prime factorization -/
def product_of_factorization (l : List (ℕ × ℕ)) : ℕ :=
  l.foldl (fun acc (p, e) => acc * p^e) 1

theorem num_perfect_square_factors_of_2940 :
  is_valid_prime_factorization prime_factorization_2940 ∧
  product_of_factorization prime_factorization_2940 = 2940 →
  num_perfect_square_factors = (List.filter (fun (_, e) => e % 2 = 0) prime_factorization_2940).length ^ 2 :=
sorry

end num_perfect_square_factors_of_2940_l3477_347745


namespace difference_of_squares_l3477_347711

theorem difference_of_squares (x : ℝ) : x^2 - 9 = (x + 3) * (x - 3) := by
  sorry

end difference_of_squares_l3477_347711


namespace digit_sum_puzzle_l3477_347783

theorem digit_sum_puzzle (a p v m t r : ℕ) 
  (h1 : a + p = v)
  (h2 : v + m = t)
  (h3 : t + a = r)
  (h4 : p + m + r = 18)
  (h5 : a ≠ 0 ∧ p ≠ 0 ∧ v ≠ 0 ∧ m ≠ 0 ∧ t ≠ 0 ∧ r ≠ 0)
  (h6 : a ≠ p ∧ a ≠ v ∧ a ≠ m ∧ a ≠ t ∧ a ≠ r ∧
        p ≠ v ∧ p ≠ m ∧ p ≠ t ∧ p ≠ r ∧
        v ≠ m ∧ v ≠ t ∧ v ≠ r ∧
        m ≠ t ∧ m ≠ r ∧
        t ≠ r) :
  t = 9 := by
  sorry


end digit_sum_puzzle_l3477_347783


namespace handbag_profit_optimization_handbag_profit_constraint_l3477_347799

/-- Represents the daily sales quantity as a function of price -/
def daily_sales (x : ℝ) : ℝ := -x + 80

/-- Represents the daily profit as a function of price -/
def daily_profit (x : ℝ) : ℝ := (x - 50) * (daily_sales x)

/-- The cost price of the handbag -/
def cost_price : ℝ := 50

/-- The lower bound of the selling price -/
def price_lower_bound : ℝ := 50

/-- The upper bound of the selling price -/
def price_upper_bound : ℝ := 80

theorem handbag_profit_optimization :
  ∃ (max_price max_profit : ℝ),
    (∀ x, price_lower_bound < x ∧ x < price_upper_bound → daily_profit x ≤ max_profit) ∧
    daily_profit max_price = max_profit ∧
    max_price = 65 ∧
    max_profit = 225 :=
sorry

theorem handbag_profit_constraint (target_profit : ℝ) (price_limit : ℝ) :
  target_profit = 200 →
  price_limit = 68 →
  ∃ (optimal_price : ℝ),
    optimal_price ≤ price_limit ∧
    daily_profit optimal_price = target_profit ∧
    optimal_price = 60 :=
sorry

end handbag_profit_optimization_handbag_profit_constraint_l3477_347799


namespace problem_solution_l3477_347739

def f (x : ℝ) : ℝ := |x - 1| - |x|

theorem problem_solution :
  let u := f (5/16)
  let v := f u
  let s := f v
  s = 1/2 := by
sorry

end problem_solution_l3477_347739


namespace cubic_minus_x_factorization_l3477_347734

theorem cubic_minus_x_factorization (x : ℝ) : x^3 - x = x * (x + 1) * (x - 1) := by
  sorry

end cubic_minus_x_factorization_l3477_347734


namespace drug_price_reduction_l3477_347753

theorem drug_price_reduction (x : ℝ) : 
  (36 : ℝ) * (1 - x)^2 = 25 ↔ 
  (∃ (price1 price2 : ℝ), 
    36 * (1 - x) = price1 ∧ 
    price1 * (1 - x) = price2 ∧ 
    price2 = 25) :=
by sorry

end drug_price_reduction_l3477_347753


namespace seed_germination_problem_l3477_347763

theorem seed_germination_problem (seeds_plot1 seeds_plot2 : ℕ) 
  (germination_rate_plot1 germination_rate_total : ℚ) :
  seeds_plot1 = 300 →
  seeds_plot2 = 200 →
  germination_rate_plot1 = 25 / 100 →
  germination_rate_total = 29 / 100 →
  ∃ (germination_rate_plot2 : ℚ),
    germination_rate_plot2 = 35 / 100 ∧
    (seeds_plot1 : ℚ) * germination_rate_plot1 + (seeds_plot2 : ℚ) * germination_rate_plot2 = 
    ((seeds_plot1 + seeds_plot2) : ℚ) * germination_rate_total :=
by sorry

end seed_germination_problem_l3477_347763


namespace max_x_is_one_l3477_347755

-- Define the function f
noncomputable def f (a : ℝ) (x : ℝ) : ℝ :=
  if x ≤ 0 then Real.exp x + a else x^2 + 1 + a

-- State the theorem
theorem max_x_is_one (a : ℝ) :
  (∀ x : ℝ, f a (2 - x) ≥ f a x) →
  (∀ x : ℝ, x ≤ 1) :=
by sorry

end max_x_is_one_l3477_347755


namespace odd_number_bound_l3477_347789

/-- Sum of digits in base 2 -/
def S₂ (n : ℕ) : ℕ := sorry

theorem odd_number_bound (K a b l m : ℕ) (hK_odd : Odd K) (hS₂K : S₂ K = 2)
  (hK_factor : K = a * b) (ha_pos : a > 1) (hb_pos : b > 1)
  (hl_pos : l > 2) (hm_pos : m > 2)
  (hS₂a : S₂ a < l) (hS₂b : S₂ b < m) : K ≤ 2^(l*m - 6) + 1 := by
  sorry

end odd_number_bound_l3477_347789


namespace complex_function_property_l3477_347757

open Complex

/-- Given a function f(z) = (a+bi)z where a and b are positive real numbers,
    if f(z) is equidistant from z and 2+2i for all complex z, and |a+bi| = 10,
    then b^2 = 287/17 -/
theorem complex_function_property (a b : ℝ) (ha : a > 0) (hb : b > 0) :
  (∀ z : ℂ, ‖(a + b * I) * z - z‖ = ‖(a + b * I) * z - (2 + 2 * I)‖) →
  ‖(a : ℂ) + b * I‖ = 10 →
  b^2 = 287/17 := by
  sorry

end complex_function_property_l3477_347757


namespace angle_y_value_l3477_347749

-- Define the triangles and angles
def triangle_ABC (A B C : ℝ) : Prop := A + B + C = 180

def right_triangle (A B : ℝ) : Prop := A + B = 90

-- State the theorem
theorem angle_y_value :
  ∀ A B C D E y : ℝ,
  triangle_ABC 50 70 C →
  right_triangle D y →
  D = C →
  y = 30 :=
by sorry

end angle_y_value_l3477_347749


namespace jezebel_bouquet_cost_l3477_347747

/-- The cost of a bouquet of flowers -/
def bouquet_cost (red_roses_per_dozen : ℕ) (red_rose_cost : ℚ) (sunflowers : ℕ) (sunflower_cost : ℚ) : ℚ :=
  (red_roses_per_dozen * 12 * red_rose_cost) + (sunflowers * sunflower_cost)

/-- Theorem: The cost of Jezebel's bouquet is $45 -/
theorem jezebel_bouquet_cost :
  bouquet_cost 2 (3/2) 3 3 = 45 := by
  sorry

end jezebel_bouquet_cost_l3477_347747


namespace quadratic_properties_l3477_347710

-- Define the quadratic function
def f (a b c x : ℝ) : ℝ := a * x^2 + b * x + c

-- State the theorem
theorem quadratic_properties
  (a b c : ℝ)
  (ha : a > 0)
  (hc : c > 0)
  (hf : f a b c c = 0)
  (h_positive : ∀ x, 0 < x → x < c → f a b c x > 0)
  (h_distinct : ∃ x, x ≠ c ∧ f a b c x = 0) :
  -- 1. The other x-intercept is at x = 1/a
  (∃ x, x ≠ c ∧ f a b c x = 0 ∧ x = 1/a) ∧
  -- 2. f(x) < 0 for x ∈ (c, 1/a)
  (∀ x, c < x → x < 1/a → f a b c x < 0) ∧
  -- 3. If the area of the triangle is 8, then 0 < a ≤ 1/8
  (((1/a - c) * c / 2 = 8) → (0 < a ∧ a ≤ 1/8)) ∧
  -- 4. If m^2 - 2km + 1 + b + ac ≥ 0 for all k ∈ [-1, 1], then m ≤ -2 or m = 0 or m ≥ 2
  ((∀ k, -1 ≤ k → k ≤ 1 → ∀ m, m^2 - 2*k*m + 1 + b + a*c ≥ 0) →
   ∀ m, m ≤ -2 ∨ m = 0 ∨ m ≥ 2) := by sorry

end quadratic_properties_l3477_347710


namespace f_2008_equals_zero_l3477_347721

-- Define an odd function f
def odd_function (f : ℝ → ℝ) : Prop := ∀ x, f (-x) = -f x

-- Define the property f(1-x) = f(1+x)
def symmetric_around_one (f : ℝ → ℝ) : Prop := ∀ x, f (1-x) = f (1+x)

theorem f_2008_equals_zero 
  (f : ℝ → ℝ) 
  (h_odd : odd_function f) 
  (h_sym : symmetric_around_one f) : 
  f 2008 = 0 := by
sorry

end f_2008_equals_zero_l3477_347721


namespace mean_home_runs_l3477_347708

def home_runs_data : List (Nat × Nat) := [(5, 6), (6, 8), (4, 10)]

theorem mean_home_runs :
  let total_home_runs := (home_runs_data.map (λ (players, hrs) => players * hrs)).sum
  let total_players := (home_runs_data.map (λ (players, _) => players)).sum
  (total_home_runs : ℚ) / total_players = 118 / 15 := by
  sorry

end mean_home_runs_l3477_347708


namespace cos_is_valid_g_l3477_347701

def a (x : ℝ) : ℝ × ℝ := (1, x)
def b (f : ℝ → ℝ) (x : ℝ) : ℝ × ℝ := (f x, -x)

def dot_product (v w : ℝ × ℝ) : ℝ := v.1 * w.1 + v.2 * w.2

def is_even (f : ℝ → ℝ) : Prop := ∀ x, f x = f (-x)

theorem cos_is_valid_g (f : ℝ → ℝ) (g : ℝ → ℝ) :
  (∀ x, dot_product (a x) (b f x) = g x) →
  is_even f →
  g = cos :=
by sorry

end cos_is_valid_g_l3477_347701


namespace pencil_eraser_cost_problem_l3477_347792

theorem pencil_eraser_cost_problem :
  ∃ (p e : ℕ), 
    p > 0 ∧ 
    e > 0 ∧ 
    10 * p + 2 * e = 110 ∧ 
    p < e ∧ 
    p + e = 19 :=
by sorry

end pencil_eraser_cost_problem_l3477_347792


namespace division_problem_l3477_347726

theorem division_problem (dividend : ℕ) (divisor : ℕ) (remainder : ℕ) (quotient : ℕ) :
  dividend = 729 →
  divisor = 38 →
  remainder = 7 →
  dividend = divisor * quotient + remainder →
  quotient = 19 := by
sorry

end division_problem_l3477_347726


namespace not_always_true_point_not_in_plane_l3477_347771

-- Define the basic types
variable (Point Line Plane : Type)

-- Define the necessary relations
variable (belongs_to : Point → Line → Prop)
variable (belongs_to_plane : Point → Plane → Prop)
variable (line_in_plane : Line → Plane → Prop)

-- Define the theorem
theorem not_always_true_point_not_in_plane 
  (A : Point) (l : Line) (α : Plane) : 
  ¬(∀ A l α, ¬(line_in_plane l α) → belongs_to A l → ¬(belongs_to_plane A α)) :=
by sorry

end not_always_true_point_not_in_plane_l3477_347771


namespace inverse_f_negative_three_l3477_347712

def f (x : ℝ) : ℝ := 5 - 2 * x

theorem inverse_f_negative_three :
  (Function.invFun f) (-3) = 4 := by
  sorry

end inverse_f_negative_three_l3477_347712


namespace days_in_year_l3477_347715

/-- The number of days in a year, given the number of hours in a year and hours in a day -/
theorem days_in_year (hours_in_year : ℕ) (hours_in_day : ℕ) 
  (h1 : hours_in_year = 8760) (h2 : hours_in_day = 24) : 
  hours_in_year / hours_in_day = 365 := by
  sorry

end days_in_year_l3477_347715


namespace proposition_equivalence_l3477_347781

theorem proposition_equivalence (a : ℝ) : 
  (∀ x : ℝ, ((x < a ∨ x > a + 1) → (x ≤ 1/2 ∨ x ≥ 1)) ∧ 
   ∃ x : ℝ, (x ≤ 1/2 ∨ x ≥ 1) ∧ ¬(x < a ∨ x > a + 1)) ↔ 
  (0 ≤ a ∧ a ≤ 1/2) :=
by sorry

end proposition_equivalence_l3477_347781


namespace triangle_area_l3477_347764

-- Define the triangle ABC
structure Triangle where
  a : ℝ
  b : ℝ
  c : ℝ
  A : ℝ
  B : ℝ
  C : ℝ

-- Define the conditions
def satisfies_conditions (t : Triangle) : Prop :=
  t.b^2 + t.c^2 = t.a^2 - t.b * t.c ∧
  t.b * t.c * Real.cos t.A = -4

-- Theorem statement
theorem triangle_area (t : Triangle) 
  (h : satisfies_conditions t) : 
  (1/2) * t.b * t.c * Real.sin t.A = 2 * Real.sqrt 3 := by
  sorry

end triangle_area_l3477_347764


namespace product_of_difference_and_sum_of_squares_l3477_347706

theorem product_of_difference_and_sum_of_squares (a b : ℝ) 
  (h1 : a - b = 3) 
  (h2 : a^2 + b^2 = 35) : 
  a * b = 13 := by
sorry

end product_of_difference_and_sum_of_squares_l3477_347706
